<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8"/>
  <title>Portal Geof√≠sico y Ciberseguridad</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
      background: #0a0e1a;
      background-image: 
        radial-gradient(circle at 20% 50%, rgba(109, 213, 237, 0.03) 0%, transparent 50%),
        radial-gradient(circle at 80% 80%, rgba(255, 179, 71, 0.03) 0%, transparent 50%),
        repeating-linear-gradient(0deg, transparent, transparent 2px, rgba(109, 213, 237, 0.03) 2px, rgba(109, 213, 237, 0.03) 4px);
      color: #fff;
      overflow-x: hidden;
      height: 100vh;
      display: flex;
      flex-direction: column;
    }
    
    /* ========== TICKER DE NOTICIAS (ARRIBA) ========== */
    .news-ticker {
      background: linear-gradient(90deg, #1a1d2e 0%, #2a2d3e 100%);
      padding: 12px 0;
      border-bottom: 2px solid #3a4d6e;
      overflow: hidden;
      position: relative;
      height: 50px;
      display: flex;
      align-items: center;
    }
    
    .news-ticker-content {
      display: flex;
      white-space: nowrap;
      animation: scroll-left 60s linear infinite;
      gap: 60px;
    }
    
    .news-item {
      display: inline-flex;
      align-items: center;
      gap: 10px;
      font-size: 14px;
      color: #e0e6ed;
      cursor: pointer;
      transition: color 0.3s;
    }
    
    .news-item:hover {
      color: #6dd5ed;
    }
    
    .news-icon {
      font-size: 18px;
    }
    
    @keyframes scroll-left {
      0% { transform: translateX(0); }
      100% { transform: translateX(-50%); }
    }
    
    /* ========== CONTENEDOR PRINCIPAL ========== */
    .main-container {
      display: grid;
      grid-template-columns: 280px 1fr 280px;
      gap: 20px;
      padding: 20px;
      flex: 1;
      overflow: hidden;
      align-items: stretch;
      height: calc(100vh - 70px);
      box-sizing: border-box;
    }
    
    /* ========== PANEL LUNA (IZQUIERDA) ========== */
    .moon-panel {
      background: linear-gradient(135deg, #1a1d2e 0%, #2a2d3e 100%);
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
      position: sticky;
      top: 20px;
      align-self: flex-start;
      max-height: calc(100vh - 90px);
      overflow-y: auto;
    }
    
    .moon-panel h3 {
      font-size: 16px;
      color: #6dd5ed;
      text-align: center;
    }
    
    #moonCanvas {
      width: 200px;
      height: 200px;
      border-radius: 50%;
      display: none;
    }
    
    #moonImage {
      width: 200px;
      height: 200px;
      border-radius: 50%;
      object-fit: cover;
    }
    
    .moon-container {
      width: 210px;
      height: 210px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: #000;
      border-radius: 50%;
      box-shadow: 0 4px 16px rgba(109, 213, 237, 0.25);
      position: relative;
    }
    
    .moon-container .image-error, .sun-container .image-error {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      width: 180px;
      text-align: center;
      z-index: 10;
      background: rgba(10, 14, 26, 0.95);
      padding: 15px;
      border-radius: 50%;
      border: 2px dashed rgba(109, 213, 237, 0.3);
    }
    
    .moon-info {
      text-align: center;
      font-size: 13px;
      line-height: 1.6;
    }
    
    .moon-info strong {
      color: #6dd5ed;
    }
    
    /* ========== MAPAS CENTRALES ========== */
    /* Para miniaturas apiladas (uno encima de otro) */
    .maps-container {
      display: flex;
      flex-direction: column;
      gap: 16px;
      overflow-y: auto;
      align-items: stretch;
      padding-top: 8px;
      padding-bottom: 8px;
      padding-right: 4px;
      max-height: 100%;
    }
    /* Scrollbar fino y discreto */
    .maps-container::-webkit-scrollbar {
      width: 4px;
    }
    .maps-container::-webkit-scrollbar-track {
      background: rgba(0, 0, 0, 0.2);
      border-radius: 2px;
    }
    .maps-container::-webkit-scrollbar-thumb {
      background: rgba(109, 213, 237, 0.25);
      border-radius: 2px;
    }
    .maps-container::-webkit-scrollbar-thumb:hover {
      background: rgba(109, 213, 237, 0.4);
    }
    /* Firefox */
    @supports (scrollbar-width: thin) {
      .maps-container {
        scrollbar-width: thin;
        scrollbar-color: rgba(109, 213, 237, 0.25) rgba(0, 0, 0, 0.2);
      }
    }
    
    .map-card {
      background: linear-gradient(135deg, #1a1d2e 0%, #2a2d3e 100%);
      border-radius: 12px;
      overflow: hidden;
      box-shadow: 
        0 8px 32px rgba(0,0,0,0.4),
        0 0 0 1px rgba(109, 213, 237, 0.2),
        inset 0 1px 0 rgba(255,255,255,0.05);
      cursor: pointer;
      transition: all 0.3s ease;
      position: relative;
      min-height: 360px;  /* m√°s altura para acercar la proporci√≥n a los paneles laterales */
      display: flex;
      flex-direction: column;
      border: 1px solid rgba(109, 213, 237, 0.15);
    }
    
    .map-card:hover {
      transform: translateY(-5px);
      box-shadow: 
        0 16px 48px rgba(109, 213, 237, 0.3),
        0 0 0 2px rgba(109, 213, 237, 0.4),
        inset 0 1px 0 rgba(255,255,255,0.1);
      border-color: rgba(109, 213, 237, 0.5);
    }
    
    .map-header {
      padding: 15px 20px;
      background: rgba(26, 29, 46, 0.8);
      border-bottom: 2px solid #3a4d6e;
    }
    
    .map-header h3 {
      font-size: 18px;
      color: #6dd5ed;
      display: flex;
      align-items: center;
      gap: 10px;
    }
    
    .map-header p {
      font-size: 13px;
      color: #a0aec0;
      margin-top: 5px;
    }
    
    .map-preview {
      flex: 1;
      background: #0a0e1a;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 6px;  /* menos marco para mostrar m√°s mapa */
      position: relative;
      overflow: hidden;
      aspect-ratio: 1 / 1;   /* Proporci√≥n cuadrada para mostrar m√°s mapa y menos recorte */
      min-height: 360px;      /* incremento para equilibrar altura con laterales */
    }
    /* Para la tarjeta cyber: formato 16:9 y altura mayor */
    .cyber-card .map-preview {
      aspect-ratio: 16 / 9;
      min-height: 560px;
      padding: 0;
      position: relative;
      overflow: hidden;
    }
    
    .map-preview img {
      max-width: 100%;
      max-height: 100%;
      object-fit: contain;
      opacity: 0.7;
      transition: opacity 0.3s;
    }
    
    .map-card:hover .map-preview img {
      opacity: 1;
    }

    /* Miniaturas responsivas: en pantallas m√°s estrechas, formato casi cuadrado */
    @media (max-width: 1200px) {
      .map-preview {
        aspect-ratio: 1 / 1;
        min-height: 220px;
      }
    }
    
    .map-placeholder {
      font-size: 14px;
      color: #718096;
      text-align: center;
      opacity: 0.5;
      letter-spacing: 1px;
    }
    
    .map-overlay {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      font-size: 16px;
      color: #6dd5ed;
      background: rgba(10, 14, 26, 0.9);
      padding: 10px 20px;
      border-radius: 8px;
      opacity: 0;
      transition: opacity 0.3s;
      pointer-events: none;
    }
    
    .map-card:hover .map-overlay {
      opacity: 1;
    }
    
    /* ========== PANEL SOL (DERECHA) ========== */
    .sun-panel {
      background: linear-gradient(135deg, #1a1d2e 0%, #2a2d3e 100%);
      border-radius: 12px;
      padding: 20px;
      box-shadow: 0 8px 32px rgba(0,0,0,0.3);
      display: flex;
      flex-direction: column;
      align-items: center;
      gap: 15px;
      position: sticky;
      top: 20px;
      align-self: flex-start;
      max-height: calc(100vh - 90px);
      overflow-y: auto;
    }
    
    .sun-panel h3 {
      font-size: 16px;
      color: #6dd5ed;
      text-align: center;
    }
    
    .noaa-alerts-link {
      width: 100%;
      text-decoration: none;
  display: block;
      outline: none;
    }
    
    .noaa-alerts-badge {
      width: 100%;
      background: transparent;
      border: none;
      box-shadow: none;
  border-radius: 8px;
      padding: 4px 0 6px 0;
      display: flex;
      flex-direction: column;
      gap: 4px;
      align-items: center;
      text-align: center;
    }
    
    .noaa-alerts-badge .label {
      font-size: 12px;
      color: #e2e8f0;
      font-weight: 700;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .noaa-alerts-badge .pills {
      display: flex;
      gap: 8px;
      justify-content: center;
      width: 100%;
    }
    
    .noaa-alerts-badge .pill {
      min-width: 38px;
      text-align: center;
      padding: 5px 9px;
      border-radius: 8px;
      font-weight: 700;
      font-size: 12px;
      color: #0a0e1a;
      background: #e2e8f0;
      border: none;
      box-shadow: none;
      transition: background 0.3s, color 0.3s;
    }
    
    /* Escala NOAA correcta: 0=Verde, 1=Amarillo, 2=Naranja, 3=Rojo, 4-5=Rojo oscuro */
    .pill[data-level="0"] { background: #4caf50; color: #fff; }
    .pill.r-scale[data-level="0"] { background: #4caf50; color: #fff; }
    .pill.r-scale[data-level="1"] { background: #ffeb3b; color: #000; }
    .pill.r-scale[data-level="2"] { background: #ff9800; color: #fff; }
    .pill.r-scale[data-level="3"] { background: #f44336; color: #fff; }
    .pill.r-scale[data-level="4"] { background: #c62828; color: #fff; }
    .pill.r-scale[data-level="5"] { background: #8b0000; color: #fff; }
    
    .pill.s-scale[data-level="0"] { background: #4caf50; color: #fff; }
    .pill.s-scale[data-level="1"] { background: #ffeb3b; color: #000; }
    .pill.s-scale[data-level="2"] { background: #ff9800; color: #fff; }
    .pill.s-scale[data-level="3"] { background: #f44336; color: #fff; }
    .pill.s-scale[data-level="4"] { background: #c62828; color: #fff; }
    .pill.s-scale[data-level="5"] { background: #8b0000; color: #fff; }
    
    .pill.g-scale[data-level="0"] { background: #4caf50; color: #fff; }
    .pill.g-scale[data-level="1"] { background: #ffeb3b; color: #000; }
    .pill.g-scale[data-level="2"] { background: #ff9800; color: #fff; }
    .pill.g-scale[data-level="3"] { background: #f44336; color: #fff; }
    .pill.g-scale[data-level="4"] { background: #c62828; color: #fff; }
    .pill.g-scale[data-level="5"] { background: #8b0000; color: #fff; }
    
    .image-error {
      width: 160px;
      height: 160px;
      border-radius: 50%;
      background: #1a1d2e;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      font-size: 12px;
      color: #718096;
      padding: 20px;
      border: 2px dashed rgba(109, 213, 237, 0.3);
      font-weight: 500;
      letter-spacing: 0.5px;
    }
    
    .sun-info {
      text-align: center;
      font-size: 12px;
      line-height: 1.6;
      color: #a0aec0;
    }
    
    .sun-graphs {
      width: 100%;
      display: flex;
      flex-direction: column;
      gap: 10px;
      margin-top: 10px;
    }
    
    .mini-graph {
      display: flex;
      flex-direction: column;
      gap: 4px;
    }
    
    .mini-graph .label {
      font-size: 12px;
      color: #a0aec0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }
    
    .mini-graph a {
      display: block;
      border-radius: 8px;
      overflow: hidden;
      border: 1px solid rgba(109, 213, 237, 0.2);
      background: #0a0e1a;
    }
    
    .mini-graph img {
      width: 100%;
      display: block;
    }
    
    .graph-fallback {
      font-size: 12px;
      color: #718096;
      text-align: center;
      padding: 8px;
      background: #0a0e1a;
      border-radius: 6px;
      border: 1px dashed rgba(109, 213, 237, 0.2);
    }

    .source-logos {
      display: flex;
      justify-content: center;
      gap: 10px;
      margin-top: 10px;
    }

    .source-logo {
      height: 40px;
      width: auto;
      filter: drop-shadow(0 2px 6px rgba(0,0,0,0.45));
      background: transparent;
      padding: 0;
      border-radius: 0;
      border: none;
    }
    
    /* ========== INFO CONEXI√ìN (ABAJO) ========== */
    .connection-bar {
      background: linear-gradient(90deg, #1a1d2e 0%, #2a2d3e 100%);
      padding: 12px 20px;
      border-top: 2px solid #3a4d6e;
      cursor: pointer;
      transition: all 0.3s;
    }
    
    .connection-bar:hover {
      background: linear-gradient(90deg, #2a2d3e 0%, #3a3d4e 100%);
    }
    
    .connection-basic {
      display: flex;
      justify-content: space-between;
      align-items: center;
      font-size: 13px;
    }
    
    .connection-items {
      display: flex;
      gap: 30px;
      align-items: center;
    }
    
    .connection-item {
      display: flex;
      align-items: center;
      gap: 8px;
    }
    
    .connection-item .icon {
      font-size: 16px;
    }
    
    .status-online {
      color: #48bb78;
    }
    
    .status-offline {
      color: #f56565;
    }
    
    .expand-btn {
      color: #6dd5ed;
      font-size: 18px;
      transition: transform 0.3s;
    }
    
    .expand-btn.expanded {
      transform: rotate(180deg);
    }
    
    .connection-expanded {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }
    
    .connection-expanded.show {
      max-height: 300px;
    }
    
    .connection-details {
      padding: 20px;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
      gap: 15px;
      border-top: 1px solid #3a4d6e;
      margin-top: 10px;
    }
    
    .detail-item {
      display: flex;
      flex-direction: column;
      gap: 5px;
    }
    
    .detail-label {
      font-size: 11px;
      color: #718096;
      text-transform: uppercase;
      letter-spacing: 0.5px;
    }
    
    .detail-value {
  font-size: 14px;
      color: #e0e6ed;
      font-weight: 500;
    }
    
    /* ========== RESPONSIVE ========== */
    @media (max-width: 1200px) {
      .main-container {
        grid-template-columns: 1fr;
        grid-template-rows: auto 1fr auto;
      }
      
      .moon-panel, .sun-panel {
        flex-direction: row;
        justify-content: center;
      }
      
      #moonCanvas, #sdoImage {
        width: 150px;
        height: 150px;
      }
    }
    
    /* ========== LOADING ========== */
    .loading {
      color: #6dd5ed;
      animation: pulse 2s infinite;
    }
    
    @keyframes pulse {
      0%, 100% { opacity: 1; }
      50% { opacity: 0.5; }
    }
  </style>
</head>
<body>
  
  <!-- TICKER DE NOTICIAS -->
  <div class="news-ticker">
    <div class="news-ticker-content" id="newsTicker">
      <!-- Se llenar√° din√°micamente -->
  </div>
  </div>
  
  <!-- CONTENEDOR PRINCIPAL -->
  <div class="main-container">
    
    <!-- PANEL LUNA (IZQUIERDA) -->
    <div class="moon-panel">
      <h3>Fase Lunar</h3>
      <div class="moon-container">
        <img id="moonImage" alt="Fase Lunar" style="display: none;"/>
        <canvas id="moonCanvas" width="320" height="320" style="display: none;"></canvas>
        <div id="moonError" class="image-error" style="display: none;">
          FUENTE NO DISPONIBLE<br>
          <small>NASA SVS offline</small>
          <div class="image-timestamp" id="moonTimestamp"></div>
        </div>
      </div>
      <div class="moon-info" id="moonInfo">
        <div class="loading">Calculando...</div>
      </div>
    </div>
    
    <!-- MAPAS CENTRALES -->
    <div class="maps-container">
      
      <!-- Mapa Tierra (Terremotos y Volcanes) -->
      <div class="map-card" onclick="window.open('mapa_tierra_v2.html', '_blank')">
        <div class="map-header">
          <h3>Mapa Terrestre Geol√≥gico</h3>
        </div>
        <div class="map-preview">
          <!-- Miniatura interactiva (solo vista previa, sin interacci√≥n) -->
          <iframe 
            src="mapa_tierra_v2.html?preview=1" 
            title="Mini mapa terrestre" 
            id="mini-earth"
            style="position: absolute; top: 50%; left: 50%; width: 100%; height: 100%; border: none; overflow: hidden; pointer-events: none; filter: contrast(1.05) brightness(1); transform: translate(-50%, -50%); transform-origin: center;"
            loading="lazy">
          </iframe>
          <div class="map-overlay">Click para abrir ‚Üí</div>
        </div>
      </div>
      
      <!-- Mapa Cyberataques -->
      <div class="map-card cyber-card" onclick="window.open('mapa_cyber.html', '_blank')">
        <div class="map-header">
          <h3>Mapa Cybern√©tico</h3>
        </div>
        <div class="map-preview">
          <iframe 
            id="mini-cyber"
            src="mapa_cyber.html?preview=1" 
            title="Mini mapa cyber" 
            style="position: absolute; top: 50%; left: 50%; width: 180%; height: 180%; border: none; border-radius: 12px; overflow: hidden; pointer-events: none; filter: contrast(1) brightness(1); transform: translate(-50%, -50%) scale(0.95); transform-origin: center;"
            loading="lazy">
          </iframe>
          <div class="map-overlay">Click para abrir ‚Üí</div>
        </div>
      </div>
      
      <!-- Mapa Espa√±a -->
      <div class="map-card" onclick="alert('Mapa de Espa√±a - Pr√≥ximamente')">
        <div class="map-header">
          <h3>Mapa de Espa√±a</h3>
        </div>
        <div class="map-preview">
          <div class="map-placeholder">
            EN DESARROLLO<br>
            <small style="font-size: 11px; margin-top: 8px; display: block;">Pr√≥ximamente</small>
          </div>
        </div>
      </div>
      
    </div>
    
    <!-- PANEL SOL (DERECHA) -->
    <div class="sun-panel">
      <h3>Estado del Sol</h3>
      <div class="sun-container" style="width: 200px; height: 200px; display: flex; align-items: center; justify-content: center; background: #000; border-radius: 50%; box-shadow: 0 6px 24px rgba(255, 215, 0, 0.35); position: relative;">
        <img id="sdoImage" src="https://sdo.gsfc.nasa.gov/assets/img/latest/latest_1024_0171.jpg" alt="Sol SDO AIA 171" 
             onerror="handleSDOError(this)" style="display: block; width: 200px; height: 200px; border-radius: 50%; object-fit: cover;"/>
        <div id="sdoError" class="image-error" style="display: none;">
          FUENTE NO DISPONIBLE<br>
          <small>SDO/NASA offline</small>
          <div class="image-timestamp" id="sdoTimestamp"></div>
        </div>
      </div>
      <div class="sun-info">
        <strong>AIA 171 (Ultravioleta)</strong><br>
        Actualizaci√≥n: <span id="sdoTime">Cargando...</span>
      </div>
      <a class="noaa-alerts-link" href="https://www.swpc.noaa.gov/products/alerts-watches-and-warnings" target="_blank" rel="noopener">
        <div class="noaa-alerts-badge">
          <div class="label">Alertas solares 24h</div>
          <div class="pills" id="noaaAlertPills">
            <span class="pill r-scale" data-level="0">R0</span>
            <span class="pill s-scale" data-level="0">S0</span>
            <span class="pill g-scale" data-level="0">G0</span>
          </div>
          <div class="graph-fallback" id="noaaAlertFallback" style="display:none;">Alertas no disponibles.</div>
        </div>
      </a>
      <div class="sun-graphs">
        <div class="mini-graph">
          <div class="label">GOES X-ray (0.1-0.8 nm / 0.05-0.4 nm)</div>
          <a href="https://www.swpc.noaa.gov/products/goes-x-ray-flux" target="_blank" rel="noopener" style="display:block;">
            <div class="xray-frame" style="background:#0d101a;border:1px solid #2c2f3a;border-radius:10px;padding:8px;">
              <canvas id="xrayCanvas" width="560" height="260" style="width:100%;background:#000;border-radius:6px;display:block;"></canvas>
            </div>
          </a>
          <div class="graph-fallback" id="xrayFallback" style="display:none;">Gr√°fico X-ray no disponible ahora mismo.</div>
        </div>
        <div class="mini-graph">
          <div class="label">Viento solar (N/V/T)</div>
          <a href="https://www.swpc.noaa.gov/products/real-time-solar-wind" target="_blank" rel="noopener" style="display:block;">
            <div class="xray-frame" style="background:#0d101a;border:1px solid #2c2f3a;border-radius:10px;padding:8px;">
              <canvas id="solarWindCanvas" width="560" height="220" style="width:100%;background:#000;border-radius:6px;display:block;"></canvas>
            </div>
          </a>
          <div class="graph-fallback" id="solarWindFallback" style="display:none;">Viento solar no disponible ahora mismo.</div>
        </div>
        <div class="mini-graph">
          <div class="label">Campo geomagn√©tico (Kp reciente)</div>
          <a href="https://www.swpc.noaa.gov/products/planetary-k-index" target="_blank" rel="noopener" style="display:block;">
            <div class="xray-frame" style="background:#0d101a;border:1px solid #2c2f3a;border-radius:10px;padding:8px;">
              <canvas id="kpCanvas" width="560" height="180" style="width:100%;background:#000;border-radius:6px;display:block;"></canvas>
            </div>
          </a>
          <div class="graph-fallback" id="kpFallback" style="display:none;">Kp no disponible ahora mismo.</div>
        </div>
        <div class="mini-graph">
          <div class="label">Flares (131 √Ö)</div>
          <a href="https://services.swpc.noaa.gov/images/flares/pixels/primary/131/latest.png" target="_blank" rel="noopener" style="display:block;">
            <div class="xray-frame" style="background:#000;border:1px solid #2c2f3a;border-radius:10px;padding:6px; overflow:hidden; height:220px;">
              <img 
                src="https://services.swpc.noaa.gov/images/flares/pixels/primary/131/latest.png" 
                alt="Flares 131√Ö" 
                style="display:block; width:120%; height:120%; object-fit: cover; object-position: center; transform: translate(-10%, -10%);"
                onerror="this.style.display='none'; if(this.parentElement && this.parentElement.nextElementSibling){this.parentElement.nextElementSibling.style.display='block';}">
            </div>
          </a>
          <div class="graph-fallback" style="display:none; min-height:80px;">Imagen de flares no disponible ahora mismo.</div>
        </div>
      </div>
      <div class="source-logos">
        <a href="https://sdo.gsfc.nasa.gov/" target="_blank" rel="noopener" style="text-decoration:none;">
          <img class="source-logo" src="https://upload.wikimedia.org/wikipedia/commons/2/2f/SDO_logo.png" alt="SDO"
               onerror="this.onerror=null;this.src='data:image/svg+xml;utf8,<svg xmlns=%22http://www.w3.org/2000/svg%22 width=%2280%22 height=%2280%22 viewBox=%220 0 80 80%22><defs><linearGradient id=%22g%22 x1=%220%22 y1=%220%22 x2=%220%22 y2=%221%22><stop offset=%220%25%22 stop-color=%22%23f6d14a%22/><stop offset=%22100%25%22 stop-color=%22%23b47b1c%22/></linearGradient></defs><circle cx=%2240%22 cy=%2240%22 r=%2238%22 fill=%22url(%23g)%22 stroke=%22%23ffffff%22 stroke-width=%222%22/><text x=%2240%22 y=%2248%22 font-family=%22Segoe UI,Arial%22 font-size=%2220%22 fill=%22%23000000%22 text-anchor=%22middle%22 font-weight=%22bold%22>SDO</text></svg>';this.style.background='rgba(13,16,26,0.85)';">
        </a>
        <a href="https://www.swpc.noaa.gov/" target="_blank" rel="noopener" style="text-decoration:none;">
          <img class="source-logo" src="https://upload.wikimedia.org/wikipedia/commons/7/79/NOAA_logo.svg" alt="NOAA/SWPC"
               onerror="this.onerror=null;this.src='data:image/svg+xml;utf8,<svg xmlns=%22http://www.w3.org/2000/svg%22 width=%2280%22 height=%2280%22 viewBox=%220 0 80 80%22><defs><linearGradient id=%22g2%22 x1=%220%22 y1=%220%22 x2=%220%22 y2=%221%22><stop offset=%220%25%22 stop-color=%22%23158bff%22/><stop offset=%22100%25%22 stop-color=%22%2300438b%22/></linearGradient></defs><circle cx=%2240%22 cy=%2240%22 r=%2238%22 fill=%22url(%23g2)%22 stroke=%22%23ffffff%22 stroke-width=%222%22/><text x=%2240%22 y=%2248%22 font-family=%22Segoe UI,Arial%22 font-size=%2218%22 fill=%22%23ffffff%22 text-anchor=%22middle%22 font-weight=%22bold%22>NOAA</text></svg>';this.style.background='rgba(13,16,26,0.85)';">
        </a>
      </div>
    </div>
    
  </div>
  
  <!-- BARRA DE CONEXI√ìN (ABAJO) -->
  <div class="connection-bar" onclick="toggleConnection()">
    <div class="connection-basic">
      <div class="connection-items">
        <div class="connection-item">
          <span class="icon">üåê</span>
          <span id="userIP">Cargando IP...</span>
        </div>
        <div class="connection-item">
          <span class="icon">üìç</span>
          <span id="userLocation">Cargando...</span>
        </div>
        <div class="connection-item">
          <span class="icon">‚ö°</span>
          <span id="userPing">-- ms</span>
        </div>
        <div class="connection-item">
          <span class="icon status-online" id="statusIcon">‚úì</span>
          <span id="statusText">Online</span>
        </div>
      </div>
      <div class="expand-btn" id="expandBtn">‚ñº</div>
    </div>
    
    <div class="connection-expanded" id="connectionDetails">
      <div class="connection-details">
        <div class="detail-item">
          <span class="detail-label">IP P√∫blica</span>
          <span class="detail-value" id="detailIP">--</span>
        </div>
        <div class="detail-item">
          <span class="detail-label">Ubicaci√≥n</span>
          <span class="detail-value" id="detailLocation">--</span>
        </div>
        <div class="detail-item">
          <span class="detail-label">ISP</span>
          <span class="detail-value" id="detailISP">--</span>
        </div>
        <div class="detail-item">
          <span class="detail-label">Navegador</span>
          <span class="detail-value" id="detailBrowser">--</span>
        </div>
        <div class="detail-item">
          <span class="detail-label">Sistema</span>
          <span class="detail-value" id="detailOS">--</span>
        </div>
        <div class="detail-item">
          <span class="detail-label">Resoluci√≥n</span>
          <span class="detail-value" id="detailResolution">--</span>
        </div>
      </div>
    </div>
  </div>
  
  <script src="https://unpkg.com/suncalc@1.9.0/suncalc.js"></script>
  <script>
    'use strict';
    const XRAY_ENDPOINTS = [
      'https://services.swpc.noaa.gov/json/goes/primary/xrays-3-day.json',
      'https://services.swpc.noaa.gov/json/goes/secondary/xrays-3-day.json',
      'https://services.swpc.noaa.gov/json/goes/primary/xrays-1-day.json',
      'https://services.swpc.noaa.gov/json/goes/secondary/xrays-1-day.json'
    ];
    
    // ========== NOTICIAS (TICKER CON CACHE) ==========
    const NEWS_CACHE_KEY = 'cached_news';
    const NEWS_CACHE_DURATION = 3600000; // 1 hora
    const GRAPHS_CACHE_DURATION = 300000; // 5 minutos para gr√°ficas
    const AEMET_API_KEY = 'eyJhbGciOiJIUzI1NiJ9.eyJzdWIiOiJoYWxtYW4xNDlAaG90bWFpbC5jb20iLCJqdGkiOiI2YWQxYzdjYS1hODhmLTRhYjMtYjQyNi1mYmUwM2YzYjEyZjUiLCJpc3MiOiJBRU1FVCIsImlhdCI6MTc2NTc5Mjg3OCwidXNlcklkIjoiNmFkMWM3Y2EtYTg4Zi00YWIzLWI0MjYtZmJlMDNmM2IxMmY1Iiwicm9sZSI6IiJ9.yGnTuT_EYPP_l0q_l9-_bYtpQhLDxvRBuX9YwZ7gdPo';
    
    // Sistema de proxies m√∫ltiples (fallback) como en mapa_cyber
    const PROXIES = [
      (url) => `https://corsproxy.io/?${encodeURIComponent(url)}`,
      (url) => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`,
      (url) => `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(url)}`,
      (url) => url // intento directo sin proxy
    ];
    
    const FALLBACK_NEWS = [
      { icon: 'üåç', text: 'Sistema de monitoreo geof√≠sico activo', url: '#' },
      { icon: 'üåã', text: 'Red de vigilancia volc√°nica operativa', url: '#' },
      { icon: '‚òÄÔ∏è', text: 'Monitoreo solar SDO/NASA en l√≠nea', url: '#' },
      { icon: 'üîí', text: 'Sistema de ciberseguridad actualizado', url: '#' },
      { icon: 'üå°Ô∏è', text: 'Monitoreo meteorol√≥gico Espa√±a operativo', url: '#' },
      { icon: 'üõ∞Ô∏è', text: 'Seguimiento ISS en tiempo real', url: '#' },
      { icon: 'üì°', text: 'Conexi√≥n a fuentes de datos establecida', url: '#' },
      { icon: 'üåê', text: 'Portal geof√≠sico en tiempo real', url: '#' }
    ];
    
    async function fetchRealNews() {
      try {
        const tasks = [];
        
        tasks.push((async () => {
          try {
            // Cambio a terremotos M4.5+ del √∫ltimo d√≠a (m√°s actuales)
            const quakeResponse = await fetch('https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/4.5_day.geojson', { signal: AbortSignal.timeout(8000) });
            const quakeData = await quakeResponse.json();
            if (!quakeData.features?.length) return [];
            
            // Filtrar solo los √∫ltimos 24h y ordenar por tiempo (m√°s reciente primero)
            const now = Date.now();
            const oneDayAgo = now - (24 * 60 * 60 * 1000);
            const recentQuakes = quakeData.features
              .filter(quake => quake.properties.time >= oneDayAgo)
              .sort((a, b) => b.properties.time - a.properties.time)
              .slice(0, 3);
            
            if (!recentQuakes.length) return [];
            
            return recentQuakes.map(quake => {
              const timeAgo = Math.floor((now - quake.properties.time) / (1000 * 60 * 60));
              const timeStr = timeAgo === 0 ? 'hace menos de 1h' : `hace ${timeAgo}h`;
              return {
                icon: 'üåç',
                text: `Terremoto M${quake.properties.mag.toFixed(1)} en ${quake.properties.place} (${timeStr})`,
                url: quake.properties.url || '#'
              };
            });
          } catch (e) {
            console.warn('‚ö†Ô∏è Error terremotos USGS:', e.message);
            return [];
          }
        })());
        
        tasks.push((async () => {
          try {
            const spaceUrl = 'https://services.swpc.noaa.gov/products/alerts.json';
            const spaceResponse = await fetch(`https://corsproxy.io/?${encodeURIComponent(spaceUrl)}`, { signal: AbortSignal.timeout(8000) });
            const spaceData = await spaceResponse.json();
            if (!spaceData?.length) return [];
            return spaceData.slice(0, 2).map(alert => ({
              icon: '‚òÄÔ∏è',
              text: (alert.message || alert.summary || '').substring(0, 80),
              url: 'https://www.swpc.noaa.gov/'
            })).filter(n => n.text.length > 10 && n.text.length < 100);
          } catch (e) {
            console.warn('‚ö†Ô∏è Error clima espacial NOAA:', e.message);
            return [];
          }
        })());
        
        tasks.push((async () => {
          try {
            const hurricaneUrl = 'https://www.nhc.noaa.gov/CurrentStorms.json';
            const hurricaneResponse = await fetch(`https://corsproxy.io/?${encodeURIComponent(hurricaneUrl)}`, { signal: AbortSignal.timeout(8000) });
            const hurricaneData = await hurricaneResponse.json();
            if (!hurricaneData.activeStorms?.length) return [];
            return hurricaneData.activeStorms.slice(0, 2).map(storm => ({
              icon: 'üåÄ',
              text: `${storm.stormType || 'Tormenta'} ${storm.name || storm.stormName || 'Sin nombre'} activo`,
              url: 'https://www.nhc.noaa.gov/'
            }));
          } catch (e) {
            console.warn('‚ö†Ô∏è Error huracanes NOAA:', e.message);
            return [];
          }
        })());
        
        tasks.push((async () => {
          try {
            const issUrl = 'http://api.open-notify.org/iss-now.json';
            const issResponse = await fetch(`https://corsproxy.io/?${encodeURIComponent(issUrl)}`, { signal: AbortSignal.timeout(8000) });
            const issData = await issResponse.json();
            if (!issData.iss_position) return [];
            
            const lat = parseFloat(issData.iss_position.latitude).toFixed(1);
            const lon = parseFloat(issData.iss_position.longitude).toFixed(1);
            let region = 'Oc√©ano';
            if (lat > 35 && lat < 45 && lon > -10 && lon < 5) region = 'Europa';
            else if (lat > 25 && lat < 50 && lon > -130 && lon < -60) region = 'Am√©rica del Norte';
            else if (lat > -60 && lat < 15 && lon > -85 && lon < -30) region = 'Am√©rica del Sur';
            else if (lat > -40 && lat < 40 && lon > 95 && lon < 150) region = 'Asia-Pac√≠fico';
            
            return [{
              icon: 'üõ∞Ô∏è',
              text: `ISS sobrevolando ${region} (${lat}¬∞, ${lon}¬∞)`,
              url: 'https://spotthestation.nasa.gov/'
            }];
          } catch (e) {
            console.warn('‚ö†Ô∏è Error ISS tracker:', e.message);
            return [];
          }
        })());
        
        // ELIMINADO: Ciberseguridad sint√©tica (usaba Math.random)
        
        tasks.push((async () => {
          try {
            const today = new Date();
            const dateStr = today.toISOString().split('T')[0];
            const asteroidUrl = `https://ssd-api.jpl.nasa.gov/cad.api?date-min=${dateStr}&dist-max=0.05`;
            const asteroidResponse = await fetch(`https://corsproxy.io/?${encodeURIComponent(asteroidUrl)}`, { signal: AbortSignal.timeout(8000) });
            const asteroidData = await asteroidResponse.json();
            if (!asteroidData?.data?.length) return [];
            const closest = asteroidData.data[0];
            const name = closest[0] || 'Desconocido';
            const distLD = parseFloat(closest[4]).toFixed(2);
            return [{
              icon: '‚òÑÔ∏è',
              text: `Asteroide ${name} pasar√° a ${distLD} distancias lunares de la Tierra`,
              url: 'https://cneos.jpl.nasa.gov/ca/'
            }];
          } catch (e) {
            console.warn('‚ö†Ô∏è Error asteroides NASA:', e.message);
            return [];
          }
        })());
        
        tasks.push((async () => {
          try {
            const volcanicUrl = 'https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_day.geojson';
            const volcanicResponse = await fetch(volcanicUrl, { signal: AbortSignal.timeout(8000) });
            const volcanicData = await volcanicResponse.json();
            if (!volcanicData.features) return [];
            let volcanicActivity = 0;
            volcanicData.features.forEach(quake => {
              const depth = quake.geometry.coordinates[2];
              const place = quake.properties.place?.toLowerCase() || '';
              if (depth < 10 && (place.includes('volcano') || place.includes('volcanic'))) {
                volcanicActivity++;
              }
            });
            if (!volcanicActivity) return [];
            return [{
              icon: 'üåã',
              text: `${volcanicActivity} eventos s√≠smicos volc√°nicos detectados hoy`,
              url: 'https://volcano.si.edu/'
            }];
          } catch (e) {
            console.warn('‚ö†Ô∏è Error actividad volc√°nica:', e.message);
            return [];
          }
        })());
        
        // Funci√≥n auxiliar para extraer avisos AEMET con regex (fallback si XML falla)
        function extractAemetWithRegex(rssText) {
          try {
            console.log('üîç Extrayendo con regex, RSS length:', rssText.length);
            const results = [];
            // Extraer items con regex (m√°s permisivo)
            const itemRegex = /<item[^>]*>([\s\S]*?)<\/item>/gi;
            let match;
            let count = 0;
            let itemsFound = 0;
            
            while ((match = itemRegex.exec(rssText)) !== null && count < 10) {
              itemsFound++;
              const itemContent = match[1];
              
              // Extraer t√≠tulo (muy permisivo)
              const titleMatch = itemContent.match(/<title[^>]*>(?:<!\[CDATA\[)?([\s\S]*?)(?:\]\]>)?<\/title>/i);
              let title = titleMatch ? titleMatch[1] : '';
              title = title.replace(/<!\[CDATA\[|\]\]>/g, '').replace(/<[^>]+>/g, '').trim();
              
              // Extraer link
              const linkMatch = itemContent.match(/<link[^>]*>(?:<!\[CDATA\[)?(.*?)(?:\]\]>)?<\/link>/i);
              const link = linkMatch ? linkMatch[1].trim() : 'https://www.aemet.es/es/eltiempo/prediccion/avisos';
              
              console.log(`  [${itemsFound}] T√≠tulo extra√≠do: "${title.substring(0, 80)}..."`);
              
              if (title && title.length > 5 && !title.includes('xmlns') && !title.includes('<?xml')) {
                const text = title.toLowerCase();
                
                // Filtrar solo metadata obvia (ser muy permisivo)
                const isObviousMetadata = (text.includes('actualizaci√≥n') && text.includes('mapa')) ||
                                         text.includes('<?xml') ||
                                         text.length < 10;
                
                if (!isObviousMetadata) {
                  let icon = '‚ö†Ô∏è';
                  if (text.includes('nieve') || text.includes('nevada')) icon = '‚ùÑÔ∏è';
                  else if (text.includes('viento')) icon = 'üí®';
                  else if (text.includes('lluvia')) icon = 'üåßÔ∏è';
                  else if (text.includes('tormenta')) icon = '‚õàÔ∏è';
                  else if (text.includes('costa') || text.includes('mar') || text.includes('oleaje')) icon = 'üåä';
                  else if (text.includes('calor') || text.includes('temperatura')) icon = 'üå°Ô∏è';
                  else if (text.includes('niebla')) icon = 'üå´Ô∏è';
                  else if (text.includes('hielo') || text.includes('helada')) icon = 'üßä';
                  
                  console.log(`    ‚úì Extra√≠do (regex): "${title}"`);
                  results.push({
                    icon,
                    text: `${title} (AEMET)`,
                    url: link
                  });
                  count++;
                }
              }
            }
            
            console.log(`üìä Regex: ${itemsFound} items encontrados, ${results.length} avisos v√°lidos`);
            
            if (results.length) {
              console.log(`‚úÖ ${results.length} avisos AEMET extra√≠dos con regex`);
              return results;
            } else {
              console.log(`‚ÑπÔ∏è AEMET: No se encontraron avisos v√°lidos (${itemsFound} items procesados)`);
              return [{ icon: '‚ÑπÔ∏è', text: 'AEMET: sin avisos meteorol√≥gicos destacados', url: 'https://www.aemet.es/es/eltiempo/prediccion/avisos', _isAemetPlaceholder: true }];
            }
          } catch (e) {
            console.error('‚ùå Error en extracci√≥n regex AEMET:', e.message);
            return [];
          }
        }
        
        tasks.push((async () => {
          try {
            console.log('üìã AEMET: Intentando API oficial con API key...');
            
            // M√âTODO 1: API Oficial de AEMET (con proxy CORS)
            let apiResults = null;
            try {
              const apiUrl = 'https://opendata.aemet.es/opendata/api/avisos/ultimoElaborado';
              
              // La API de AEMET tiene CORS bloqueado, necesitamos proxy
              // Pero los proxies no pasan headers personalizados, as√≠ que a√±adimos la key a la URL
              const apiUrlWithKey = `${apiUrl}?api_key=${AEMET_API_KEY}`;
              
              let metadata = null;
              // Intentar con proxies (solo los 2 primeros, los m√°s r√°pidos)
              for (let i = 0; i < 2 && !metadata; i++) {
                try {
                  const proxyUrl = PROXIES[i](apiUrlWithKey);
                  console.log(`  ‚Üí Intentando API oficial con proxy ${i+1}...`);
                  const apiResponse = await fetch(proxyUrl, { signal: AbortSignal.timeout(12000) });
                  
                  if (apiResponse.ok) {
                    const text = await apiResponse.text();
                    console.log(`  üìÑ Respuesta API (primeros 200 chars):`, text.substring(0, 200));
                    metadata = JSON.parse(text);
                    console.log(`  ‚úì Metadata obtenida con proxy ${i+1}:`, metadata.estado, metadata.descripcion);
                    break;
                  } else {
                    console.warn(`  ‚úó Proxy ${i+1} respuesta no OK:`, apiResponse.status);
                  }
                } catch (e) {
                  console.warn(`  ‚úó Proxy ${i+1} fall√≥ para API:`, e.message);
                }
              }
              
              if (metadata && metadata.estado === 200 && metadata.datos) {
                // Obtener datos reales desde URL temporal (tambi√©n con proxy por si acaso)
                let avisos = null;
                for (let i = 0; i < 2 && !avisos; i++) {
                  try {
                    const datosProxyUrl = PROXIES[i](metadata.datos);
                    const datosResponse = await fetch(datosProxyUrl, { signal: AbortSignal.timeout(10000) });
                    if (datosResponse.ok) {
                      avisos = await datosResponse.json();
                      break;
                    }
                  } catch (e) {
                    // Intentar sin proxy como fallback
                    if (i === 1) {
                      const datosResponse = await fetch(metadata.datos, { signal: AbortSignal.timeout(10000) });
                      avisos = await datosResponse.json();
                    }
                  }
                }
                
                if (avisos) {
                  console.log(`  ‚úì Datos cargados: ${Array.isArray(avisos) ? avisos.length : 'N/A'} avisos`);
                  
                  // Procesar avisos JSON
                  const results = [];
                  if (Array.isArray(avisos)) {
                    for (const aviso of avisos.slice(0, 10)) {
                      // Extraer informaci√≥n del aviso
                      const provincia = aviso.area?.areaDesc || aviso.provinciaDesc || 'Espa√±a';
                      const fenomeno = aviso.fenomeno || aviso.evento || '';
                      const nivel = aviso.nivel || aviso.nivel_max || '';
                      
                      if (fenomeno && provincia) {
                        let icon = '‚ö†Ô∏è';
                        const text = (fenomeno + ' ' + provincia).toLowerCase();
                        
                        if (text.includes('nieve') || text.includes('nevada')) icon = '‚ùÑÔ∏è';
                        else if (text.includes('viento')) icon = 'üí®';
                        else if (text.includes('lluvia')) icon = 'üåßÔ∏è';
                        else if (text.includes('tormenta')) icon = '‚õàÔ∏è';
                        else if (text.includes('costa') || text.includes('mar') || text.includes('oleaje')) icon = 'üåä';
                        else if (text.includes('calor') || text.includes('temperatura')) icon = 'üå°Ô∏è';
                        else if (text.includes('niebla')) icon = 'üå´Ô∏è';
                        
                        const nivelText = nivel ? ` (${nivel})` : '';
                        results.push({
                          icon,
                          text: `${provincia}: ${fenomeno}${nivelText} (AEMET)`,
                          url: 'https://www.aemet.es/es/eltiempo/prediccion/avisos'
                        });
                      }
                    }
                  }
                  
                  if (results.length) {
                    console.log(`‚úÖ ${results.length} avisos AEMET cargados desde API oficial`);
                    apiResults = results;
                  } else {
                    console.log('‚ÑπÔ∏è API oficial sin avisos activos');
                  }
                }
              } else {
                console.warn('‚ö†Ô∏è No se pudieron obtener datos desde URL temporal');
              }
            } catch (apiError) {
              console.error('‚ùå API oficial AEMET error cr√≠tico:', apiError.message, apiError.stack);
            }
            
            // Si la API funcion√≥, devolver sus resultados
            if (apiResults && apiResults.length > 0) {
              return apiResults;
            }
            
            // M√âTODO 2: RSS de AEMET (fallback)
            console.log('üìã AEMET: Intentando RSS de avisos (fallback)...');
            const aemetRssUrl = 'https://www.aemet.es/es/eltiempo/prediccion/avisos/rss';
            
            let rssText = null;
            // Intentar cada proxy en secuencia
            for (let i = 0; i < PROXIES.length; i++) {
              try {
                const proxyUrl = PROXIES[i](aemetRssUrl);
                console.log(`  ‚Üí Proxy ${i+1}/${PROXIES.length}...`);
                const rssResponse = await fetch(proxyUrl, { signal: AbortSignal.timeout(10000) });
                if (rssResponse.ok) {
                  rssText = await rssResponse.text();
                  console.log(`  ‚úì Proxy ${i+1} exitoso!`);
                  break;
                }
              } catch (e) {
                console.warn(`  ‚úó Proxy ${i+1} fall√≥: ${e.message}`);
              }
            }
            
            if (!rssText) {
              console.warn('AEMET RSS: Todos los proxies fallaron');
              return [];
            }
            
            // Limpieza AGRESIVA del RSS de AEMET (tiene muchos problemas de formato)
            let cleanedRss = rssText
              // Eliminar etiquetas <source> problem√°ticas
              .replace(/<source[^>]*>/gi, '')
              .replace(/<\/source>/gi, '')
              // Eliminar comentarios XML
              .replace(/<!--[\s\S]*?-->/g, '')
              // Arreglar tags sin cerrar comunes en AEMET
              .replace(/<br>/gi, '<br/>')
              .replace(/<hr>/gi, '<hr/>')
              .replace(/<img([^>]*)>/gi, '<img$1/>')
              // Eliminar espacios/saltos de l√≠nea excesivos
              .replace(/\s{2,}/g, ' ')
              .trim();
            
            // Re-a√±adir declaraci√≥n XML limpia al inicio
            if (!cleanedRss.startsWith('<?xml')) {
              cleanedRss = '<?xml version="1.0" encoding="UTF-8"?>\n' + cleanedRss;
            }
            
            console.log('üìã AEMET: RSS limpiado, intentando parsear...');
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(cleanedRss, 'text/xml');
            
            const parseError = xmlDoc.querySelector('parsererror');
            if (parseError) {
              console.error('‚ùå AEMET RSS con parsererror tras limpieza:');
              console.error(parseError.textContent);
              // Intentar extraer datos con regex como fallback
              console.log('üîÑ Intentando extracci√≥n alternativa con regex...');
              return extractAemetWithRegex(rssText);
            }
            const items = xmlDoc.getElementsByTagName('item');
            if (!items.length) return [];
            
            const results = [];
            console.log(`üìã AEMET: Procesando ${items.length} items del RSS...`);
            
            for (let i = 0; i < Math.min(10, items.length); i++) {
              const titleElem = items[i].getElementsByTagName('title')[0];
              const linkElem = items[i].getElementsByTagName('link')[0];
              const descElem = items[i].getElementsByTagName('description')[0];
              
              let title = titleElem?.textContent || titleElem?.text || '';
              const link = linkElem?.textContent || 'https://www.aemet.es/es/eltiempo/prediccion/avisos';
              let desc = descElem?.textContent || descElem?.text || '';
              
              title = title.replace(/<!\[CDATA\[|\]\]>/g, '').trim();
              desc = desc.replace(/<!\[CDATA\[|\]\]>/g, '').trim();
              
              console.log(`  [${i+1}] T√≠tulo RAW: "${title}"`);
              
              if (title && title.length > 5 && !title.includes('xmlns')) {
                let icon = '‚ö†Ô∏è';
                const text = (title + ' ' + desc).toLowerCase();
                
                // Asignar icono seg√∫n el tipo de aviso
                if (text.includes('nieve') || text.includes('nevada')) icon = '‚ùÑÔ∏è';
                if (text.includes('viento')) icon = 'üí®';
                if (text.includes('lluvia')) icon = 'üåßÔ∏è';
                if (text.includes('tormenta')) icon = '‚õàÔ∏è';
                if (text.includes('costa') || text.includes('mar') || text.includes('oleaje')) icon = 'üåä';
                if (text.includes('calor') || text.includes('temperatura') || text.includes('m√°ximas')) icon = 'üå°Ô∏è';
                if (text.includes('niebla')) icon = 'üå´Ô∏è';
                if (text.includes('hielo') || text.includes('helada')) icon = 'üßä';
                
                // FILTRO MUY PERMISIVO: Solo excluir si NO es un aviso real
                // Excluir solo t√≠tulos que son claramente metadata o no-avisos
                const isMetadata = title.toLowerCase().includes('actualizaci√≥n') && 
                                  title.toLowerCase().includes('mapa') && 
                                  title.toLowerCase().includes('avisos');
                
                if (!isMetadata) {
                  console.log(`    ‚úì Incluido: "${title}"`);
                  results.push({
                    icon,
                    text: `${title} (AEMET)`,
                    url: link
                  });
                } else {
                  console.log(`    ‚úó Filtrado (metadata): "${title}"`);
                }
              }
            }
            
            if (results.length) {
              console.log(`‚úÖ ${results.length} avisos AEMET cargados desde RSS`);
              return results;
            } else {
              // Si el feed tiene items pero todos fueron filtrados, no devolver nada
              // Si el feed est√° vac√≠o, devolver indicador especial
              if (items.length === 0) {
                console.log('‚ÑπÔ∏è AEMET RSS: Feed vac√≠o (sin avisos publicados)');
                return [{ icon: '‚ÑπÔ∏è', text: 'AEMET: sin avisos meteorol√≥gicos destacados', url: 'https://www.aemet.es/es/eltiempo/prediccion/avisos', _isAemetPlaceholder: true }];
              } else {
                console.log(`‚ÑπÔ∏è AEMET RSS: ${items.length} avisos encontrados pero filtrados (riesgo bajo)`);
                return []; // No mostrar nada si solo hay avisos de riesgo bajo
              }
            }
          } catch (e) {
            console.warn('‚ö†Ô∏è AEMET API no disponible:', e.message);
            return [];
          }
        })());
        
        const settled = await Promise.allSettled(tasks);
        const allNews = [];
        settled.forEach(r => {
          if (r.status === 'fulfilled' && Array.isArray(r.value)) {
            allNews.push(...r.value);
          }
        });
        
        // No a√±adir fallback aqu√≠ - AEMET ya maneja su propio fallback si el feed est√° vac√≠o
        // ELIMINADO: Manchas solares sint√©ticas (usaban Math.random)
        
        if (allNews.length > 0) {
          localStorage.setItem(NEWS_CACHE_KEY, JSON.stringify({ news: allNews, timestamp: Date.now() }));
          console.log(`‚úì ${allNews.length} noticias reales cargadas`);
          return allNews;
        }
        return null;
      } catch (error) {
        console.warn('‚ö†Ô∏è Error general cargando noticias:', error);
        return null;
      }
    }
    
    async function initNews() {
      let newsItems = FALLBACK_NEWS;
      
      // Intentar cargar desde cache primero
      try {
        const cached = localStorage.getItem(NEWS_CACHE_KEY);
        if (cached) {
          const { news, timestamp } = JSON.parse(cached);
          if (Date.now() - timestamp < NEWS_CACHE_DURATION) {
            newsItems = news.length > 0 ? news : FALLBACK_NEWS;
            console.log('‚úì Usando noticias cacheadas');
          }
        }
      } catch (e) {
        console.warn('‚ö†Ô∏è Error leyendo cache de noticias');
      }
      
      // Mostrar noticias (cacheadas o fallback)
      displayNews(newsItems);
      
      // Intentar actualizar con noticias reales en background
      const realNews = await fetchRealNews();
      if (realNews && realNews.length > 0) {
        displayNews(realNews);
        console.log('‚úì Noticias actualizadas en tiempo real');
      }
    }
    
    function displayNews(newsItems) {
      const ticker = document.getElementById('newsTicker');
      // Duplicar noticias para scroll infinito
      const doubled = [...newsItems, ...newsItems];
      ticker.innerHTML = doubled.map(item => 
        `<div class="news-item" onclick="window.open('${item.url}', '_blank')">
          <span class="news-icon">${item.icon}</span>
          <span>${item.text}</span>
        </div>`
      ).join('');
    }
    
    // Actualizar noticias cada 15 minutos
    setInterval(async () => {
      const realNews = await fetchRealNews();
      if (realNews && realNews.length > 0) {
        displayNews(realNews);
      }
    }, 900000); // 15 minutos
    
    // ========== LUNA (IM√ÅGENES REALES NASA) ==========
    function drawMoon() {
      const now = new Date();
      
      // Calcular fase lunar con SunCalc para info
      const moonIllum = SunCalc.getMoonIllumination(now);
      const phase = moonIllum.phase;
      const fraction = moonIllum.fraction;
      
      const phaseNames = [
        'Luna Nueva', 'Creciente', 'Cuarto Creciente', 'Gibosa Creciente',
        'Luna Llena', 'Gibosa Menguante', 'Cuarto Menguante', 'Menguante'
      ];
      const phaseIndex = Math.floor(phase * 8) % 8;
      const phaseName = phaseNames[phaseIndex];
      const illumination = (fraction * 100).toFixed(1);
      
      // Intentar cargar imagen real de NASA SVS
      loadNASAMoonImage(now, phaseName, illumination);
    }
    
    function loadNASAMoonImage(date, phaseName, illumination) {
      const year = date.getUTCFullYear();
      
      // Solo funciona para 2025 (el dataset de NASA SVS que tenemos)
      if (year !== 2025) {
        useFallbackMoon(phaseName, illumination, date);
        return;
      }
      
      // Calcular frame number (hora desde inicio del a√±o)
      const startOfYear = new Date(Date.UTC(2025, 0, 1, 0, 0, 0));
      const hoursSinceStart = Math.floor((date - startOfYear) / (1000 * 60 * 60));
      const frameNumber = String(hoursSinceStart + 1).padStart(4, '0');
      
      // URL de la imagen NASA SVS con proxy CORS
      const nasaDirectUrl = `https://svs.gsfc.nasa.gov/vis/a000000/a005400/a005415/frames/730x730_1x1_30p/moon.${frameNumber}.jpg`;
      const nasaUrl = `https://corsproxy.io/?${encodeURIComponent(nasaDirectUrl)}`;
      
      const moonImg = document.getElementById('moonImage');
      const canvas = document.getElementById('moonCanvas');
      
      // Intentar cargar imagen
      const testImg = new Image();
      
      testImg.onload = function() {
        // √âxito - mostrar imagen real
        moonImg.src = nasaUrl;
        moonImg.style.display = 'block';
        canvas.style.display = 'none';
        
        updateMoonInfo(phaseName, illumination, date, true);
        console.log('‚úì Luna NASA cargada (frame:', frameNumber, ')');
        console.log('   URL:', nasaDirectUrl);
      };
      
      testImg.onerror = function(e) {
        // Fall√≥ - mostrar mensaje de error profesional
        console.error('‚ùå No se pudo cargar imagen NASA');
        console.error('   Frame:', frameNumber);
        console.error('   URL:', nasaDirectUrl);
        
        const moonImg = document.getElementById('moonImage');
        const moonError = document.getElementById('moonError');
        const canvas = document.getElementById('moonCanvas');
        
        moonImg.style.display = 'none';
        canvas.style.display = 'none';
        moonError.style.display = 'flex';
        
        updateMoonInfo(phaseName, illumination, date, false);
      };
      
      console.log('üåô Intentando cargar luna NASA (frame:', frameNumber, ')...');
      testImg.src = nasaUrl;
    }
    
    function useFallbackMoon(phaseName, illumination, date) {
      // Mostrar mensaje de error profesional
      const moonImg = document.getElementById('moonImage');
      const canvas = document.getElementById('moonCanvas');
      const moonError = document.getElementById('moonError');
      
      moonImg.style.display = 'none';
      canvas.style.display = 'none';
      moonError.style.display = 'flex';
      
      updateMoonInfo(phaseName, illumination, date, false);
    }
    
    function updateMoonInfo(phaseName, illumination, date, isNASA) {
      const source = isNASA ? '<small style="color: #48bb78;">NASA SVS</small>' : '<small style="color: #ed8936;">Simulado</small>';
      
      document.getElementById('moonInfo').innerHTML = `
        <strong>${phaseName}</strong><br>
        Iluminaci√≥n: ${illumination}%<br>
        ${source}<br>
        <small style="color: #718096;">${date.toLocaleTimeString('es-ES')}</small>
      `;
    }
    
    // ========== SOL SDO (ACTUALIZACI√ìN) ==========
    function handleSDOError(img) {
      console.error('‚ùå No se pudo cargar imagen SDO');
      const fallbacks = [
        'https://sdo.gsfc.nasa.gov/assets/img/latest/f_AIA_171_1024.jpg',
        'https://sdo.gsfc.nasa.gov/assets/img/latest/f_171_193_211.jpg',
        'https://sdo.gsfc.nasa.gov/assets/img/latest/latest_1024_0171.jpg'
      ];
      const current = img.dataset.errStep ? parseInt(img.dataset.errStep, 10) : 0;
      if (current < fallbacks.length) {
        img.dataset.errStep = current + 1;
        img.src = `${fallbacks[current]}?${Date.now()}`;
        img.style.display = 'block';
        document.getElementById('sdoError').style.display = 'none';
      } else {
        // No ocultar imagen antigua, solo mostrar overlay
        const errorEl = document.getElementById('sdoError');
        const timestampEl = document.getElementById('sdoTimestamp');
        if (errorEl) errorEl.style.display = 'flex';
        if (timestampEl && img.dataset.lastSuccess) {
          timestampEl.textContent = `√öltima imagen: ${img.dataset.lastSuccess}`;
        }
        document.getElementById('sdoTime').textContent = 'Datos antiguos';
      }
    }
    
    function updateSDO() {
      const update = () => {
        const img = document.getElementById('sdoImage');
        if (img) {
          img.dataset.errStep = '0';
          img.src = `https://sdo.gsfc.nasa.gov/assets/img/latest/latest_1024_0171.jpg?${Date.now()}`;
        }
        document.getElementById('sdoTime').textContent = new Date().toLocaleTimeString('es-ES');
      };
      update();
      setInterval(update, 600000); // cada 10 minutos
    }
    
    // ========== ALERTAS NOAA R/S/G (badge compacto) ==========
    async function fetchNoaaAlerts() {
      // 1) Intentar escalas NOAA (24h m√°x) para coincidir con la p√°gina oficial
      try {
        const scalesRes = await fetch(`https://corsproxy.io/?${encodeURIComponent('https://services.swpc.noaa.gov/products/noaa-scales.json')}`, { signal: AbortSignal.timeout(8000) });
        if (!scalesRes.ok) throw new Error(`HTTP scales ${scalesRes.status}`);
        const scales = await scalesRes.json();
        const dayMinus1 = scales?.["-1"] || scales?.[0];
        if (dayMinus1 && dayMinus1.R && dayMinus1.S && dayMinus1.G) {
          const rVal = parseInt(dayMinus1.R.Scale ?? 0, 10) || 0;
          const sVal = parseInt(dayMinus1.S.Scale ?? 0, 10) || 0;
          const gVal = parseInt(dayMinus1.G.Scale ?? 0, 10) || 0;
          const pillsContainer = document.getElementById('noaaAlertPills');
          const fallbackDiv = document.getElementById('noaaAlertFallback');
          if (pillsContainer) {
            const rPill = pillsContainer.querySelector('.r-scale');
            const sPill = pillsContainer.querySelector('.s-scale');
            const gPill = pillsContainer.querySelector('.g-scale');
            if (rPill) { rPill.textContent = `R${rVal}`; rPill.dataset.level = rVal; }
            if (sPill) { sPill.textContent = `S${sVal}`; sPill.dataset.level = sVal; }
            if (gPill) { gPill.textContent = `G${gVal}`; gPill.dataset.level = gVal; }
            const label = document.querySelector('.noaa-alerts-badge .label');
            if (label) label.textContent = 'Alertas solares 24h';
            pillsContainer.style.display = 'flex';
            if (fallbackDiv) fallbackDiv.style.display = 'none';
            return; // √©xito con escalas
          }
        }
      } catch (e) {
        console.warn('Escalas NOAA no disponibles, usando alerts.json', e);
      }

      // 2) Fallback: alerts.json (solo activas, sin caducadas)
      const url = 'https://services.swpc.noaa.gov/products/alerts.json';
      const pillsContainer = document.getElementById('noaaAlertPills');
      const fallbackDiv = document.getElementById('noaaAlertFallback');
      if (!pillsContainer) return;

      try {
        const response = await fetch(`https://corsproxy.io/?${encodeURIComponent(url)}`, { signal: AbortSignal.timeout(8000) });
        if (!response.ok) throw new Error(`HTTP error! status: ${response.status}`);
        const alerts = await response.json();

        let maxR = 0, maxS = 0, maxG = 0;
        let activeAlertsFound = false;
        const now = Date.now();

        alerts.forEach(alert => {
          const message = alert.message || '';
          const expires = alert.expires || alert.endTime || alert.end || alert.expiration_time || null;
          const isEndedText = /ended|has ended|cancelled|canceled/i.test(message);
          const isExpired = expires ? (new Date(expires).getTime() < now) : false;
          if (isEndedText || isExpired) return; // ignorar alertas caducadas o finalizadas
          const rMatch = message.match(/R(\d)/);
          const sMatch = message.match(/S(\d)/);
          const gMatch = message.match(/G(\d)/);

          if (rMatch) { maxR = Math.max(maxR, parseInt(rMatch[1], 10)); activeAlertsFound = true; }
          if (sMatch) { maxS = Math.max(maxS, parseInt(sMatch[1], 10)); activeAlertsFound = true; }
          if (gMatch) { maxG = Math.max(maxG, parseInt(gMatch[1], 10)); activeAlertsFound = true; }
        });

        document.querySelector('.noaa-alerts-badge .label').textContent = activeAlertsFound ? 'Alertas activas' : 'Sin alertas activas';

        const rPill = pillsContainer.querySelector('.r-scale');
        const sPill = pillsContainer.querySelector('.s-scale');
        const gPill = pillsContainer.querySelector('.g-scale');
        rPill.textContent = `R${maxR}`;
        rPill.dataset.level = maxR;
        sPill.textContent = `S${maxS}`;
        sPill.dataset.level = maxS;
        gPill.textContent = `G${maxG}`;

        pillsContainer.style.display = 'flex';
        fallbackDiv.style.display = 'none';

      } catch (error) {
        console.error('Error fetching NOAA alerts:', error);
        const label = document.querySelector('.noaa-alerts-badge .label');
        if (label) label.textContent = 'Alertas no disponibles';
        pillsContainer.style.display = 'none';
        if (fallbackDiv) fallbackDiv.style.display = 'block';
      }
    }
    
    // ========== GR√ÅFICO X-RAY (datos JSON propios con cache) ==========
    async function loadXrayData() {
      // Intentar cache primero
      try {
        const cached = localStorage.getItem('xray_cache');
        if (cached) {
          const { data, timestamp } = JSON.parse(cached);
          if (Date.now() - timestamp < GRAPHS_CACHE_DURATION) {
            console.log('‚úì X-ray desde cache');
            return data;
          }
        }
      } catch (e) {
        console.warn('Error leyendo cache X-ray');
      }
      
      // Cargar desde API
      for (const endpoint of XRAY_ENDPOINTS) {
        try {
          const res = await fetch(endpoint, { signal: AbortSignal.timeout(8000) });
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const data = await res.json();
          if (Array.isArray(data) && data.length > 0) {
            // Guardar en cache
            try {
              localStorage.setItem('xray_cache', JSON.stringify({
                data,
                timestamp: Date.now()
              }));
            } catch (e) {
              console.warn('Error guardando cache X-ray');
            }
            return data;
          }
        } catch (e) {
          console.warn('X-ray endpoint fallo:', endpoint, e.message);
        }
      }
      return null;
    }

    function drawXrayChart(data) {
      const canvas = document.getElementById('xrayCanvas');
      const fallback = document.getElementById('xrayFallback');
      if (!canvas || !data) {
        if (fallback) fallback.style.display = 'block';
      return;
    }
      
      // Usar requestAnimationFrame para mejor performance
      requestAnimationFrame(() => {
      const ctx = canvas.getContext('2d');
      const w = canvas.width;
      const h = canvas.height;
      ctx.clearRect(0, 0, w, h);

      // Preparar datos: separar largo (0.1-0.8 nm) y corto (0.05-0.4 nm) con heur√≠sticas
      const longBand = [];
      const shortBand = [];

      const pushPoint = (t, f, band) => {
        const time = new Date(t);
        const flux = parseFloat(f);
        if (!isFinite(flux) || flux <= 0 || isNaN(time.getTime())) return;
        if (band === 'long') longBand.push({ t: time, f: flux });
        if (band === 'short') shortBand.push({ t: time, f: flux });
      };

      data.forEach(item => {
        // Caso objeto
        if (item && typeof item === 'object' && !Array.isArray(item)) {
          const time = item.time_tag || item.time || item.timestamp || item.date;
          const energy = (item.energy || item.channel || '').toString().toLowerCase();
          const flux = item.observed_flux ?? item.flux ?? item.short_flux ?? item['flux'] ?? item['primary'] ?? item['secondary'];
          if (energy.includes('0.1-0.8')) pushPoint(time, flux, 'long');
          else if (energy.includes('0.05-0.4') || energy.includes('0.5-4')) pushPoint(time, flux, 'short');
          else if ('long_wavelength' in item && 'short_wavelength' in item) {
            pushPoint(time, item.long_wavelength, 'long');
            pushPoint(time, item.short_wavelength, 'short');
          }
        }
        // Caso array: intentar [time, short, long] o [time, long, short]
        if (Array.isArray(item) && item.length >= 3) {
          const t = item[0];
          const a = item[1];
          const b = item[2];
          // Heur√≠stica: el mayor suele ser long (0.1-0.8)
          if (parseFloat(a) >= parseFloat(b)) {
            pushPoint(t, a, 'long');
            pushPoint(t, b, 'short');
          } else {
            pushPoint(t, b, 'long');
            pushPoint(t, a, 'short');
          }
        }
      });

      longBand.sort((a,b)=>a.t-b.t);
      shortBand.sort((a,b)=>a.t-b.t);

      if (longBand.length < 2 && shortBand.length < 2) {
        fallback.style.display = 'block';
        return;
      }

      // Escala log
      const series = [
        { name: 'long', data: longBand, color: '#f6ad55' }, // naranja
        { name: 'short', data: shortBand, color: '#5a38d6' } // p√∫rpura
      ];

      // Extremos de tiempo seg√∫n lo disponible
      const all = [...(longBand||[]), ...(shortBand||[])];
      const tMin = all[0]?.t.getTime();
      const tMax = all[all.length-1]?.t.getTime();
      if (!tMin || !tMax) {
        fallback.style.display = 'block';
        return;
      }

      const primary = longBand.length >= shortBand.length ? longBand : shortBand;
      const logPoints = primary.map(p => ({ t: p.t.getTime(), l: Math.log10(p.f) }));
      if (logPoints.length < 2) {
        fallback.style.display = 'block';
        return;
      }

      // Fijar escala NOAA-like (10^-2 a 10^-9)
      const yMin = -9;
      const yMax = -2;

      // Ejes y fondo
      ctx.fillStyle = '#000';
      ctx.fillRect(0, 0, w, h);
      ctx.strokeStyle = 'rgba(109,213,237,0.18)';
      ctx.lineWidth = 1;

      // Gu√≠as niveles A/B/C/M/X
      const levels = [
        { label: 'A', value: -8 },
        { label: 'B', value: -7 },
        { label: 'C', value: -6 },
        { label: 'M', value: -5 },
        { label: 'X', value: -4 },
      ];
      ctx.font = '11px "Segoe UI", sans-serif';
      ctx.textBaseline = 'middle';
      ctx.fillStyle = '#718096';

      const padding = { left: 50, right: 14, top: 16, bottom: 36 };

      function yToPx(logVal) {
        return padding.top + ( (yMax - logVal) / (yMax - yMin) ) * (h - padding.top - padding.bottom);
      }
      function xToPx(t) {
        return padding.left + ( (t - tMin) / (tMax - tMin) ) * (w - padding.left - padding.right);
      }

      levels.forEach(lv => {
        const y = yToPx(lv.value);
        ctx.strokeStyle = 'rgba(109,213,237,0.18)';
        ctx.beginPath();
        ctx.moveTo(padding.left, y);
        ctx.lineTo(w - padding.right, y);
        ctx.stroke();
        ctx.fillStyle = '#6dd5ed';
        ctx.fillText(lv.label, 12, y);
      });

      // Marco exterior estilo NOAA
      ctx.strokeStyle = '#4a4d57';
      ctx.lineWidth = 1.4;
      ctx.strokeRect(padding.left, padding.top, w - padding.left - padding.right, h - padding.top - padding.bottom);

      // Eje X labels (hora) cada ~6h (sin l√≠neas internas para limpiar)
      ctx.fillStyle = '#a0aec0';
      const totalHours = (tMax - tMin) / 3600000;
      const stepHours = totalHours > 48 ? 6 : 3;
      const firstTick = Math.ceil(tMin / (stepHours * 3600000)) * (stepHours * 3600000);
      for (let t = firstTick; t <= tMax; t += stepHours * 3600000) {
        const px = xToPx(t);
        const label = new Date(t).toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });
        ctx.fillText(label, px - 16, h - padding.bottom + 16);
      }

      // Trazar series
      series.forEach(serie => {
        if (!serie.data || serie.data.length < 2) return;
        ctx.strokeStyle = serie.color;
        ctx.lineWidth = 2.2;
        ctx.beginPath();
        serie.data.forEach((p, idx) => {
          const x = xToPx(p.t.getTime());
          const y = yToPx(Math.log10(p.f));
          if (idx === 0) ctx.moveTo(x, y);
          else ctx.lineTo(x, y);
        });
        ctx.stroke();
      });

      // √öltimos valores
      const lastLong = longBand[longBand.length-1];
      const lastShort = shortBand[shortBand.length-1];
      ctx.fillStyle = '#e2e8f0';
      const labelY = padding.top - 2;
      const labelX = padding.left;
      const lastText = [];
      if (lastLong) lastText.push(`L: ${lastLong.f.toExponential(2)} W/m¬≤`);
      if (lastShort) lastText.push(`S: ${lastShort.f.toExponential(2)} W/m¬≤`);
      ctx.fillText(lastText.join('   '), labelX, labelY);

      fallback.style.display = 'none';
      }); // Fin del requestAnimationFrame
    }

    async function renderXrayChart() {
      const data = await loadXrayData();
      const fallback = document.getElementById('xrayFallback');
      if (!data) {
        if (fallback) fallback.style.display = 'block';
        return;
      }
      drawXrayChart(data);
    }

    // ========== VIENTO SOLAR (ACE/DSCOVR, 1m) ==========
    const SW_ENDPOINTS = [
      // Plasma 7 d√≠as (densidad, velocidad, temperatura)
      'https://services.swpc.noaa.gov/products/solar-wind/plasma-7-day.json',
      // Backup ACE SWEpam 1m
      'https://services.swpc.noaa.gov/products/summary/ace_swepam_1m.json'
    ];

    async function fetchWithProxy(url) {
      const attempts = [
        `https://corsproxy.io/?${encodeURIComponent(url)}`,
        `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`,
        url
      ];
      for (const u of attempts) {
        try {
          const res = await fetch(u, { signal: AbortSignal.timeout(8000) });
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          return await res.json();
        } catch (e) {
          console.warn('Fetch fallo:', u, e.message);
        }
      }
      return null;
    }

    async function loadSolarWindData() {
      // Intentar cache primero
      try {
        const cached = localStorage.getItem('solarwind_cache');
        if (cached) {
          const { data, timestamp } = JSON.parse(cached);
          if (Date.now() - timestamp < GRAPHS_CACHE_DURATION) {
            console.log('‚úì Solar Wind desde cache');
            return data;
          }
        }
      } catch (e) {
        console.warn('Error leyendo cache Solar Wind');
      }
      
      // Cargar desde API
      for (const url of SW_ENDPOINTS) {
        const data = await fetchWithProxy(url);
        if (Array.isArray(data) && data.length > 2) {
          // Guardar en cache
          try {
            localStorage.setItem('solarwind_cache', JSON.stringify({
              data,
              timestamp: Date.now()
            }));
          } catch (e) {
            console.warn('Error guardando cache Solar Wind');
          }
          return data;
        }
      }
      return null;
    }

    function parseSolarWind(data) {
      if (!Array.isArray(data) || data.length < 2) return null;
      let header = data[0];
      let rows = data.slice(1);
      // Encabezado CSV y filas CSV
      if (typeof header === 'string') {
        header = header.split(',');
        rows = rows.map(r => typeof r === 'string' ? r.split(',') : r);
      }
      // Caso objetos en vez de arrays
      if (!Array.isArray(header) && typeof header === 'object') {
        // data es lista de objetos
        const points = data
          .map(item => {
            const t = item.time_tag || item.time || item.timestamp || item.date;
            const n = item.density ?? item.proton_density ?? item.Np ?? item.np;
            const v = item.speed ?? item.velocity ?? item.bulk_speed ?? item.Vp ?? item.vp;
            const T = item.temperature ?? item.ion_temperature ?? item.Tp ?? item.tp;
            const time = new Date(t);
            const nn = parseFloat(n);
            const vv = parseFloat(v);
            const TT = parseFloat(T);
            if (!isFinite(nn) || !isFinite(vv) || !isFinite(TT) || isNaN(time.getTime())) return null;
            return { t: time, n: nn, v: vv, T: TT };
          })
          .filter(Boolean);
        return points.length ? points : null;
      }

      // Arrays
      const idxTime = header.findIndex(h => /time/i.test(h));
      const idxDensity = header.findIndex(h => /density|np|proton/i.test(h));
      const idxSpeed = header.findIndex(h => /speed|velocity|vp|bulk/i.test(h));
      const idxTemp = header.findIndex(h => /temperature|temp|tp/i.test(h));
      if (idxTime === -1 || idxDensity === -1 || idxSpeed === -1 || idxTemp === -1) return null;
      const points = rows
        .map(r => {
          if (!Array.isArray(r)) return null;
          const t = new Date(r[idxTime]);
          const n = parseFloat(r[idxDensity]);
          const v = parseFloat(r[idxSpeed]);
          const T = parseFloat(r[idxTemp]);
          if (!isFinite(n) || !isFinite(v) || !isFinite(T) || isNaN(t.getTime())) return null;
          return { t, n, v, T };
        })
        .filter(Boolean);
      return points.length ? points : null;
    }

    function drawSolarWind(points) {
      const canvas = document.getElementById('solarWindCanvas');
      const fallback = document.getElementById('solarWindFallback');
      if (!canvas || !points || points.length < 5) {
        if (fallback) fallback.style.display = 'block';
        return;
      }
      
      // Usar requestAnimationFrame para mejor performance
      requestAnimationFrame(() => {
      const ctx = canvas.getContext('2d');
      const w = canvas.width, h = canvas.height;
      ctx.clearRect(0, 0, w, h);

      // Tomar √∫ltimas 12 horas aprox
      const now = points[points.length-1].t.getTime();
      const cutoff = now - 12 * 3600000;
      const recent = points.filter(p => p.t.getTime() >= cutoff);
      if (recent.length < 5) recent.push(...points.slice(-200)); // fallback √∫ltimas ~3-4h

      const tMin = recent[0].t.getTime();
      const tMax = recent[recent.length-1].t.getTime();

      const nVals = recent.map(p => p.n);
      const vVals = recent.map(p => p.v);
      const tVals = recent.map(p => p.T);
      const nMin = Math.min(...nVals), nMax = Math.max(...nVals);
      const vMin = Math.min(...vVals), vMax = Math.max(...vVals);
      const TMin = Math.min(...tVals), TMax = Math.max(...tVals);

      const padding = { left: 48, right: 16, top: 14, bottom: 28 };
      ctx.fillStyle = '#000';
      ctx.fillRect(0,0,w,h);
      ctx.strokeStyle = '#4a4d57';
      ctx.lineWidth = 1.4;
      ctx.strokeRect(padding.left, padding.top, w - padding.left - padding.right, h - padding.top - padding.bottom);

      ctx.font = '11px "Segoe UI", sans-serif';
      ctx.fillStyle = '#a0aec0';

      const totalHours = (tMax - tMin)/3600000;
      const stepHours = totalHours > 6 ? 2 : 1;
      const firstTick = Math.ceil(tMin / (stepHours*3600000)) * (stepHours*3600000);
      for (let t = firstTick; t <= tMax; t += stepHours*3600000) {
        const x = padding.left + (t - tMin)/(tMax - tMin) * (w - padding.left - padding.right);
        const label = new Date(t).toLocaleTimeString('es-ES', { hour: '2-digit', minute: '2-digit' });
        ctx.fillText(label, x-16, h - padding.bottom + 14);
      }

      const toX = (t) => padding.left + (t - tMin)/(tMax - tMin) * (w - padding.left - padding.right);
      const toY = (val, min, max) => padding.top + (max - val)/(max - min || 1) * (h - padding.top - padding.bottom);

      function drawSerie(vals, min, max, color) {
        ctx.strokeStyle = color;
        ctx.lineWidth = 2;
        ctx.beginPath();
        vals.forEach((p, idx) => {
          const x = toX(p.t.getTime());
          const y = toY(p.val, min, max);
          if (idx === 0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
        });
        ctx.stroke();
      }

      const serieN = recent.map(p => ({t:p.t, val:p.n}));
      const serieV = recent.map(p => ({t:p.t, val:p.v}));
      const serieT = recent.map(p => ({t:p.t, val:p.T}));

      drawSerie(serieN, nMin, nMax, '#00e5ff');
      drawSerie(serieV, vMin, vMax, '#f6ad55');
      drawSerie(serieT, TMin, TMax, '#9ae6b4');

      ctx.fillStyle = '#e2e8f0';
      ctx.fillText(`N: ${nVals[nVals.length-1].toFixed(1)} / V: ${vVals[vVals.length-1].toFixed(0)} / T: ${(tVals[tVals.length-1]/1e3).toFixed(0)}K`, padding.left, padding.top - 2);
      if (fallback) fallback.style.display = 'none';
      }); // Fin del requestAnimationFrame
    }

    async function renderSolarWind() {
      const data = await loadSolarWindData();
      const fallback = document.getElementById('solarWindFallback');
      if (!data) {
        if (fallback) fallback.style.display = 'block';
        return;
      }
      const parsed = parseSolarWind(data);
      if (!parsed) {
        if (fallback) fallback.style.display = 'block';
        return;
      }
      drawSolarWind(parsed);
    }

    // ========== Kp reciente ==========
    const KP_ENDPOINT = 'https://services.swpc.noaa.gov/products/noaa-planetary-k-index.json';

    async function loadKp() {
      // Intentar cache primero
      try {
        const cached = localStorage.getItem('kp_cache');
        if (cached) {
          const { data, timestamp } = JSON.parse(cached);
          if (Date.now() - timestamp < GRAPHS_CACHE_DURATION) {
            console.log('‚úì Kp desde cache');
            return data;
          }
        }
      } catch (e) {
        console.warn('Error leyendo cache Kp');
      }
      
      // Cargar desde API
      try {
        const res = await fetch(KP_ENDPOINT, { signal: AbortSignal.timeout(8000) });
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const data = await res.json();
        if (Array.isArray(data) && data.length > 2) {
          // Guardar en cache
          try {
            localStorage.setItem('kp_cache', JSON.stringify({
              data,
              timestamp: Date.now()
            }));
          } catch (e) {
            console.warn('Error guardando cache Kp');
          }
          return data;
        }
      } catch (e) {
        console.warn('Kp fallo:', e.message);
      }
      return null;
    }

    function drawKp(data) {
      const canvas = document.getElementById('kpCanvas');
      const fallback = document.getElementById('kpFallback');
      if (!canvas || !data || data.length < 3) {
        if (fallback) fallback.style.display = 'block';
        return;
      }
      
      // Usar requestAnimationFrame para mejor performance
      requestAnimationFrame(() => {
      const header = data[0];
      const idxTime = header.findIndex(h => /time/i.test(h));
      const idxKp = header.findIndex(h => /^Kp$/i.test(h));
      const points = data.slice(1).map(r => {
        const t = new Date(r[idxTime]);
        const k = parseFloat(r[idxKp]);
        if (!isFinite(k) || isNaN(t.getTime())) return null;
        return { t, k };
      }).filter(Boolean);
      if (points.length < 2) {
        if (fallback) fallback.style.display = 'block';
        return;
      }

      const ctx = canvas.getContext('2d');
      const w = canvas.width, h = canvas.height;
      ctx.clearRect(0,0,w,h);
      const tMin = points[0].t.getTime();
      const tMax = points[points.length-1].t.getTime();
      const kMin = 0, kMax = 9;
      const padding = { left: 42, right: 12, top: 12, bottom: 26 };

      ctx.fillStyle = '#000';
      ctx.fillRect(0,0,w,h);
      ctx.strokeStyle = '#4a4d57';
      ctx.lineWidth = 1.2;
      ctx.strokeRect(padding.left, padding.top, w - padding.left - padding.right, h - padding.top - padding.bottom);

      ctx.strokeStyle = 'rgba(109,213,237,0.18)';
      ctx.font = '11px "Segoe UI", sans-serif';
      ctx.fillStyle = '#6dd5ed';
      for (let k=1; k<=9; k+=2) {
        const y = padding.top + (kMax - k)/(kMax - kMin) * (h - padding.top - padding.bottom);
        ctx.beginPath(); ctx.moveTo(padding.left, y); ctx.lineTo(w - padding.right, y); ctx.stroke();
        ctx.fillText(String(k), 10, y);
      }

      ctx.fillStyle = '#a0aec0';
      const totalHours = (tMax - tMin)/3600000;
      const stepHours = totalHours > 24 ? 6 : 3;
      const firstTick = Math.ceil(tMin / (stepHours*3600000)) * (stepHours*3600000);
      const toX = t => padding.left + (t - tMin)/(tMax - tMin) * (w - padding.left - padding.right);
      for (let t = firstTick; t <= tMax; t += stepHours*3600000) {
        const x = toX(t);
        const label = new Date(t).toLocaleTimeString('es-ES', { hour: '2-digit' });
        ctx.fillText(label, x-12, h - padding.bottom + 14);
      }

      ctx.strokeStyle = '#f6ad55';
      ctx.lineWidth = 2.4;
      ctx.beginPath();
      points.forEach((p, idx) => {
        const x = toX(p.t.getTime());
        const y = padding.top + (kMax - p.k)/(kMax - kMin) * (h - padding.top - padding.bottom);
        if (idx === 0) ctx.moveTo(x,y); else ctx.lineTo(x,y);
      });
      ctx.stroke();

      ctx.fillStyle = '#e2e8f0';
      const last = points[points.length-1];
      ctx.fillText(`Kp: ${last.k.toFixed(1)}`, padding.left, padding.top - 2);
      if (fallback) fallback.style.display = 'none';
      }); // Fin del requestAnimationFrame
    }

    async function renderKp() {
      const data = await loadKp();
      const fallback = document.getElementById('kpFallback');
      if (!data) {
        if (fallback) fallback.style.display = 'block';
        return;
      }
      drawKp(data);
    }
    
    // ========== INFO CONEXI√ìN ==========
    async function loadConnectionInfo() {
      try {
        // Obtener IP y localizaci√≥n
        const response = await fetch('https://ipapi.co/json/');
        const data = await response.json();
        
        document.getElementById('userIP').textContent = data.ip || '--';
        document.getElementById('userLocation').textContent = `${data.city}, ${data.country_name}` || '--';
        
        // Detalles expandidos
        document.getElementById('detailIP').textContent = data.ip || '--';
        document.getElementById('detailLocation').textContent = `${data.city}, ${data.region}, ${data.country_name}` || '--';
        document.getElementById('detailISP').textContent = data.org || '--';
        
        // Ping simulado (medir tiempo de respuesta)
        const pingStart = Date.now();
        await fetch('https://ipapi.co/json/');
        const ping = Date.now() - pingStart;
        document.getElementById('userPing').textContent = `${ping} ms`;
        
      } catch (error) {
        console.error('Error obteniendo info de conexi√≥n:', error);
        document.getElementById('userIP').textContent = 'No disponible';
        document.getElementById('userLocation').textContent = 'No disponible';
      }
      
      // Info del navegador
      const ua = navigator.userAgent;
      let browser = 'Desconocido';
      if (ua.includes('Chrome')) browser = 'Chrome';
      else if (ua.includes('Firefox')) browser = 'Firefox';
      else if (ua.includes('Safari')) browser = 'Safari';
      else if (ua.includes('Edge')) browser = 'Edge';
      
      let os = 'Desconocido';
      if (ua.includes('Windows')) os = 'Windows';
      else if (ua.includes('Mac')) os = 'macOS';
      else if (ua.includes('Linux')) os = 'Linux';
      else if (ua.includes('Android')) os = 'Android';
      else if (ua.includes('iOS')) os = 'iOS';
      
      document.getElementById('detailBrowser').textContent = browser;
      document.getElementById('detailOS').textContent = os;
      document.getElementById('detailResolution').textContent = `${window.screen.width}x${window.screen.height}`;
      
      // Estado online
      updateOnlineStatus();
      window.addEventListener('online', updateOnlineStatus);
      window.addEventListener('offline', updateOnlineStatus);
    }
    
    function updateOnlineStatus() {
      const isOnline = navigator.onLine;
      const icon = document.getElementById('statusIcon');
      const text = document.getElementById('statusText');
      
      if (isOnline) {
        icon.className = 'icon status-online';
        icon.textContent = '‚úì';
        text.textContent = 'Online';
      } else {
        icon.className = 'icon status-offline';
        icon.textContent = '‚úó';
        text.textContent = 'Offline';
      }
    }
    
    function toggleConnection() {
      const details = document.getElementById('connectionDetails');
      const btn = document.getElementById('expandBtn');
      details.classList.toggle('show');
      btn.classList.toggle('expanded');
    }
    
    // ========== MINI MAPA (RECARGA OPTIMIZADA CON THROTTLE) ==========
    (function setupMiniMapRefresh() {
      const miniEarth = document.getElementById('mini-earth');
      if (!miniEarth) return;

      const baseSrc = 'mapa_tierra_v2.html?preview=1';
      let resizeTimer = null;
      let lastReload = 0;
      const RELOAD_THROTTLE = 30000; // M√≠nimo 30 seg entre recargas

      function reloadMiniEarth(reason = '') {
        const now = Date.now();
        if (now - lastReload < RELOAD_THROTTLE) {
          console.log(`‚Üª Recarga ${reason} ignorada (throttle activo)`);
          return;
        }
        lastReload = now;
        miniEarth.src = `${baseSrc}&t=${now}`;
        console.log(`‚Üª Mini mapa Tierra recargado (${reason})`);
      }

      // Recarga al cambiar el tama√±o de la ventana (debounced + throttled)
      window.addEventListener('resize', () => {
        clearTimeout(resizeTimer);
        resizeTimer = setTimeout(() => reloadMiniEarth('resize'), 300);
      });

      // Recarga peri√≥dica para reflejar actualizaciones del mapa (cada 5 min)
      setInterval(() => reloadMiniEarth('interval 5m'), 300000);
})();

    // Refresco mini-cyber optimizado
    (function setupMiniCyberRefresh() {
      const miniCyber = document.getElementById('mini-cyber');
      if (!miniCyber) return;
      
      const baseSrc = 'mapa_cyber.html?preview=1';
      let lastReload = 0;
      const RELOAD_THROTTLE = 30000; // M√≠nimo 30 seg entre recargas
      
      function reload(reason='') {
        const now = Date.now();
        if (now - lastReload < RELOAD_THROTTLE) {
          console.log(`‚Üª Recarga cyber ${reason} ignorada (throttle activo)`);
          return;
        }
        lastReload = now;
        miniCyber.src = `${baseSrc}&t=${now}`;
        console.log(`‚Üª Mini cyber recargado (${reason})`);
      }
      
      setInterval(() => reload('interval 5m'), 300000);
    })();

    // ========== INICIALIZACI√ìN OPTIMIZADA (carga escalonada) ==========
    window.addEventListener('DOMContentLoaded', () => {
      console.log('üåç Portal Geof√≠sico inicializado');
      
      // FASE 1: Cr√≠tico inmediato (0ms) - UI b√°sica
      initNews();
      drawMoon();
      loadConnectionInfo();
      console.log('‚úì Fase 1: UI b√°sica cargada');
      
      // FASE 2: Visual importante (1 segundo despu√©s) - Im√°genes
      setTimeout(() => {
        updateSDO();
        fetchNoaaAlerts();
        console.log('‚úì Fase 2: Im√°genes solares cargadas');
      }, 1000);
      
      // FASE 3: Gr√°ficas pesadas (3 segundos despu√©s) - Canvas
      setTimeout(() => {
        renderXrayChart();
        renderSolarWind();
        renderKp();
        console.log('‚úì Fase 3: Gr√°ficas cargadas');
      }, 3000);
      
      // Actualizar luna cada minuto
      setInterval(drawMoon, 60000);
      // Refrescar alertas NOAA cada 10 minutos
      setInterval(fetchNoaaAlerts, 600000);
      // Actualizar X-ray cada 5 minutos
      setInterval(renderXrayChart, 300000);
      setInterval(renderSolarWind, 300000);
      setInterval(renderKp, 600000);
      
      console.log('‚úì Todos los componentes inicializados');
    });
</script>
</body>
</html>
