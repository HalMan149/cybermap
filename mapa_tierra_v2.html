<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Mapa Tierra en Tiempo Real</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000000;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }
    #map {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000000;
    }
    /* Fondo negro para el contenedor de tiles */
    .leaflet-container {
      background: #000000 !important;
    }
    .leaflet-tile-pane {
      background: #000000 !important;
    }
    /* Ocultar tiles que no cargan */
    .leaflet-tile-container {
      background: #000000 !important;
    }
    .leaflet-tile {
      border: none !important;
      background: #000000 !important;
    }
    /* Ocultar completamente el mensaje de error de tiles */
    .leaflet-tile[src*="data:image"],
    .leaflet-tile-loaded[src*="data:image"] {
      opacity: 0 !important;
      visibility: hidden !important;
      display: none !important;
    }
    /* Ocultar cualquier tile con error */
    .leaflet-tile-error {
      opacity: 0 !important;
      visibility: hidden !important;
      display: none !important;
    }
    /* Hacer la atribuci√≥n m√°s discreta */
    .leaflet-control-attribution {
      background: rgba(0, 0, 0, 0.7) !important;
      color: rgba(255, 255, 255, 0.6) !important;
      font-size: 10px !important;
      padding: 2px 5px !important;
    }
    .leaflet-control-attribution a {
      color: rgba(255, 255, 255, 0.7) !important;
    }
    
    /* Animaciones para terremotos seg√∫n antig√ºedad y magnitud */
    @keyframes earthquake-pulse-strong {
      0%, 100% {
        transform: scale(1);
        opacity: 0.9;
        filter: drop-shadow(0 0 8px rgba(255, 136, 0, 0.8));
      }
      50% {
        transform: scale(2.5);
        opacity: 0.3;
        filter: drop-shadow(0 0 20px rgba(255, 136, 0, 1));
      }
    }
    
    @keyframes earthquake-pulse-medium {
      0%, 100% {
        transform: scale(1);
        opacity: 0.8;
        filter: drop-shadow(0 0 5px rgba(255, 200, 0, 0.6));
      }
      50% {
        transform: scale(2);
        opacity: 0.3;
        filter: drop-shadow(0 0 12px rgba(255, 200, 0, 0.8));
      }
    }
    
    @keyframes earthquake-pulse-weak {
      0%, 100% {
        transform: scale(1);
        opacity: 0.7;
        filter: drop-shadow(0 0 3px rgba(255, 230, 0, 0.4));
      }
      50% {
        transform: scale(1.5);
        opacity: 0.4;
        filter: drop-shadow(0 0 8px rgba(255, 230, 0, 0.6));
      }
    }
    
    /* Clases para aplicar animaciones */
    .quake-very-recent-strong {
      animation: earthquake-pulse-strong 1.5s ease-in-out infinite;
    }
    
    .quake-very-recent-medium {
      animation: earthquake-pulse-medium 2s ease-in-out infinite;
    }
    
    .quake-very-recent-weak {
      animation: earthquake-pulse-weak 2.5s ease-in-out infinite;
    }
    
    .quake-recent {
      animation: earthquake-pulse-weak 4s ease-in-out infinite;
      opacity: 0.6;
    }
    /* Panel lateral de terremotos recientes (estilo cyber) */
    #recent-quakes {
      position: absolute; top: 15px; right: 15px; z-index: 2000;
      background: rgba(11, 16, 33, 0.25); backdrop-filter: blur(16px);
      border: 2px solid #ffa500; border-radius: 12px; padding: 0;
      font-family: 'Segoe UI', sans-serif; color: #fff;
      box-shadow: 0 4px 15px rgba(255, 165, 0, 0.3);
      transition: all 0.3s ease;
      width: auto;
    }
    #recent-quakes:not(.collapsed) {
      width: 340px;
      max-height: calc(100vh - 30px);
    }
    #quakes-header {
      padding: 10px 12px; cursor: pointer;
      display: flex; align-items: center; justify-content: space-between;
      border-bottom: 1px solid rgba(255, 165, 0, 0.3);
      gap: 10px;
    }
    #recent-quakes.collapsed #quakes-header { 
      border-bottom: none; 
      justify-content: center;
      padding: 8px 10px;
      gap: 0;
    }
    #quakes-header:hover { background: rgba(255, 165, 0, 0.1); }
    #recent-quakes h3 {
      margin: 0; font-size: 0.95em; color: #ffa500;
      text-shadow: 0 0 6px #ffa500; font-weight: 500;
      white-space: nowrap;
    }
    #recent-quakes.collapsed h3 {
      font-size: 0.8em;
    }
    #quakes-toggle {
      font-size: 1em; color: #ffa500; transition: transform 0.3s;
    }
    #recent-quakes.collapsed #quakes-toggle { transform: rotate(180deg); display: none; }
    #quakes-content {
      max-height: calc(100vh - 90px);
      overflow-y: auto;
      transition: max-height 0.3s ease, opacity 0.3s ease, padding 0.3s ease;
      padding: 12px 15px;
    }
    #recent-quakes.collapsed #quakes-content {
      max-height: 0;
      opacity: 0;
      padding: 0;
    }
    .quake-item {
      background: rgba(255, 200, 0, 0.08);
      border-left: 3px solid #ffa500;
      padding: 10px; margin-bottom: 8px; border-radius: 6px;
      font-size: 0.82em; cursor: pointer;
      transition: all 0.3s; animation: slideIn 0.4s ease-out;
    }
    .quake-item:hover {
      background: rgba(255, 200, 0, 0.18); transform: translateX(-3px);
      box-shadow: 0 2px 8px rgba(255, 165, 0, 0.3);
    }
    .quake-item.very-recent {
      border-left-color: #ff4444; background: rgba(255, 68, 68, 0.1);
      border-left-width: 4px;
    }
    .quake-item.very-recent:hover { background: rgba(255, 68, 68, 0.2); }
    .quake-item.strong {
      border-left-width: 5px;
      box-shadow: 0 0 10px rgba(255, 165, 0, 0.4);
    }
    .quake-magnitude {
      font-weight: 700; color: #ffa500; font-size: 1.1em; margin-bottom: 4px;
    }
    .quake-item.very-recent .quake-magnitude { color: #ff4444; }
    .quake-item.strong .quake-magnitude { font-size: 1.3em; }
    .quake-location {
      color: #e0e6ed; line-height: 1.5; margin-bottom: 4px;
    }
    .quake-time {
      font-size: 0.85em; color: #ffd700; margin-top: 4px;
      font-family: 'Consolas', monospace;
    }
    .quake-depth {
      font-size: 0.8em; color: #a0aec0; margin-top: 2px;
    }
    #quakes-content::-webkit-scrollbar { width: 6px; }
    #quakes-content::-webkit-scrollbar-track { background: rgba(0,0,0,0.3); }
    #quakes-content::-webkit-scrollbar-thumb {
      background: #ffa500; border-radius: 3px;
    }
    
    /* Animaci√≥n slideIn */
    @keyframes slideIn {
      from { opacity: 0; transform: translateX(20px); }
      to { opacity: 1; transform: translateX(0); }
    }
    
    /* Ocultar panel en preview */
    body.preview #recent-quakes { display: none; }
    .legend {
      position: absolute;
      bottom: 30px;
      left: 15px;
      background: rgba(10, 14, 39, 0.45); /* m√°s transparente */
      backdrop-filter: blur(10px);
      color: #fff;
      padding: 12px;
      border-radius: 8px;
      font-size: 12px;
      z-index: 1000;
      box-shadow: 0 4px 12px rgba(0,0,0,0.5);
    }
    .legend-item {
      margin: 6px 0;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .legend-circle {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      border: 2px solid;
    }
  </style>
</head>
<body>
  <div id="map"></div>
  
  <!-- Lista lateral de terremotos recientes -->
  <div id="recent-quakes" class="collapsed">
    <div id="quakes-header">
      <h3>üåç Terremotos Recientes</h3>
      <span id="quakes-toggle">‚ñ∂</span>
    </div>
    <div id="quakes-content">
      <div id="quakes-stats" style="margin-bottom: 12px; padding: 8px; background: rgba(255, 165, 0, 0.1); border-radius: 6px; font-size: 0.85em;">
        <div style="color: #ffd700; font-weight: 600;">üìä Estad√≠sticas</div>
        <div id="totalQuakes" style="margin-top: 4px;">Total: --</div>
        <div id="last24h" style="color: #ffaa00;">√öltimas 24h: --</div>
        <div id="last6h" style="color: #ff6666;">√öltimas 6h: --</div>
      </div>
      <div id="quakes-list"></div>
    </div>
  </div>

  <div class="legend">
    <div class="legend-item">
      <div class="legend-circle" style="background: #ffd700; border-color: #ffa500; animation: earthquake-pulse-strong 1.5s ease-in-out infinite;"></div>
      <span>Terremotos < 24h (pulsantes)</span>
    </div>
    <div class="legend-item">
      <div class="legend-circle" style="background: #ffd700; border-color: #ffa500; opacity: 0.5;"></div>
      <span>Terremotos > 24h (est√°ticos)</span>
    </div>
    <div class="legend-item">
      <div class="legend-circle" style="background: #ff4444; border-color: #cc0000;"></div>
      <span>Volcanes (tama√±o=actividad)</span>
    </div>
  </div>

  <script src="https://unpkg.com/suncalc@1.9.0/suncalc.js"></script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    'use strict';

    // ============================================
    // CONFIGURACI√ìN
    // ============================================
    const CONFIG = {
      openWeatherApiKey: 'c5424fe9f21a8a1e36206abaf7c1cf65',
      colors: {
        earthquake: '#ffd700',
        volcano: '#ff4444',
        night: '#000000'
      }
    };

    // ============================================
    // CREAR MAPA BASE CON AUTO-AJUSTE
    // ============================================
    
    let programmaticZoom = false; // Detectar si el zoom es program√°tico

    // Detectar modo preview (miniatura)
    const urlParams = new URLSearchParams(window.location.search);
    const isPreview = urlParams.has('preview');

    const map = L.map('map', {
      center: [0, 0],
      zoom: isPreview ? 1.7 : 2,
      minZoom: isPreview ? 1.4 : 1,
      maxZoom: 17,
      zoomControl: false,
      attributionControl: true,
      worldCopyJump: false,
      noWrap: true,
      preferCanvas: true,
      maxBounds: [[-85.05, -180], [85.05, 180]],
      maxBoundsViscosity: 1.0
    });

    // Calcular el zoom m√≠nimo necesario para llenar la ventana sin bordes negros
    function calculateMinZoom() {
      const mapElement = document.getElementById('map');
      const width = mapElement.offsetWidth;
      const height = mapElement.offsetHeight;
      
      // Tama√±o del mundo en p√≠xeles en zoom 0 = 256px
      // Rango de latitudes visibles: -85.05 a 85.05 (aprox 170¬∞ efectivos en Mercator)
      
      // Zoom necesario para llenar horizontalmente (360¬∞ = ancho de ventana)
      const zoomH = Math.log2(width / 256);
      
      // Zoom necesario para llenar verticalmente
      // En Mercator, la altura depende de las latitudes
      // Aproximaci√≥n: 170¬∞ visibles ‚âà 256px en zoom 0
      const zoomV = Math.log2(height / 256);
      
      // Usar el MAYOR para asegurar que siempre se llena al menos un eje
      const minZoom = Math.max(1.5, Math.max(zoomH, zoomV));
      
      // En modo preview, forzar un zoom m√≠nimo m√°s bajo para ver m√°s mundo
      if (isPreview) {
        return Math.max(Math.max(zoomH, zoomV), 1.4);
      }
      return minZoom;
    }
    
    // Ajustar el mapa para que siempre llene la ventana
    function adjustMapToWindow() {
      programmaticZoom = true;
      
      const requiredMinZoom = calculateMinZoom();
      const currentZoom = map.getZoom();
      
      // Actualizar el zoom m√≠nimo
      map.setMinZoom(requiredMinZoom);
      
      // Si el zoom actual es menor que el requerido, ajustarlo
      if (currentZoom < requiredMinZoom) {
        map.setZoom(requiredMinZoom, { animate: false });
      }
      
      setTimeout(() => {
        programmaticZoom = false;
      }, 100);
    }
    
    // El mapa ajusta autom√°ticamente el zoom m√≠nimo, pero el usuario puede hacer zoom libremente

    // Capa sat√©lite de ESRI
    const sateliteLayer = L.tileLayer(
      'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
      {
        attribution: 'Tiles ¬© Esri',
        minZoom: 2,
        maxZoom: 17,
        noWrap: true,
        bounds: [[-85.05, -180], [85.05, 180]],
        errorTileUrl: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'
      }
    ).addTo(map);

    // Capa de nubes en tiempo real (con actualizaci√≥n autom√°tica)
    let cloudsLayer = L.tileLayer(
      `https://tile.openweathermap.org/map/clouds_new/{z}/{x}/{y}.png?appid=${CONFIG.openWeatherApiKey}&t=${Date.now()}`,
      {
        attribution: 'Nubes ¬© OpenWeatherMap',
        opacity: 0.5,
        minZoom: 2,
        maxZoom: 17,
        noWrap: true,
        bounds: [[-85.05, -180], [85.05, 180]],
        errorTileUrl: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'
      }
    ).addTo(map);

    // Actualizar nubes cada 10 minutos para datos frescos
    function updateClouds() {
      cloudsLayer.remove();
      cloudsLayer = L.tileLayer(
        `https://tile.openweathermap.org/map/clouds_new/{z}/{x}/{y}.png?appid=${CONFIG.openWeatherApiKey}&t=${Date.now()}`,
        {
          attribution: 'Nubes ¬© OpenWeatherMap',
          opacity: 0.5,
          minZoom: 2,
          maxZoom: 17,
          noWrap: true,
          bounds: [[-85.05, -180], [85.05, 180]],
          errorTileUrl: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'
        }
      ).addTo(map);
      console.log('‚òÅÔ∏è Capa de nubes actualizada:', new Date().toLocaleTimeString('es-ES'));
    }

    setInterval(updateClouds, 600000); // 600000ms = 10 minutos
    
    // Ajustar mapa cuando cambia el tama√±o de ventana
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        map.invalidateSize();
        adjustMapToWindow();
      }, 250);
    });

    // ============================================
    // SOMBRA D√çA/NOCHE MEJORADA
    // ============================================
    let nightLayer = L.layerGroup().addTo(map);

    function findTerminatorLat(lng, date) {
      // B√∫squeda binaria para encontrar donde el sol est√° en el horizonte
      let latMin = -90;
      let latMax = 90;
      const tolerance = 0.1;
      
      while (latMax - latMin > tolerance) {
        const lat1 = latMin + (latMax - latMin) / 3;
        const lat2 = latMax - (latMax - latMin) / 3;
        
        const sun1 = SunCalc.getPosition(date, lat1, lng);
        const sun2 = SunCalc.getPosition(date, lat2, lng);
        
        const diff1 = Math.abs(sun1.altitude);
        const diff2 = Math.abs(sun2.altitude);
        
        if (diff1 < diff2) {
          latMax = lat2;
        } else {
          latMin = lat1;
        }
      }
      
      return (latMin + latMax) / 2;
    }

    function calculateNightShadow() {
      const now = new Date();
      
      // Calcular el terminador con mejor precisi√≥n
      const terminatorCoords = [];
      for (let lng = -180; lng <= 180; lng += 1.5) {
        const lat = findTerminatorLat(lng, now);
        terminatorCoords.push([lat, lng]);
      }

      // Determinar qu√© hemisferio est√° en noche
      const testNorth = SunCalc.getPosition(now, 60, 0);
      const testSouth = SunCalc.getPosition(now, -60, 0);
      const northIsDark = testNorth.altitude < testSouth.altitude;

      nightLayer.clearLayers();
      
      // Crear banda principal (noche total)
      const nightCoords = [...terminatorCoords];
      if (northIsDark) {
        nightCoords.push([85, 180]);
        nightCoords.push([85, -180]);
      } else {
        nightCoords.push([-85, 180]);
        nightCoords.push([-85, -180]);
      }
      nightCoords.push(nightCoords[0]);

      const nightPolygon = L.polygon(nightCoords, {
        fillColor: '#000000',
        fillOpacity: 0.45,
        stroke: false,
        interactive: false,
        smoothFactor: 1
      });
      nightLayer.addLayer(nightPolygon);

      // A√±adir crep√∫sculo (sombra m√°s suave en el borde)
      const twilightCoords = [];
      for (let lng = -180; lng <= 180; lng += 2) {
        // Buscar la l√≠nea de crep√∫sculo civil (sol 6¬∞ bajo horizonte)
        let lat = findTerminatorLat(lng, now);
        // Desplazar hacia el lado iluminado
        lat = northIsDark ? lat - 8 : lat + 8;
        twilightCoords.push([lat, lng]);
      }
      
      // A√±adir el terminador original para crear una banda
      for (let i = terminatorCoords.length - 1; i >= 0; i--) {
        twilightCoords.push(terminatorCoords[i]);
      }
      twilightCoords.push(twilightCoords[0]);

      const twilightPolygon = L.polygon(twilightCoords, {
        fillColor: '#1a1a2e',
        fillOpacity: 0.25,
        stroke: false,
        interactive: false,
        smoothFactor: 1
      });
      nightLayer.addLayer(twilightPolygon);

      // Actualizar info panel
      updateInfoPanel(now);
    }

    // ============================================
    // VOLCANES ACTIVOS (datos en tiempo real desde USGS)
    // ============================================
    
    // Volcanes con erupciones recientes conocidos (fallback si API falla)
    const volcanesActivos = [
      // M√°s activos en 2025
      { name: 'Etna', lat: 37.734, lng: 14.999, country: 'Italia', lastActivity: '2025-06' },
      { name: 'Kilauea', lat: 19.421, lng: -155.287, country: 'Haw√°i, EE.UU.', lastActivity: '2025-05' },
      { name: 'Kanlaon', lat: 10.412, lng: 123.132, country: 'Filipinas', lastActivity: '2025-04' },
      { name: 'Stromboli', lat: 38.789, lng: 15.213, country: 'Italia', lastActivity: '2025-01' },
      { name: 'Popocat√©petl', lat: 19.023, lng: -98.622, country: 'M√©xico', lastActivity: '2025-01' },
      
      // === ACTIVIDAD 2024 (GRANDES) ===
      { name: 'Sakurajima', lat: 31.580, lng: 130.657, country: 'Jap√≥n', lastActivity: '2024-12' },
      { name: 'Semeru', lat: -8.108, lng: 112.922, country: 'Indonesia', lastActivity: '2024-12' },
      { name: 'Erebus', lat: -77.530, lng: 167.170, country: 'Ant√°rtida', lastActivity: '2024-12' },
      { name: 'Shishaldin', lat: 54.756, lng: -163.971, country: 'Alaska, EE.UU.', lastActivity: '2024-11' },
      { name: 'Fuego', lat: 14.473, lng: -90.880, country: 'Guatemala', lastActivity: '2024-11' },
      { name: 'Merapi', lat: -7.542, lng: 110.446, country: 'Indonesia', lastActivity: '2024-11' },
      { name: 'Aso', lat: 32.884, lng: 131.104, country: 'Jap√≥n', lastActivity: '2024-10' },
      { name: 'Pacaya', lat: 14.381, lng: -90.601, country: 'Guatemala', lastActivity: '2024-10' },
      { name: 'Great Sitkin', lat: 52.076, lng: -176.130, country: 'Alaska, EE.UU.', lastActivity: '2024-09' },
      { name: 'Pavlof', lat: 55.417, lng: -161.894, country: 'Alaska, EE.UU.', lastActivity: '2024-08' },
      { name: 'Reventador', lat: -0.077, lng: -77.656, country: 'Ecuador', lastActivity: '2024-08' },
      { name: 'Fagradalsfjall', lat: 63.903, lng: -22.272, country: 'Islandia', lastActivity: '2024-08' },
      { name: 'Piton de la Fournaise', lat: -21.244, lng: 55.708, country: 'Reuni√≥n', lastActivity: '2024-07' },
      { name: 'Cleveland', lat: 52.825, lng: -169.945, country: 'Alaska, EE.UU.', lastActivity: '2024-07' },
      { name: 'Krakatau', lat: -6.102, lng: 105.423, country: 'Indonesia', lastActivity: '2024-06' },
      { name: 'Nyiragongo', lat: -1.52, lng: 29.25, country: 'R.D. Congo', lastActivity: '2024-05' },
      { name: 'Villarrica', lat: -39.420, lng: -71.931, country: 'Chile', lastActivity: '2024-03' },
      { name: 'Nevados de Chill√°n', lat: -36.863, lng: -71.377, country: 'Chile', lastActivity: '2024-01' },
      
      // === ACTIVIDAD 2023 (MEDIANOS) ===
      { name: 'Mauna Loa', lat: 19.475, lng: -155.608, country: 'Haw√°i, EE.UU.', lastActivity: '2023-12' },
      { name: 'Sundhn√∫kur', lat: 63.898, lng: -22.451, country: 'Islandia', lastActivity: '2023-12' },
      { name: 'Katla', lat: 63.633, lng: -19.051, country: 'Islandia', lastActivity: '2023-08' },
      { name: 'Cotopaxi', lat: -0.677, lng: -78.436, country: 'Ecuador', lastActivity: '2023-07' },
      { name: 'Ubinas', lat: -16.355, lng: -70.903, country: 'Per√∫', lastActivity: '2023-06' },
      { name: 'Sinabung', lat: 3.170, lng: 98.392, country: 'Indonesia', lastActivity: '2023-03' },
      
      // === ACTIVIDAD ANTERIOR (PEQUE√ëOS - CASI PUNTOS) ===
      { name: 'Gr√≠msv√∂tn', lat: 64.416, lng: -17.316, country: 'Islandia', lastActivity: '2022-11' },
      { name: 'Askja', lat: 65.030, lng: -16.750, country: 'Islandia', lastActivity: '2021-07' },
      { name: 'Taal', lat: 14.002, lng: 120.993, country: 'Filipinas', lastActivity: '2021-07' },
      { name: 'Hekla', lat: 63.981, lng: -19.703, country: 'Islandia', lastActivity: '2000-02' },
      { name: 'Tungurahua', lat: -1.467, lng: -78.442, country: 'Ecuador', lastActivity: '2016-02' },
      { name: 'Eyjafjallaj√∂kull', lat: 63.633, lng: -19.633, country: 'Islandia', lastActivity: '2010-05' },
      
      // Volcanes muy activos adicionales
      { name: 'Klyuchevskoy', lat: 56.056, lng: 160.642, country: 'Rusia (Kamchatka)', lastActivity: '2024-09' },
      { name: 'Bezymianny', lat: 55.972, lng: 160.595, country: 'Rusia (Kamchatka)', lastActivity: '2024-08' },
      { name: 'Karymsky', lat: 54.049, lng: 159.443, country: 'Rusia (Kamchatka)', lastActivity: '2024-07' },
      { name: 'Turrialba', lat: 10.025, lng: -83.767, country: 'Costa Rica', lastActivity: '2024-03' },
      { name: 'Sangay', lat: -2.005, lng: -78.341, country: 'Ecuador', lastActivity: '2024-06' },
      { name: 'Sabancaya', lat: -15.787, lng: -71.857, country: 'Per√∫', lastActivity: '2024-11' },
      { name: 'Nevado del Ruiz', lat: 4.892, lng: -75.324, country: 'Colombia', lastActivity: '2024-09' },
      { name: 'Lascar', lat: -23.370, lng: -67.730, country: 'Chile', lastActivity: '2023-11' },
      { name: 'Dukono', lat: 1.680, lng: 127.894, country: 'Indonesia', lastActivity: '2024-12' },
      { name: 'Ibu', lat: 1.488, lng: 127.630, country: 'Indonesia', lastActivity: '2024-11' },
      { name: 'Ruang', lat: 2.303, lng: 125.369, country: 'Indonesia', lastActivity: '2024-04' },
      { name: 'Lewotolok', lat: -8.272, lng: 123.505, country: 'Indonesia', lastActivity: '2024-08' },
      { name: 'Agung', lat: -8.343, lng: 115.508, country: 'Indonesia (Bali)', lastActivity: '2019-06' },
      { name: 'Mayon', lat: 13.257, lng: 123.685, country: 'Filipinas', lastActivity: '2023-06' },
      { name: 'Bulusan', lat: 12.770, lng: 124.051, country: 'Filipinas', lastActivity: '2024-06' },
      { name: 'Taal', lat: 14.002, lng: 120.993, country: 'Filipinas', lastActivity: '2024-03' }
    ];

    const volcanesLayer = L.layerGroup().addTo(map);
    let cachedVolcanoData = null;

    // Funci√≥n para cargar volcanes desde API de USGS (eventos volc√°nicos)
    async function loadVolcanoes() {
      try {
        console.log('üåã Cargando volcanes activos...');
        
        // M√©todo 1: Buscar eventos s√≠smicos volc√°nicos (√∫ltima semana)
        const response = await fetch('https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_week.geojson');
        const data = await response.json();
        
        // Filtrar eventos que son volc√°nicos (profundidad < 10km y en zona volc√°nica)
        const volcanicEvents = data.features.filter(quake => {
          const depth = quake.geometry.coordinates[2];
          const place = quake.properties.place?.toLowerCase() || '';
          return depth < 10 && (
            place.includes('volcano') || 
            place.includes('volcanic') ||
            place.includes('crater') ||
            place.includes('eruption')
          );
        });
        
        console.log(`  ‚úì ${volcanicEvents.length} eventos volc√°nicos encontrados`);
        
        // Agrupar por ubicaci√≥n (volcanes con m√∫ltiples eventos)
        const volcanoGroups = {};
        
        volcanicEvents.forEach(event => {
          const coords = event.geometry.coordinates;
          const place = event.properties.place;
          const key = `${coords[1].toFixed(2)},${coords[0].toFixed(2)}`;
          
          if (!volcanoGroups[key]) {
            volcanoGroups[key] = {
              lat: coords[1],
              lng: coords[0],
              name: place,
              events: [],
              lastActivity: event.properties.time,
              maxMag: event.properties.mag || 0
            };
          }
          
          volcanoGroups[key].events.push(event);
          volcanoGroups[key].lastActivity = Math.max(volcanoGroups[key].lastActivity, event.properties.time);
          volcanoGroups[key].maxMag = Math.max(volcanoGroups[key].maxMag, event.properties.mag || 0);
        });
        
        const activeVolcanoes = Object.values(volcanoGroups);
        console.log(`  ‚úì ${activeVolcanoes.length} volcanes activos agrupados`);
        
        // Solo volcanes con actividad real (sin datos hardcodeados antiguos)
        const combinedVolcanoes = [...activeVolcanoes];
        
        console.log(`  ‚úì Total volcanes con actividad real: ${combinedVolcanoes.length}`);
        
        // Limpiar capa de volcanes
        volcanesLayer.clearLayers();
        
        // Renderizar volcanes
        combinedVolcanoes.forEach(v => {
          const now = Date.now();
          const hoursAgo = (now - v.lastActivity) / (1000 * 60 * 60);
          const daysAgo = hoursAgo / 24;
          
          // Determinar tama√±o seg√∫n actividad reciente
          let size = 6;
          let isVeryActive = false;
          let isActive = false;
          
          if (daysAgo < 1) {
            size = 12 + v.maxMag * 2;
            isVeryActive = true;
          } else if (daysAgo < 7) {
            size = 10 + v.maxMag;
            isActive = true;
          } else if (daysAgo < 30) {
            size = 8;
          }
          
          // Color seg√∫n actividad
          let fillColor = '#ff4444';
          let borderColor = '#cc0000';
          let fillOpacity = 0.6;
          
          if (isVeryActive) {
            fillColor = '#ff0000';
            borderColor = '#ff0000';
            fillOpacity = 0.9;
          } else if (isActive) {
            fillColor = '#ff4444';
            borderColor = '#ff0000';
            fillOpacity = 0.75;
          } else {
            fillOpacity = 0.4;
          }
          
          const marker = L.circleMarker([v.lat, v.lng], {
            radius: size,
            fillColor: fillColor,
            color: borderColor,
            weight: isVeryActive ? 3 : 2,
            opacity: isVeryActive ? 1 : 0.8,
            fillOpacity: fillOpacity
          });
          
          // Formatear tiempo
          const timeText = daysAgo < 1 ? 
            `hace ${Math.floor(hoursAgo)} horas` : 
            `hace ${Math.floor(daysAgo)} d√≠as`;
          
          let statusEmoji = '';
          let statusText = '';
          if (isVeryActive) {
            statusEmoji = 'üî¥';
            statusText = 'ACTIVIDAD RECIENTE';
          } else if (isActive) {
            statusEmoji = 'üü†';
            statusText = 'ACTIVIDAD ESTA SEMANA';
          } else {
            statusEmoji = 'üü°';
            statusText = 'Monitoreado';
          }
          
          marker.bindPopup(`
            <div style="font-family: sans-serif;">
              <b style="color: #ff4444; font-size: 14px;">üåã ${v.name}</b><br>
              <span style="font-size: 12px;">${v.country || 'Ubicaci√≥n'}</span><br>
              ${statusEmoji} <b style="font-size: 11px;">${statusText}</b><br>
              <span style="font-size: 11px; color: #888;">${timeText}</span><br>
              ${v.events.length > 0 ? `<span style="font-size: 10px;">Eventos s√≠smicos: ${v.events.length}</span>` : ''}
            </div>
          `);
          
          // Animaci√≥n para volcanes muy activos
          if (isVeryActive) {
            let growing = true;
            let currentRadius = size;
            const baseRadius = size;
            const maxRadius = size * 1.8;
            
            const pulseInterval = setInterval(() => {
              if (growing) {
                currentRadius += 0.15;
                if (currentRadius >= maxRadius) growing = false;
              } else {
                currentRadius -= 0.15;
                if (currentRadius <= baseRadius) growing = true;
              }
              
              marker.setRadius(currentRadius);
              marker.setStyle({
                fillOpacity: 0.9 - ((currentRadius - baseRadius) / (maxRadius - baseRadius)) * 0.3
              });
            }, 80);
            
            // Guardar para limpiar
            pulseCircles.push({ circle: marker, interval: pulseInterval });
          }
          
          volcanesLayer.addLayer(marker);
        });
        
        // Actualizar contador
        const volcanoCount = combinedVolcanoes.filter(v => (now - v.lastActivity) / (1000 * 60 * 60 * 24) < 30).length;
        console.log(`‚úÖ ${combinedVolcanoes.length} volcanes cargados (${volcanoCount} activos √∫ltimos 30 d√≠as)`);
        
        cachedVolcanoData = combinedVolcanoes;
        
      } catch (error) {
        console.error('Error cargando volcanes:', error);
        // Usar volcanes hardcodeados como fallback
        if (!cachedVolcanoData) {
          console.log('‚ÑπÔ∏è Usando volcanes conocidos (fallback)');
          renderFallbackVolcanoes();
        }
      }
    }
    
    // Renderizar volcanes hardcodeados (fallback)
    function renderFallbackVolcanoes() {
      volcanesLayer.clearLayers();

    // Calcular tama√±o seg√∫n antig√ºedad de la actividad
    function getVolcanoSize(lastActivity) {
      const now = new Date();
      const activityDate = new Date(lastActivity + '-01'); // A√±adir d√≠a para parsear
      const yearActivity = parseInt(lastActivity.split('-')[0]);
      
      // 2025 = muy grande (14px)
      // 2024 = grande (11px)
      // 2023 = medio (8px)
      // Antes de 2023 = casi un punto (4px)
      if (yearActivity >= 2025) return 14;
      if (yearActivity === 2024) return 11;
      if (yearActivity === 2023) return 8;
      return 4;
    }
    
    function getActivityStatus(lastActivity) {
      const yearActivity = parseInt(lastActivity.split('-')[0]);
      const now = new Date();
      const currentYear = now.getFullYear();
      
      if (yearActivity >= 2025) return 'Erupci√≥n 2025 ‚ö†Ô∏è';
      if (yearActivity === 2024) return 'Activo 2024';
      if (yearActivity === 2023) return 'Activo 2023';
      if (yearActivity >= 2020) return 'Actividad reciente';
      if (yearActivity >= 2010) return 'Actividad hist√≥rica';
      return 'Volc√°n activo conocido';
    }

    volcanesActivos.forEach(v => {
      const size = getVolcanoSize(v.lastActivity);
      const status = getActivityStatus(v.lastActivity);
      
      // Formatear fecha para mostrar
      const [year, month] = v.lastActivity.split('-');
      const monthNames = ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'];
      const formattedDate = `${monthNames[parseInt(month) - 1]} ${year}`;
      
      const marker = L.circleMarker([v.lat, v.lng], {
        radius: size,
        fillColor: CONFIG.colors.volcano,
        color: '#990000',
        weight: 2,
        opacity: 1,
        fillOpacity: 0.7
      });
      
      marker.bindPopup(`
        <div style="font-family: sans-serif;">
          <b style="color: ${CONFIG.colors.volcano}; font-size: 14px;">üåã ${v.name}</b><br>
          <span style="font-size: 12px;">${v.country}</span><br>
          <b style="font-size: 11px;">√öltima actividad:</b> ${formattedDate}<br>
          <span style="font-size: 11px; color: #666;">${status}</span>
        </div>
      `);
      
      volcanesLayer.addLayer(marker);
    });
    
    console.log(`‚úÖ ${volcanesActivos.length} volcanes conocidos renderizados (fallback)`);
  } // Fin de renderFallbackVolcanoes

    // ============================================
    // TERREMOTOS RECIENTES (USGS)
    // ============================================
    const earthquakesLayer = L.layerGroup().addTo(map);
    let previousEarthquakeIds = new Set(); // Para detectar terremotos nuevos
    const pulseCircles = []; // Almacenar c√≠rculos pulsantes
    let cachedEarthquakeData = null; // Cache para evitar perder datos si falla el fetch

    async function loadEarthquakes() {
      try {
        // Cargar m√∫ltiples feeds para tener datos m√°s completos y actuales
        const feeds = [
          'https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_hour.geojson',   // √öltima hora
          'https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_day.geojson',    // √öltimas 24h
          'https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/2.5_week.geojson'    // Semana (M2.5+)
        ];
        
        // Cargar feeds en paralelo
        const responses = await Promise.allSettled(
          feeds.map(url => fetch(url).then(r => r.json()))
        );
        
        // Combinar todos los terremotos
        let allFeatures = [];
        responses.forEach((result, idx) => {
          if (result.status === 'fulfilled' && result.value?.features) {
            console.log(`‚úì Feed ${idx + 1}: ${result.value.features.length} terremotos`);
            allFeatures.push(...result.value.features);
          }
        });
        
        // Deduplicar por ID
        const seen = new Set();
        const uniqueFeatures = allFeatures.filter(quake => {
          const id = quake.properties.id || quake.properties.code;
          if (seen.has(id)) return false;
          seen.add(id);
          return true;
        });
        
        console.log(`üìä Total terremotos √∫nicos: ${uniqueFeatures.length}`);
        
        const data = { features: uniqueFeatures };
        if (!data || !data.features) throw new Error('Datos de terremotos inv√°lidos');

        // Detectar terremotos nuevos
        const currentEarthquakeIds = new Set();
        const newEarthquakes = [];
        
        // Limpiar c√≠rculos pulsantes y capa SOLO si tenemos datos v√°lidos
        pulseCircles.forEach(({ circle, interval }) => {
          clearInterval(interval);
          if (earthquakesLayer.hasLayer(circle)) {
            earthquakesLayer.removeLayer(circle);
          }
        });
        pulseCircles.length = 0;

        earthquakesLayer.clearLayers();

        data.features.forEach(quake => {
          const coords = quake.geometry.coordinates;
          const props = quake.properties;
          const mag = props.mag || 0;
          const depth = coords[2] || 10; // Profundidad en km
          const quakeId = props.id || props.code;
          
          // Filtrar terremotos muy peque√±os
          if (mag < 2.5) return;
          
          // Guardar ID y detectar si es nuevo
          currentEarthquakeIds.add(quakeId);
          const isNew = previousEarthquakeIds.size > 0 && !previousEarthquakeIds.has(quakeId);
          if (isNew) {
            newEarthquakes.push({ coords, mag, quakeId });
          }
          
          // Calcular antig√ºedad del terremoto
          const now = Date.now();
          const quakeTime = props.time;
          const hoursAgo = (now - quakeTime) / (1000 * 60 * 60);
          const isVeryRecent = hoursAgo <= 24; // √öltimas 24 horas
          const isUltraRecent = hoursAgo <= 6; // √öltimas 6 horas
          
          // Radio del c√≠rculo exterior seg√∫n magnitud
          const outerRadius = 4 + mag * 1.5;
          
          // Radio del c√≠rculo interior seg√∫n profundidad
          // Terremotos superficiales (< 70km) = c√≠rculo grande
          // Terremotos profundos (> 300km) = c√≠rculo peque√±o
          const depthRatio = Math.max(0.2, Math.min(1, 1 - (depth / 400)));
          const innerRadius = outerRadius * depthRatio * 0.7;
          
          // Color del c√≠rculo interior m√°s oscuro
          const innerColor = depth < 70 ? '#cc9900' : 
                            depth < 150 ? '#996600' : 
                            '#663300';
          
          // Determinar clase de animaci√≥n seg√∫n antig√ºedad y magnitud
          let animationClass = '';
          if (isUltraRecent) {
            // √öltimas 6 horas - animaci√≥n seg√∫n magnitud
            if (mag >= 6.0) animationClass = 'quake-very-recent-strong';
            else if (mag >= 4.5) animationClass = 'quake-very-recent-medium';
            else animationClass = 'quake-very-recent-weak';
          } else if (isVeryRecent) {
            // 6-24 horas - animaci√≥n suave
            animationClass = 'quake-recent';
          }
          // > 24h - sin animaci√≥n (est√°tico)
          
          // C√≠rculo exterior (magnitud) - sin className para animaci√≥n manual
          const outerCircle = L.circleMarker([coords[1], coords[0]], {
            radius: outerRadius,
            fillColor: CONFIG.colors.earthquake,
            color: isVeryRecent ? '#ffaa00' : '#ff8800',
            weight: isVeryRecent ? 2.5 : 2,
            opacity: isVeryRecent ? 1 : 0.7,
            fillOpacity: isVeryRecent ? 0.7 : 0.5
          });
          
          // Aplicar animaci√≥n manual con setInterval si es reciente
          if (isVeryRecent) {
            let growing = true;
            let currentOpacity = isVeryRecent ? 0.7 : 0.5;
            let currentRadius = outerRadius;
            const baseRadius = outerRadius;
            
            // Determinar par√°metros de animaci√≥n seg√∫n antig√ºedad y magnitud
            let maxRadius, speed, opacityMin;
            if (isUltraRecent && mag >= 6.0) {
              // Muy reciente y fuerte
              maxRadius = baseRadius * 2.5;
              speed = 0.08;
              opacityMin = 0.3;
            } else if (isUltraRecent && mag >= 4.5) {
              // Muy reciente medio
              maxRadius = baseRadius * 2.0;
              speed = 0.06;
              opacityMin = 0.35;
            } else if (isUltraRecent) {
              // Muy reciente d√©bil
              maxRadius = baseRadius * 1.5;
              speed = 0.05;
              opacityMin = 0.4;
            } else {
              // Reciente (6-24h)
              maxRadius = baseRadius * 1.3;
              speed = 0.03;
              opacityMin = 0.45;
            }
            
            const pulseInterval = setInterval(() => {
              if (growing) {
                currentRadius += speed * baseRadius;
                currentOpacity -= speed / 2;
                if (currentRadius >= maxRadius) {
                  growing = false;
                }
              } else {
                currentRadius -= speed * baseRadius;
                currentOpacity += speed / 2;
                if (currentRadius <= baseRadius) {
                  growing = true;
                }
              }
              
              outerCircle.setRadius(currentRadius);
              outerCircle.setStyle({
                fillOpacity: Math.max(opacityMin, Math.min(0.7, currentOpacity)),
                opacity: Math.max(opacityMin + 0.2, Math.min(1, currentOpacity + 0.3))
              });
            }, 50);
            
            // Guardar intervalo para limpiar despu√©s
            pulseCircles.push({ circle: outerCircle, interval: pulseInterval });
          }
          
          // C√≠rculo interior (profundidad)
          const innerCircle = L.circleMarker([coords[1], coords[0]], {
            radius: innerRadius,
            fillColor: innerColor,
            color: innerColor,
            weight: 0,
            opacity: 1,
            fillOpacity: 0.8
          });
          
          const fecha = new Date(props.time).toLocaleString('es-ES');
          const hoursAgoText = hoursAgo < 1 ? 
            `hace ${Math.floor(hoursAgo * 60)} minutos` : 
            `hace ${Math.floor(hoursAgo)} horas`;
          
          // Indicador visual de antig√ºedad
          let timeIndicator = '';
          if (isUltraRecent) {
            timeIndicator = 'üî¥ <b style="color: #ff4444;">MUY RECIENTE</b> ';
          } else if (isVeryRecent) {
            timeIndicator = 'üü° <b style="color: #ffaa00;">RECIENTE</b> ';
          }
          
          const popup = `
            <div style="font-family: sans-serif;">
              <b style="color: ${CONFIG.colors.earthquake}; font-size: 14px;">üåç Terremoto</b><br>
              ${timeIndicator}${hoursAgoText}<br>
              <b>Magnitud:</b> ${mag.toFixed(1)}<br>
              <b>Profundidad:</b> ${depth.toFixed(1)} km ${depth < 70 ? '(superficial)' : depth < 300 ? '(intermedio)' : '(profundo)'}<br>
              <b>Fecha:</b> ${fecha}<br>
              <b>Lugar:</b> ${props.place || 'Desconocido'}
            </div>
          `;
          
          outerCircle.bindPopup(popup);
          innerCircle.bindPopup(popup);
          
          earthquakesLayer.addLayer(outerCircle);
          earthquakesLayer.addLayer(innerCircle);
          
          // Si es un terremoto NUEVO, a√±adir c√≠rculo pulsante
          if (isNew) {
            createPulsingCircle([coords[1], coords[0]], outerRadius, mag);
          }
        });
        
        // Actualizar lista de IDs conocidos y cache
        previousEarthquakeIds = currentEarthquakeIds;
        cachedEarthquakeData = data;
        
        // Contar terremotos recientes (√∫ltimas 24h)
        const now = Date.now();
        const oneDayAgo = now - (24 * 60 * 60 * 1000);
        const recentCount = data.features.filter(q => q.properties.time >= oneDayAgo).length;
        
        // Actualizar panel lateral de terremotos recientes
        updateQuakesList(data.features);
        
        if (newEarthquakes.length > 0) {
          console.log(`‚úì ${data.features.length} terremotos cargados (${recentCount} recientes, ${newEarthquakes.length} NUEVOS)`);
        } else {
          console.log(`‚úì ${data.features.length} terremotos cargados (${recentCount} en √∫ltimas 24h)`);
        }
        
      } catch (error) {
        console.error('Error cargando terremotos (manteniendo datos previos si existen):', error);
        if (cachedEarthquakeData) {
          console.warn('Usando datos cacheados de terremotos; mapa se mantiene intacto.');
          // No hacemos nada: mantenemos en pantalla los datos ya renderizados
        } else {
          console.warn('No hay datos cacheados de terremotos disponibles.');
        }
      }
    }
    
    // Crear c√≠rculo pulsante para terremotos nuevos
    function createPulsingCircle(latlng, baseRadius, magnitude) {
      const pulseCircle = L.circle(latlng, {
        radius: baseRadius * 1000, // Convertir a metros para L.circle
        fillColor: CONFIG.colors.earthquake,
        color: CONFIG.colors.earthquake,
        weight: 2,
        opacity: 0.7,
        fillOpacity: 0.1,
        interactive: false
      }).addTo(earthquakesLayer);
      
      // Animaci√≥n con setInterval
      let growing = true;
      let currentScale = 1;
      const maxScale = 3;
      const minScale = 1;
      const step = 0.05;
      
      const pulseInterval = setInterval(() => {
        if (growing) {
          currentScale += step;
          if (currentScale >= maxScale) {
            growing = false;
          }
        } else {
          currentScale -= step;
          if (currentScale <= minScale) {
            growing = true;
          }
        }
        
        pulseCircle.setRadius(baseRadius * 1000 * currentScale);
        pulseCircle.setStyle({
          opacity: 0.7 / currentScale,
          fillOpacity: 0.15 / currentScale
        });
      }, 50);
      
      // Guardar para poder limpiar despu√©s
      pulseCircles.push({ circle: pulseCircle, interval: pulseInterval });
      
      // Detener animaci√≥n despu√©s de la pr√≥xima actualizaci√≥n (5 minutos)
      setTimeout(() => {
        clearInterval(pulseInterval);
        if (earthquakesLayer.hasLayer(pulseCircle)) {
          earthquakesLayer.removeLayer(pulseCircle);
        }
        // Remover de la lista
        const index = pulseCircles.findIndex(p => p.circle === pulseCircle);
        if (index > -1) pulseCircles.splice(index, 1);
      }, 300000); // 5 minutos
    }

    // ============================================
    // INFO PANEL
    // ============================================
    function updateInfoPanel(date) {
      const clock = document.getElementById('clock');
      const sunStatus = document.getElementById('sun-status');

      // Si no existen los elementos (panel oculto), salir sin romper el resto del mapa
      if (!clock || !sunStatus) return;
      
      clock.textContent = `üïê ${date.toLocaleTimeString('es-ES')}`;
      
      // Calcular posici√≥n del sol en Madrid como referencia
      const madridSun = SunCalc.getPosition(date, 40.4168, -3.7038);
      const altitude = madridSun.altitude * 180 / Math.PI;
      
      if (altitude > 0) {
        sunStatus.textContent = `‚òÄÔ∏è D√≠a en Madrid`;
      } else {
        sunStatus.textContent = `üåô Noche en Madrid`;
      }
    }

    // ============================================
    // ACTUALIZACI√ìN AUTOM√ÅTICA
    // ============================================
    
    // ============================================
    // PANEL LATERAL DE TERREMOTOS RECIENTES
    // ============================================
    
    // Toggle del panel
    document.getElementById('quakes-header')?.addEventListener('click', function() {
      const panel = document.getElementById('recent-quakes');
      const toggle = document.getElementById('quakes-toggle');
      panel.classList.toggle('collapsed');
      toggle.textContent = panel.classList.contains('collapsed') ? '‚ñ∂' : '‚óÄ';
    });
    
    // Funci√≥n para actualizar la lista de terremotos
    function updateQuakesList(features) {
      const quakesList = document.getElementById('quakes-list');
      if (!quakesList) return;
      
      // Ordenar por tiempo (m√°s reciente primero)
      const sorted = [...features]
        .filter(q => q.properties.mag >= 2.5)
        .sort((a, b) => b.properties.time - a.properties.time);
      
      // Tomar solo los 30 m√°s recientes
      const recent = sorted.slice(0, 30);
      
      // Actualizar estad√≠sticas
      const now = Date.now();
      const last24h = features.filter(q => (now - q.properties.time) < 24 * 60 * 60 * 1000).length;
      const last6h = features.filter(q => (now - q.properties.time) < 6 * 60 * 60 * 1000).length;
      
      if (document.getElementById('totalQuakes')) {
        document.getElementById('totalQuakes').textContent = `Total: ${features.length}`;
      }
      if (document.getElementById('last24h')) {
        document.getElementById('last24h').textContent = `√öltimas 24h: ${last24h}`;
      }
      if (document.getElementById('last6h')) {
        document.getElementById('last6h').textContent = `√öltimas 6h: ${last6h}`;
      }
      
      // Generar HTML de la lista
      quakesList.innerHTML = recent.map(quake => {
        const props = quake.properties;
        const coords = quake.geometry.coordinates;
        const mag = props.mag.toFixed(1);
        const depth = coords[2].toFixed(0);
        const hoursAgo = (now - props.time) / (1000 * 60 * 60);
        
        // Determinar clases seg√∫n antig√ºedad y magnitud
        let classes = ['quake-item'];
        if (hoursAgo < 6) classes.push('very-recent');
        if (mag >= 6.0) classes.push('strong');
        
        // Formato de tiempo
        const timeText = hoursAgo < 1 ? 
          `hace ${Math.floor(hoursAgo * 60)} min` : 
          `hace ${Math.floor(hoursAgo)}h`;
        
        // Indicador visual
        let indicator = '';
        if (hoursAgo < 1) indicator = 'üî¥';
        else if (hoursAgo < 6) indicator = 'üü†';
        else if (hoursAgo < 24) indicator = 'üü°';
        
        return `
          <div class="${classes.join(' ')}" 
               onclick="map.setView([${coords[1]}, ${coords[0]}], 8, {animate: true, duration: 1}); 
                        this.style.background='rgba(255,200,0,0.3)'; 
                        setTimeout(() => this.style.background='', 500);">
            <div class="quake-magnitude">${indicator} M${mag}</div>
            <div class="quake-location">${props.place || 'Ubicaci√≥n desconocida'}</div>
            <div class="quake-time">${timeText}</div>
            <div class="quake-depth">Profundidad: ${depth} km</div>
          </div>
        `;
      }).join('');
      
      console.log(`‚úì Lista de terremotos actualizada: ${recent.length} mostrados`);
    }
    
    // Actualizar sombra nocturna cada minuto
    setInterval(calculateNightShadow, 60000);
    
    // Actualizar terremotos cada 5 minutos
    setInterval(loadEarthquakes, 300000);
    
    // Cargar volcanes al inicio
    loadVolcanoes();
    
    // Actualizar volcanes cada 10 minutos
    setInterval(loadVolcanoes, 600000);
    
    // Actualizar reloj cada segundo
    setInterval(() => updateInfoPanel(new Date()), 1000);

    // ============================================
    // INICIALIZACI√ìN
    // ============================================
    map.whenReady(() => {
      console.log('üó∫Ô∏è Mapa inicializado');
      
      // Ajustar el mapa a la ventana al cargar
      adjustMapToWindow();
      setTimeout(adjustMapToWindow, 100);

      calculateNightShadow();
      loadEarthquakes();
      loadVolcanoes();
      console.log('‚úì Datos en tiempo real cargados (terremotos + volcanes)');
      console.log('üìê Zoom m√≠nimo din√°mico activado - Sin bordes negros');
    });

  </script>
</body>
</html>

