<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Mapa Tierra en Tiempo Real</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }
    html, body {
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #000000;
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', sans-serif;
    }
    #map {
      position: absolute;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: #000000;
    }
    /* Fondo negro para el contenedor de tiles */
    .leaflet-container {
      background: #000000 !important;
    }
    .leaflet-tile-pane {
      background: #000000 !important;
    }
    /* Ocultar tiles que no cargan */
    .leaflet-tile-container {
      background: #000000 !important;
    }
    .leaflet-tile {
      border: none !important;
      background: #000000 !important;
    }
    /* Ocultar completamente el mensaje de error de tiles */
    .leaflet-tile[src*="data:image"],
    .leaflet-tile-loaded[src*="data:image"] {
      opacity: 0 !important;
      visibility: hidden !important;
      display: none !important;
    }
    /* Ocultar cualquier tile con error */
    .leaflet-tile-error {
      opacity: 0 !important;
      visibility: hidden !important;
      display: none !important;
    }
    /* Hacer la atribuci√≥n m√°s discreta */
    .leaflet-control-attribution {
      background: rgba(0, 0, 0, 0.7) !important;
      color: rgba(255, 255, 255, 0.6) !important;
      font-size: 10px !important;
      padding: 2px 5px !important;
    }
    .leaflet-control-attribution a {
      color: rgba(255, 255, 255, 0.7) !important;
    }
    
    /* Animaciones para terremotos seg√∫n antig√ºedad y magnitud */
    @keyframes earthquake-pulse-strong {
      0%, 100% {
        transform: scale(1);
        opacity: 0.9;
        filter: drop-shadow(0 0 8px rgba(255, 136, 0, 0.8));
      }
      50% {
        transform: scale(2.5);
        opacity: 0.3;
        filter: drop-shadow(0 0 20px rgba(255, 136, 0, 1));
      }
    }
    
    @keyframes earthquake-pulse-medium {
      0%, 100% {
        transform: scale(1);
        opacity: 0.8;
        filter: drop-shadow(0 0 5px rgba(255, 200, 0, 0.6));
      }
      50% {
        transform: scale(2);
        opacity: 0.3;
        filter: drop-shadow(0 0 12px rgba(255, 200, 0, 0.8));
      }
    }
    
    @keyframes earthquake-pulse-weak {
      0%, 100% {
        transform: scale(1);
        opacity: 0.7;
        filter: drop-shadow(0 0 3px rgba(255, 230, 0, 0.4));
      }
      50% {
        transform: scale(1.5);
        opacity: 0.4;
        filter: drop-shadow(0 0 8px rgba(255, 230, 0, 0.6));
      }
    }
    
    /* Clases para aplicar animaciones */
    .quake-very-recent-strong {
      animation: earthquake-pulse-strong 1.5s ease-in-out infinite;
    }
    
    .quake-very-recent-medium {
      animation: earthquake-pulse-medium 2s ease-in-out infinite;
    }
    
    .quake-very-recent-weak {
      animation: earthquake-pulse-weak 2.5s ease-in-out infinite;
    }
    
    .quake-recent {
      animation: earthquake-pulse-weak 4s ease-in-out infinite;
      opacity: 0.6;
    }
    .info-panel {
      position: absolute;
      top: 15px;
      right: 15px;
      background: rgba(10, 14, 39, 0.9);
      backdrop-filter: blur(10px);
      color: #fff;
      padding: 12px 16px;
      border-radius: 8px;
      font-size: 13px;
      z-index: 1000;
      box-shadow: 0 4px 12px rgba(0,0,0,0.5);
      max-width: 250px;
    }
    .info-panel h3 {
      font-size: 14px;
      margin-bottom: 8px;
      color: #6dd5ed;
    }
    .info-item {
      margin: 4px 0;
      font-size: 12px;
      opacity: 0.9;
    }
    .legend {
      position: absolute;
      bottom: 30px;
      left: 15px;
      background: rgba(10, 14, 39, 0.45); /* m√°s transparente */
      backdrop-filter: blur(10px);
      color: #fff;
      padding: 12px;
      border-radius: 8px;
      font-size: 12px;
      z-index: 1000;
      box-shadow: 0 4px 12px rgba(0,0,0,0.5);
    }
    .legend-item {
      margin: 6px 0;
      display: flex;
      align-items: center;
      gap: 8px;
    }
    .legend-circle {
      width: 16px;
      height: 16px;
      border-radius: 50%;
      border: 2px solid;
    }
  </style>
</head>
<body>
  <div id="map"></div>
  
  <!-- Panel de info removido a petici√≥n del usuario -->

  <div class="legend">
    <div class="legend-item">
      <div class="legend-circle" style="background: #ffd700; border-color: #ffa500; animation: earthquake-pulse-strong 1.5s ease-in-out infinite;"></div>
      <span>Terremotos < 24h (pulsantes)</span>
    </div>
    <div class="legend-item">
      <div class="legend-circle" style="background: #ffd700; border-color: #ffa500; opacity: 0.5;"></div>
      <span>Terremotos > 24h (est√°ticos)</span>
    </div>
    <div class="legend-item" style="padding-left: 24px; font-size: 11px; opacity: 0.8;">
      <span>‚Ä¢ Tama√±o = magnitud ‚Ä¢ Centro oscuro = profundidad</span>
    </div>
    <div class="legend-item">
      <div class="legend-circle" style="background: #ff4444; border-color: #cc0000;"></div>
      <span>Volcanes (tama√±o=actividad)</span>
    </div>
  </div>

  <script src="https://unpkg.com/suncalc@1.9.0/suncalc.js"></script>
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script>
    'use strict';

    // ============================================
    // CONFIGURACI√ìN
    // ============================================
    const CONFIG = {
      openWeatherApiKey: 'c5424fe9f21a8a1e36206abaf7c1cf65',
      colors: {
        earthquake: '#ffd700',
        volcano: '#ff4444',
        night: '#000000'
      }
    };

    // ============================================
    // CREAR MAPA BASE CON AUTO-AJUSTE
    // ============================================
    
    let programmaticZoom = false; // Detectar si el zoom es program√°tico

    // Detectar modo preview (miniatura)
    const urlParams = new URLSearchParams(window.location.search);
    const isPreview = urlParams.has('preview');

    const map = L.map('map', {
      center: [0, 0],
      zoom: isPreview ? 1.7 : 2,
      minZoom: isPreview ? 1.4 : 1,
      maxZoom: 17,
      zoomControl: false,
      attributionControl: true,
      worldCopyJump: false,
      noWrap: true,
      preferCanvas: true,
      maxBounds: [[-85.05, -180], [85.05, 180]],
      maxBoundsViscosity: 1.0
    });

    // Calcular el zoom m√≠nimo necesario para llenar la ventana sin bordes negros
    function calculateMinZoom() {
      const mapElement = document.getElementById('map');
      const width = mapElement.offsetWidth;
      const height = mapElement.offsetHeight;
      
      // Tama√±o del mundo en p√≠xeles en zoom 0 = 256px
      // Rango de latitudes visibles: -85.05 a 85.05 (aprox 170¬∞ efectivos en Mercator)
      
      // Zoom necesario para llenar horizontalmente (360¬∞ = ancho de ventana)
      const zoomH = Math.log2(width / 256);
      
      // Zoom necesario para llenar verticalmente
      // En Mercator, la altura depende de las latitudes
      // Aproximaci√≥n: 170¬∞ visibles ‚âà 256px en zoom 0
      const zoomV = Math.log2(height / 256);
      
      // Usar el MAYOR para asegurar que siempre se llena al menos un eje
      const minZoom = Math.max(1.5, Math.max(zoomH, zoomV));
      
      // En modo preview, forzar un zoom m√≠nimo m√°s bajo para ver m√°s mundo
      if (isPreview) {
        return Math.max(Math.max(zoomH, zoomV), 1.4);
      }
      return minZoom;
    }
    
    // Ajustar el mapa para que siempre llene la ventana
    function adjustMapToWindow() {
      programmaticZoom = true;
      
      const requiredMinZoom = calculateMinZoom();
      const currentZoom = map.getZoom();
      
      // Actualizar el zoom m√≠nimo
      map.setMinZoom(requiredMinZoom);
      
      // Si el zoom actual es menor que el requerido, ajustarlo
      if (currentZoom < requiredMinZoom) {
        map.setZoom(requiredMinZoom, { animate: false });
      }
      
      setTimeout(() => {
        programmaticZoom = false;
      }, 100);
    }
    
    // El mapa ajusta autom√°ticamente el zoom m√≠nimo, pero el usuario puede hacer zoom libremente

    // Capa sat√©lite de ESRI
    const sateliteLayer = L.tileLayer(
      'https://server.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer/tile/{z}/{y}/{x}',
      {
        attribution: 'Tiles ¬© Esri',
        minZoom: 2,
        maxZoom: 17,
        noWrap: true,
        bounds: [[-85.05, -180], [85.05, 180]],
        errorTileUrl: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'
      }
    ).addTo(map);

    // Capa de nubes en tiempo real (con actualizaci√≥n autom√°tica)
    let cloudsLayer = L.tileLayer(
      `https://tile.openweathermap.org/map/clouds_new/{z}/{x}/{y}.png?appid=${CONFIG.openWeatherApiKey}&t=${Date.now()}`,
      {
        attribution: 'Nubes ¬© OpenWeatherMap',
        opacity: 0.5,
        minZoom: 2,
        maxZoom: 17,
        noWrap: true,
        bounds: [[-85.05, -180], [85.05, 180]],
        errorTileUrl: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'
      }
    ).addTo(map);

    // Actualizar nubes cada 10 minutos para datos frescos
    function updateClouds() {
      cloudsLayer.remove();
      cloudsLayer = L.tileLayer(
        `https://tile.openweathermap.org/map/clouds_new/{z}/{x}/{y}.png?appid=${CONFIG.openWeatherApiKey}&t=${Date.now()}`,
        {
          attribution: 'Nubes ¬© OpenWeatherMap',
          opacity: 0.5,
          minZoom: 2,
          maxZoom: 17,
          noWrap: true,
          bounds: [[-85.05, -180], [85.05, 180]],
          errorTileUrl: 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7'
        }
      ).addTo(map);
      console.log('‚òÅÔ∏è Capa de nubes actualizada:', new Date().toLocaleTimeString('es-ES'));
    }

    setInterval(updateClouds, 600000); // 600000ms = 10 minutos
    
    // Ajustar mapa cuando cambia el tama√±o de ventana
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        map.invalidateSize();
        adjustMapToWindow();
      }, 250);
    });

    // ============================================
    // SOMBRA D√çA/NOCHE MEJORADA
    // ============================================
    let nightLayer = L.layerGroup().addTo(map);

    function findTerminatorLat(lng, date) {
      // B√∫squeda binaria para encontrar donde el sol est√° en el horizonte
      let latMin = -90;
      let latMax = 90;
      const tolerance = 0.1;
      
      while (latMax - latMin > tolerance) {
        const lat1 = latMin + (latMax - latMin) / 3;
        const lat2 = latMax - (latMax - latMin) / 3;
        
        const sun1 = SunCalc.getPosition(date, lat1, lng);
        const sun2 = SunCalc.getPosition(date, lat2, lng);
        
        const diff1 = Math.abs(sun1.altitude);
        const diff2 = Math.abs(sun2.altitude);
        
        if (diff1 < diff2) {
          latMax = lat2;
        } else {
          latMin = lat1;
        }
      }
      
      return (latMin + latMax) / 2;
    }

    function calculateNightShadow() {
      const now = new Date();
      
      // Calcular el terminador con mejor precisi√≥n
      const terminatorCoords = [];
      for (let lng = -180; lng <= 180; lng += 1.5) {
        const lat = findTerminatorLat(lng, now);
        terminatorCoords.push([lat, lng]);
      }

      // Determinar qu√© hemisferio est√° en noche
      const testNorth = SunCalc.getPosition(now, 60, 0);
      const testSouth = SunCalc.getPosition(now, -60, 0);
      const northIsDark = testNorth.altitude < testSouth.altitude;

      nightLayer.clearLayers();
      
      // Crear banda principal (noche total)
      const nightCoords = [...terminatorCoords];
      if (northIsDark) {
        nightCoords.push([85, 180]);
        nightCoords.push([85, -180]);
      } else {
        nightCoords.push([-85, 180]);
        nightCoords.push([-85, -180]);
      }
      nightCoords.push(nightCoords[0]);

      const nightPolygon = L.polygon(nightCoords, {
        fillColor: '#000000',
        fillOpacity: 0.45,
        stroke: false,
        interactive: false,
        smoothFactor: 1
      });
      nightLayer.addLayer(nightPolygon);

      // A√±adir crep√∫sculo (sombra m√°s suave en el borde)
      const twilightCoords = [];
      for (let lng = -180; lng <= 180; lng += 2) {
        // Buscar la l√≠nea de crep√∫sculo civil (sol 6¬∞ bajo horizonte)
        let lat = findTerminatorLat(lng, now);
        // Desplazar hacia el lado iluminado
        lat = northIsDark ? lat - 8 : lat + 8;
        twilightCoords.push([lat, lng]);
      }
      
      // A√±adir el terminador original para crear una banda
      for (let i = terminatorCoords.length - 1; i >= 0; i--) {
        twilightCoords.push(terminatorCoords[i]);
      }
      twilightCoords.push(twilightCoords[0]);

      const twilightPolygon = L.polygon(twilightCoords, {
        fillColor: '#1a1a2e',
        fillOpacity: 0.25,
        stroke: false,
        interactive: false,
        smoothFactor: 1
      });
      nightLayer.addLayer(twilightPolygon);

      // Actualizar info panel
      updateInfoPanel(now);
    }

    // ============================================
    // VOLCANES ACTIVOS (con fecha de √∫ltima actividad)
    // ============================================
    const volcanesActivos = [
      // === ACTIVIDAD 2025 (MUY GRANDES) ===
      { name: 'Etna', lat: 37.734, lng: 14.999, country: 'Italia', lastActivity: '2025-06' },
      { name: 'Kilauea', lat: 19.421, lng: -155.287, country: 'Haw√°i, EE.UU.', lastActivity: '2025-05' },
      { name: 'Kanlaon', lat: 10.412, lng: 123.132, country: 'Filipinas', lastActivity: '2025-04' },
      { name: 'Stromboli', lat: 38.789, lng: 15.213, country: 'Italia', lastActivity: '2025-01' },
      { name: 'Popocat√©petl', lat: 19.023, lng: -98.622, country: 'M√©xico', lastActivity: '2025-01' },
      
      // === ACTIVIDAD 2024 (GRANDES) ===
      { name: 'Sakurajima', lat: 31.580, lng: 130.657, country: 'Jap√≥n', lastActivity: '2024-12' },
      { name: 'Semeru', lat: -8.108, lng: 112.922, country: 'Indonesia', lastActivity: '2024-12' },
      { name: 'Erebus', lat: -77.530, lng: 167.170, country: 'Ant√°rtida', lastActivity: '2024-12' },
      { name: 'Shishaldin', lat: 54.756, lng: -163.971, country: 'Alaska, EE.UU.', lastActivity: '2024-11' },
      { name: 'Fuego', lat: 14.473, lng: -90.880, country: 'Guatemala', lastActivity: '2024-11' },
      { name: 'Merapi', lat: -7.542, lng: 110.446, country: 'Indonesia', lastActivity: '2024-11' },
      { name: 'Aso', lat: 32.884, lng: 131.104, country: 'Jap√≥n', lastActivity: '2024-10' },
      { name: 'Pacaya', lat: 14.381, lng: -90.601, country: 'Guatemala', lastActivity: '2024-10' },
      { name: 'Great Sitkin', lat: 52.076, lng: -176.130, country: 'Alaska, EE.UU.', lastActivity: '2024-09' },
      { name: 'Pavlof', lat: 55.417, lng: -161.894, country: 'Alaska, EE.UU.', lastActivity: '2024-08' },
      { name: 'Reventador', lat: -0.077, lng: -77.656, country: 'Ecuador', lastActivity: '2024-08' },
      { name: 'Fagradalsfjall', lat: 63.903, lng: -22.272, country: 'Islandia', lastActivity: '2024-08' },
      { name: 'Piton de la Fournaise', lat: -21.244, lng: 55.708, country: 'Reuni√≥n', lastActivity: '2024-07' },
      { name: 'Cleveland', lat: 52.825, lng: -169.945, country: 'Alaska, EE.UU.', lastActivity: '2024-07' },
      { name: 'Krakatau', lat: -6.102, lng: 105.423, country: 'Indonesia', lastActivity: '2024-06' },
      { name: 'Nyiragongo', lat: -1.52, lng: 29.25, country: 'R.D. Congo', lastActivity: '2024-05' },
      { name: 'Villarrica', lat: -39.420, lng: -71.931, country: 'Chile', lastActivity: '2024-03' },
      { name: 'Nevados de Chill√°n', lat: -36.863, lng: -71.377, country: 'Chile', lastActivity: '2024-01' },
      
      // === ACTIVIDAD 2023 (MEDIANOS) ===
      { name: 'Mauna Loa', lat: 19.475, lng: -155.608, country: 'Haw√°i, EE.UU.', lastActivity: '2023-12' },
      { name: 'Sundhn√∫kur', lat: 63.898, lng: -22.451, country: 'Islandia', lastActivity: '2023-12' },
      { name: 'Katla', lat: 63.633, lng: -19.051, country: 'Islandia', lastActivity: '2023-08' },
      { name: 'Cotopaxi', lat: -0.677, lng: -78.436, country: 'Ecuador', lastActivity: '2023-07' },
      { name: 'Ubinas', lat: -16.355, lng: -70.903, country: 'Per√∫', lastActivity: '2023-06' },
      { name: 'Sinabung', lat: 3.170, lng: 98.392, country: 'Indonesia', lastActivity: '2023-03' },
      
      // === ACTIVIDAD ANTERIOR (PEQUE√ëOS - CASI PUNTOS) ===
      { name: 'Gr√≠msv√∂tn', lat: 64.416, lng: -17.316, country: 'Islandia', lastActivity: '2022-11' },
      { name: 'Askja', lat: 65.030, lng: -16.750, country: 'Islandia', lastActivity: '2021-07' },
      { name: 'Taal', lat: 14.002, lng: 120.993, country: 'Filipinas', lastActivity: '2021-07' },
      { name: 'Hekla', lat: 63.981, lng: -19.703, country: 'Islandia', lastActivity: '2000-02' },
      { name: 'Tungurahua', lat: -1.467, lng: -78.442, country: 'Ecuador', lastActivity: '2016-02' },
      { name: 'Eyjafjallaj√∂kull', lat: 63.633, lng: -19.633, country: 'Islandia', lastActivity: '2010-05' },
      
      // Volcanes muy activos adicionales
      { name: 'Klyuchevskoy', lat: 56.056, lng: 160.642, country: 'Rusia (Kamchatka)', lastActivity: '2024-09' },
      { name: 'Bezymianny', lat: 55.972, lng: 160.595, country: 'Rusia (Kamchatka)', lastActivity: '2024-08' },
      { name: 'Karymsky', lat: 54.049, lng: 159.443, country: 'Rusia (Kamchatka)', lastActivity: '2024-07' },
      { name: 'Turrialba', lat: 10.025, lng: -83.767, country: 'Costa Rica', lastActivity: '2024-03' },
      { name: 'Sangay', lat: -2.005, lng: -78.341, country: 'Ecuador', lastActivity: '2024-06' },
      { name: 'Sabancaya', lat: -15.787, lng: -71.857, country: 'Per√∫', lastActivity: '2024-11' },
      { name: 'Nevado del Ruiz', lat: 4.892, lng: -75.324, country: 'Colombia', lastActivity: '2024-09' },
      { name: 'Lascar', lat: -23.370, lng: -67.730, country: 'Chile', lastActivity: '2023-11' },
      { name: 'Dukono', lat: 1.680, lng: 127.894, country: 'Indonesia', lastActivity: '2024-12' },
      { name: 'Ibu', lat: 1.488, lng: 127.630, country: 'Indonesia', lastActivity: '2024-11' },
      { name: 'Ruang', lat: 2.303, lng: 125.369, country: 'Indonesia', lastActivity: '2024-04' },
      { name: 'Lewotolok', lat: -8.272, lng: 123.505, country: 'Indonesia', lastActivity: '2024-08' },
      { name: 'Agung', lat: -8.343, lng: 115.508, country: 'Indonesia (Bali)', lastActivity: '2019-06' },
      { name: 'Mayon', lat: 13.257, lng: 123.685, country: 'Filipinas', lastActivity: '2023-06' },
      { name: 'Bulusan', lat: 12.770, lng: 124.051, country: 'Filipinas', lastActivity: '2024-06' },
      { name: 'Taal', lat: 14.002, lng: 120.993, country: 'Filipinas', lastActivity: '2024-03' }
    ];

    const volcanesLayer = L.layerGroup().addTo(map);

    // Calcular tama√±o seg√∫n antig√ºedad de la actividad
    function getVolcanoSize(lastActivity) {
      const now = new Date();
      const activityDate = new Date(lastActivity + '-01'); // A√±adir d√≠a para parsear
      const yearActivity = parseInt(lastActivity.split('-')[0]);
      
      // 2025 = muy grande (14px)
      // 2024 = grande (11px)
      // 2023 = medio (8px)
      // Antes de 2023 = casi un punto (4px)
      if (yearActivity >= 2025) return 14;
      if (yearActivity === 2024) return 11;
      if (yearActivity === 2023) return 8;
      return 4;
    }
    
    function getActivityStatus(lastActivity) {
      const yearActivity = parseInt(lastActivity.split('-')[0]);
      const now = new Date();
      const currentYear = now.getFullYear();
      
      if (yearActivity >= 2025) return 'Erupci√≥n 2025 ‚ö†Ô∏è';
      if (yearActivity === 2024) return 'Activo 2024';
      if (yearActivity === 2023) return 'Activo 2023';
      if (yearActivity >= 2020) return 'Actividad reciente';
      if (yearActivity >= 2010) return 'Actividad hist√≥rica';
      return 'Volc√°n activo conocido';
    }

    volcanesActivos.forEach(v => {
      const size = getVolcanoSize(v.lastActivity);
      const status = getActivityStatus(v.lastActivity);
      
      // Formatear fecha para mostrar
      const [year, month] = v.lastActivity.split('-');
      const monthNames = ['Ene', 'Feb', 'Mar', 'Abr', 'May', 'Jun', 'Jul', 'Ago', 'Sep', 'Oct', 'Nov', 'Dic'];
      const formattedDate = `${monthNames[parseInt(month) - 1]} ${year}`;
      
      const marker = L.circleMarker([v.lat, v.lng], {
        radius: size,
        fillColor: CONFIG.colors.volcano,
        color: '#990000',
        weight: 2,
        opacity: 1,
        fillOpacity: 0.7
      });
      
      marker.bindPopup(`
        <div style="font-family: sans-serif;">
          <b style="color: ${CONFIG.colors.volcano}; font-size: 14px;">üåã ${v.name}</b><br>
          <span style="font-size: 12px;">${v.country}</span><br>
          <b style="font-size: 11px;">√öltima actividad:</b> ${formattedDate}<br>
          <span style="font-size: 11px; color: #666;">${status}</span>
        </div>
      `);
      
      volcanesLayer.addLayer(marker);
    });

    // ============================================
    // TERREMOTOS RECIENTES (USGS)
    // ============================================
    const earthquakesLayer = L.layerGroup().addTo(map);
    let previousEarthquakeIds = new Set(); // Para detectar terremotos nuevos
    const pulseCircles = []; // Almacenar c√≠rculos pulsantes
    let cachedEarthquakeData = null; // Cache para evitar perder datos si falla el fetch

    async function loadEarthquakes() {
      try {
        // Cargar m√∫ltiples feeds para tener datos m√°s completos y actuales
        const feeds = [
          'https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_hour.geojson',   // √öltima hora
          'https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/all_day.geojson',    // √öltimas 24h
          'https://earthquake.usgs.gov/earthquakes/feed/v1.0/summary/2.5_week.geojson'    // Semana (M2.5+)
        ];
        
        // Cargar feeds en paralelo
        const responses = await Promise.allSettled(
          feeds.map(url => fetch(url).then(r => r.json()))
        );
        
        // Combinar todos los terremotos
        let allFeatures = [];
        responses.forEach((result, idx) => {
          if (result.status === 'fulfilled' && result.value?.features) {
            console.log(`‚úì Feed ${idx + 1}: ${result.value.features.length} terremotos`);
            allFeatures.push(...result.value.features);
          }
        });
        
        // Deduplicar por ID
        const seen = new Set();
        const uniqueFeatures = allFeatures.filter(quake => {
          const id = quake.properties.id || quake.properties.code;
          if (seen.has(id)) return false;
          seen.add(id);
          return true;
        });
        
        console.log(`üìä Total terremotos √∫nicos: ${uniqueFeatures.length}`);
        
        const data = { features: uniqueFeatures };
        if (!data || !data.features) throw new Error('Datos de terremotos inv√°lidos');

        // Detectar terremotos nuevos
        const currentEarthquakeIds = new Set();
        const newEarthquakes = [];
        
        // Limpiar c√≠rculos pulsantes y capa SOLO si tenemos datos v√°lidos
        pulseCircles.forEach(({ circle, interval }) => {
          clearInterval(interval);
          if (earthquakesLayer.hasLayer(circle)) {
            earthquakesLayer.removeLayer(circle);
          }
        });
        pulseCircles.length = 0;

        earthquakesLayer.clearLayers();

        data.features.forEach(quake => {
          const coords = quake.geometry.coordinates;
          const props = quake.properties;
          const mag = props.mag || 0;
          const depth = coords[2] || 10; // Profundidad en km
          const quakeId = props.id || props.code;
          
          // Filtrar terremotos muy peque√±os
          if (mag < 2.5) return;
          
          // Guardar ID y detectar si es nuevo
          currentEarthquakeIds.add(quakeId);
          const isNew = previousEarthquakeIds.size > 0 && !previousEarthquakeIds.has(quakeId);
          if (isNew) {
            newEarthquakes.push({ coords, mag, quakeId });
          }
          
          // Calcular antig√ºedad del terremoto
          const now = Date.now();
          const quakeTime = props.time;
          const hoursAgo = (now - quakeTime) / (1000 * 60 * 60);
          const isVeryRecent = hoursAgo <= 24; // √öltimas 24 horas
          const isUltraRecent = hoursAgo <= 6; // √öltimas 6 horas
          
          // Radio del c√≠rculo exterior seg√∫n magnitud
          const outerRadius = 4 + mag * 1.5;
          
          // Radio del c√≠rculo interior seg√∫n profundidad
          // Terremotos superficiales (< 70km) = c√≠rculo grande
          // Terremotos profundos (> 300km) = c√≠rculo peque√±o
          const depthRatio = Math.max(0.2, Math.min(1, 1 - (depth / 400)));
          const innerRadius = outerRadius * depthRatio * 0.7;
          
          // Color del c√≠rculo interior m√°s oscuro
          const innerColor = depth < 70 ? '#cc9900' : 
                            depth < 150 ? '#996600' : 
                            '#663300';
          
          // Determinar clase de animaci√≥n seg√∫n antig√ºedad y magnitud
          let animationClass = '';
          if (isUltraRecent) {
            // √öltimas 6 horas - animaci√≥n seg√∫n magnitud
            if (mag >= 6.0) animationClass = 'quake-very-recent-strong';
            else if (mag >= 4.5) animationClass = 'quake-very-recent-medium';
            else animationClass = 'quake-very-recent-weak';
          } else if (isVeryRecent) {
            // 6-24 horas - animaci√≥n suave
            animationClass = 'quake-recent';
          }
          // > 24h - sin animaci√≥n (est√°tico)
          
          // C√≠rculo exterior (magnitud)
          const outerCircle = L.circleMarker([coords[1], coords[0]], {
            radius: outerRadius,
            fillColor: CONFIG.colors.earthquake,
            color: isVeryRecent ? '#ffaa00' : '#ff8800',
            weight: isVeryRecent ? 2.5 : 2,
            opacity: isVeryRecent ? 1 : 0.7,
            fillOpacity: isVeryRecent ? 0.7 : 0.5,
            className: animationClass
          });
          
          // C√≠rculo interior (profundidad)
          const innerCircle = L.circleMarker([coords[1], coords[0]], {
            radius: innerRadius,
            fillColor: innerColor,
            color: innerColor,
            weight: 0,
            opacity: 1,
            fillOpacity: 0.8
          });
          
          const fecha = new Date(props.time).toLocaleString('es-ES');
          const hoursAgoText = hoursAgo < 1 ? 
            `hace ${Math.floor(hoursAgo * 60)} minutos` : 
            `hace ${Math.floor(hoursAgo)} horas`;
          
          // Indicador visual de antig√ºedad
          let timeIndicator = '';
          if (isUltraRecent) {
            timeIndicator = 'üî¥ <b style="color: #ff4444;">MUY RECIENTE</b> ';
          } else if (isVeryRecent) {
            timeIndicator = 'üü° <b style="color: #ffaa00;">RECIENTE</b> ';
          }
          
          const popup = `
            <div style="font-family: sans-serif;">
              <b style="color: ${CONFIG.colors.earthquake}; font-size: 14px;">üåç Terremoto</b><br>
              ${timeIndicator}${hoursAgoText}<br>
              <b>Magnitud:</b> ${mag.toFixed(1)}<br>
              <b>Profundidad:</b> ${depth.toFixed(1)} km ${depth < 70 ? '(superficial)' : depth < 300 ? '(intermedio)' : '(profundo)'}<br>
              <b>Fecha:</b> ${fecha}<br>
              <b>Lugar:</b> ${props.place || 'Desconocido'}
            </div>
          `;
          
          outerCircle.bindPopup(popup);
          innerCircle.bindPopup(popup);
          
          earthquakesLayer.addLayer(outerCircle);
          earthquakesLayer.addLayer(innerCircle);
          
          // Si es un terremoto NUEVO, a√±adir c√≠rculo pulsante
          if (isNew) {
            createPulsingCircle([coords[1], coords[0]], outerRadius, mag);
          }
        });
        
        // Actualizar lista de IDs conocidos y cache
        previousEarthquakeIds = currentEarthquakeIds;
        cachedEarthquakeData = data;
        
        // Contar terremotos recientes (√∫ltimas 24h)
        const now = Date.now();
        const oneDayAgo = now - (24 * 60 * 60 * 1000);
        const recentCount = data.features.filter(q => q.properties.time >= oneDayAgo).length;
        
        // Actualizar contadores
        document.getElementById('earthquakeCount').textContent = `Terremotos: ${data.features.length}`;
        if (document.getElementById('recentQuakes')) {
          document.getElementById('recentQuakes').textContent = `√öltimas 24h: ${recentCount} (pulsantes)`;
        }
        document.getElementById('updateTime').textContent = `√öltima actualizaci√≥n: ${new Date().toLocaleTimeString('es-ES')}`;
        
        if (newEarthquakes.length > 0) {
          console.log(`‚úì ${data.features.length} terremotos cargados (${recentCount} recientes, ${newEarthquakes.length} NUEVOS)`);
        } else {
          console.log(`‚úì ${data.features.length} terremotos cargados (${recentCount} en √∫ltimas 24h)`);
        }
        
      } catch (error) {
        console.error('Error cargando terremotos (manteniendo datos previos si existen):', error);
        if (cachedEarthquakeData) {
          console.warn('Usando datos cacheados de terremotos; mapa se mantiene intacto.');
          // No hacemos nada: mantenemos en pantalla los datos ya renderizados
        } else {
          console.warn('No hay datos cacheados de terremotos disponibles.');
        }
      }
    }
    
    // Crear c√≠rculo pulsante para terremotos nuevos
    function createPulsingCircle(latlng, baseRadius, magnitude) {
      const pulseCircle = L.circle(latlng, {
        radius: baseRadius * 1000, // Convertir a metros para L.circle
        fillColor: CONFIG.colors.earthquake,
        color: CONFIG.colors.earthquake,
        weight: 2,
        opacity: 0.7,
        fillOpacity: 0.1,
        interactive: false
      }).addTo(earthquakesLayer);
      
      // Animaci√≥n con setInterval
      let growing = true;
      let currentScale = 1;
      const maxScale = 3;
      const minScale = 1;
      const step = 0.05;
      
      const pulseInterval = setInterval(() => {
        if (growing) {
          currentScale += step;
          if (currentScale >= maxScale) {
            growing = false;
          }
        } else {
          currentScale -= step;
          if (currentScale <= minScale) {
            growing = true;
          }
        }
        
        pulseCircle.setRadius(baseRadius * 1000 * currentScale);
        pulseCircle.setStyle({
          opacity: 0.7 / currentScale,
          fillOpacity: 0.15 / currentScale
        });
      }, 50);
      
      // Guardar para poder limpiar despu√©s
      pulseCircles.push({ circle: pulseCircle, interval: pulseInterval });
      
      // Detener animaci√≥n despu√©s de la pr√≥xima actualizaci√≥n (5 minutos)
      setTimeout(() => {
        clearInterval(pulseInterval);
        if (earthquakesLayer.hasLayer(pulseCircle)) {
          earthquakesLayer.removeLayer(pulseCircle);
        }
        // Remover de la lista
        const index = pulseCircles.findIndex(p => p.circle === pulseCircle);
        if (index > -1) pulseCircles.splice(index, 1);
      }, 300000); // 5 minutos
    }

    // ============================================
    // INFO PANEL
    // ============================================
    function updateInfoPanel(date) {
      const clock = document.getElementById('clock');
      const sunStatus = document.getElementById('sun-status');

      // Si no existen los elementos (panel oculto), salir sin romper el resto del mapa
      if (!clock || !sunStatus) return;
      
      clock.textContent = `üïê ${date.toLocaleTimeString('es-ES')}`;
      
      // Calcular posici√≥n del sol en Madrid como referencia
      const madridSun = SunCalc.getPosition(date, 40.4168, -3.7038);
      const altitude = madridSun.altitude * 180 / Math.PI;
      
      if (altitude > 0) {
        sunStatus.textContent = `‚òÄÔ∏è D√≠a en Madrid`;
      } else {
        sunStatus.textContent = `üåô Noche en Madrid`;
      }
    }

    // ============================================
    // ACTUALIZACI√ìN AUTOM√ÅTICA
    // ============================================
    
    // Actualizar sombra nocturna cada minuto
    setInterval(calculateNightShadow, 60000);
    
    // Actualizar terremotos cada 5 minutos
    setInterval(loadEarthquakes, 300000);
    
    // Actualizar reloj cada segundo
    setInterval(() => updateInfoPanel(new Date()), 1000);

    // ============================================
    // INICIALIZACI√ìN
    // ============================================
    map.whenReady(() => {
      console.log('üó∫Ô∏è Mapa inicializado');
      
      // Ajustar el mapa a la ventana al cargar
      adjustMapToWindow();
      setTimeout(adjustMapToWindow, 100);

      calculateNightShadow();
      loadEarthquakes();
      console.log('‚úì Datos en tiempo real cargados');
      console.log('üìê Zoom m√≠nimo din√°mico activado - Sin bordes negros');
    });

  </script>
</body>
</html>

