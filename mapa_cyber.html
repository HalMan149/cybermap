<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Mapa Cyberpunk + GPS p√∫blico</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    html, body {
      height: 100vh; width: 100vw; margin: 0; padding: 0; background: #0b1021;
      box-sizing: border-box;
    }
    #map {
      width: 100vw; height: 100vh; margin: 0; padding: 0; background: #0b1021;
      box-sizing: border-box;
    }
    .zona-horaria-label, .city-clock-label { pointer-events: none; user-select: none; }
    .gmt-utc-clock {
      font-family: 'Consolas', monospace; font-size: 1.25em;
      padding: 2px 12px; border-radius: 12px; border: 2.2px solid #00ffd9a0;
      background: #0a233bf2; color: #1fffb7; font-weight: 600;
      margin-top: 6px; margin-bottom: 0; text-align: center; width: 76px;
      box-shadow: 0 0 8px #0ff8; letter-spacing: 0.04em;
      text-shadow: 0 0 5px #0ff7; transition: color 0.2s, border 0.2s, background 0.2s;
      cursor: pointer;
    }
    .gmt-utc-clock.sync-error {
      color: #ffae47 !important;
      border-color: #ffc66a !important;
      background: #2d1c05ea !important;
      box-shadow: 0 0 18px #ffc66a77 !important;
    }
    .zona-horaria-label.gmt-central { font-weight: bold; }
    .city-clock-label {
      background: transparent !important; border: none !important; box-shadow: none !important; min-width: 0 !important; padding: 0 !important;
      font-family: 'Segoe UI', 'Roboto', sans-serif; color: #63faff;
      text-align: center;
      text-shadow: 0 0 8px #29eaffb8, 0 0 2px #09e7;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
    }
    .city-clock-label .hora {
      font-family: 'Consolas', monospace; font-size: 1.24em; color: #73fdff; font-weight: 800;
      margin-bottom: 0px; text-shadow: 0 0 13px #5efcff, 0 0 3px #33eaffb8; background: transparent; border: none; letter-spacing: 0.03em; line-height: 1.2;
    }
    .city-clock-label .city {
      font-size: 1em; color: #fff; font-weight: 600; margin-top: 0px; line-height: 1.08; background: transparent; border: none; text-shadow: 0 0 4px #00f8, 0 0 1px #0af9;
    }
    .leaflet-overlay-pane svg polyline {
      stroke: #2cfdff !important; filter: drop-shadow(0 0 6px #12fd) drop-shadow(0 0 2px #00f8); stroke-width: 2.3 !important; stroke-opacity: 0.65 !important;
    }
    #noticias-ticker {
      position: absolute; bottom: 0; left: 0; width: 100vw;
      z-index: 3000; background: rgba(8, 26, 31, 0.54); backdrop-filter: blur(2.5px);
      color: #6bf; font-family: 'Segoe UI', Arial, sans-serif; font-size: 1.13em;
      height: 33px; display: flex; align-items: center; overflow: hidden;
      border-top: 2px solid #13f5ff; box-shadow: 0 1px 7px #00f3;
      text-shadow: 0 0 8px #27fd;
    }
    #noticias-inner { white-space: nowrap; display: inline-block; will-change: transform; }

    /* Ocultar ticker en miniatura */
    body.preview #noticias-ticker { display: none; }

    /* Animaciones */
    @keyframes pulseGlow {
      0%, 100% { box-shadow: 0 0 12px rgba(19, 245, 255, 0.4); transform: scale(1); }
      50% { box-shadow: 0 0 25px rgba(19, 245, 255, 0.8); transform: scale(1.03); }
    }
    @keyframes resetPulse {
      0% { box-shadow: 0 0 0 0 rgba(19, 245, 255, 0.7); }
      70% { box-shadow: 0 0 0 15px rgba(19, 245, 255, 0); }
      100% { box-shadow: 0 0 0 0 rgba(19, 245, 255, 0); }
    }
    @keyframes slideIn {
      from { opacity: 0; transform: translateX(20px); }
      to { opacity: 1; transform: translateX(0); }
    }

    /* Leyenda */
    #legend {
      position: absolute; top: 15px; left: 15px; z-index: 2000;
      background: rgba(11, 16, 33, 0.45); backdrop-filter: blur(12px);
      border: 2px solid #13f5ff; border-radius: 12px; padding: 15px 18px;
      font-family: 'Segoe UI', sans-serif; color: #fff;
      box-shadow: 0 4px 15px rgba(0, 255, 255, 0.3); min-width: 220px;
    }
    #legend h3 {
      margin: 0 0 12px 0; font-size: 1.1em; color: #13f5ff;
      text-shadow: 0 0 8px #13f5ff; font-weight: 600;
    }
    .legend-item {
      display: flex; align-items: center; margin-bottom: 10px;
      cursor: pointer; transition: opacity 0.3s;
    }
    .legend-item:hover { opacity: 0.8; }
    .legend-item.disabled { opacity: 0.4; }
    .legend-color {
      width: 18px; height: 18px; border-radius: 50%;
      margin-right: 10px; border: 2px solid currentColor;
    }
    .legend-label { font-size: 0.95em; flex: 1; }
    .legend-count {
      font-size: 0.85em; color: #13f5ff; font-weight: 600; margin-left: 8px;
    }
    #heatmap-toggle, #reset-view {
      padding: 8px 12px; width: 100%;
      background: linear-gradient(135deg, #1a4d5e, #0d2838);
      border: 2px solid #13f5ff; border-radius: 8px;
      color: #fff; font-size: 0.9em; cursor: pointer;
      transition: all 0.3s; font-weight: 600;
      text-shadow: 0 0 5px #13f5ff; margin-top: 10px;
    }
    #heatmap-toggle:hover, #reset-view:hover {
      background: linear-gradient(135deg, #2a6d7e, #1d4858);
      animation: pulseGlow 1.5s ease-in-out infinite;
    }
    #heatmap-toggle.active {
      background: linear-gradient(135deg, #ff6b6b, #ee5a52);
      border-color: #ff6b6b; text-shadow: 0 0 5px #ff6b6b;
    }
    #reset-view.resetting { animation: resetPulse 1s ease-out; }

    /* Lista lateral de ataques */
    #recent-attacks {
      position: absolute; top: 15px; right: 15px; z-index: 2000;
      background: rgba(11, 16, 33, 0.45); backdrop-filter: blur(12px);
      border: 2px solid #ff6b6b; border-radius: 12px; padding: 15px;
      font-family: 'Segoe UI', sans-serif; color: #fff;
      box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
      width: 320px; max-height: 500px; overflow-y: auto;
    }
    #recent-attacks h3 {
      margin: 0 0 12px 0; font-size: 1.1em; color: #ff6b6b;
      text-shadow: 0 0 8px #ff6b6b; font-weight: 600;
    }
    .attack-item {
      background: rgba(255, 107, 107, 0.08);
      border-left: 3px solid #ff6b6b;
      padding: 10px; margin-bottom: 8px; border-radius: 6px;
      font-size: 0.85em; cursor: pointer;
      transition: all 0.3s; animation: slideIn 0.4s ease-out;
    }
    .attack-item:hover {
      background: rgba(255, 107, 107, 0.15); transform: translateX(-3px);
    }
    .attack-item.ransomware {
      border-left-color: #ffa500; background: rgba(255, 165, 0, 0.08);
    }
    .attack-item.ransomware:hover { background: rgba(255, 165, 0, 0.15); }
    .attack-item.urlhaus {
      border-left-color: #ba68c8; background: rgba(186, 104, 200, 0.08);
    }
    .attack-item.urlhaus:hover { background: rgba(186, 104, 200, 0.15); }
    .attack-type {
      font-weight: 600; color: #ff6b6b; font-size: 0.9em; margin-bottom: 4px;
    }
    .attack-item.ransomware .attack-type { color: #ffa500; }
    .attack-item.urlhaus .attack-type { color: #ba68c8; }
    .attack-details { color: #ccc; line-height: 1.5; }
    .attack-time {
      font-size: 0.8em; color: #13f5ff; margin-top: 4px;
      font-family: 'Consolas', monospace;
    }
    #recent-attacks::-webkit-scrollbar { width: 6px; }
    #recent-attacks::-webkit-scrollbar-track { background: rgba(0,0,0,0.3); }
    #recent-attacks::-webkit-scrollbar-thumb {
      background: #ff6b6b; border-radius: 3px;
    }

    /* Ocultar paneles en preview */
    body.preview #legend, body.preview #recent-attacks { display: none; }
  </style>
</head>
<body class="">
  <div id="map"></div>
  
  <!-- Leyenda -->
  <div id="legend">
    <h3>üó∫Ô∏è Capas del Mapa</h3>
    <div class="legend-item" id="legend-ips" data-layer="ips">
      <div class="legend-color" style="background: #ff4757;"></div>
      <span class="legend-label">IPs Maliciosas</span>
      <span class="legend-count" id="count-ips">0</span>
    </div>
    <div class="legend-item" id="legend-ransomware" data-layer="ransomware">
      <div class="legend-color" style="background: #ffa500;"></div>
      <span class="legend-label">V√≠ctimas Ransomware</span>
      <span class="legend-count" id="count-ransomware">0</span>
    </div>
    <div class="legend-item" id="legend-urlhaus" data-layer="urlhaus">
      <div class="legend-color" style="background: #ba68c8;"></div>
      <span class="legend-label">Botnets C&C</span>
      <span class="legend-count" id="count-urlhaus">0</span>
    </div>
    <button id="heatmap-toggle">üî• Modo Mapa de Calor</button>
    <button id="reset-view">üéØ Restablecer Vista</button>
  </div>

  <!-- Lista de ataques recientes -->
  <div id="recent-attacks">
    <h3>‚ö° Ataques Recientes</h3>
    <div id="attacks-list"></div>
  </div>

  <div id="noticias-ticker"><span id="noticias-inner"></span></div>
  
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>
  <script>
    const urlParams = new URLSearchParams(window.location.search);
    const isPreview = urlParams.has('preview');
    if (isPreview) {
      document.body.classList.add('preview');
    }

    const CENTER = [38.3373, -0.5266];
    const ZOOM = 3;
    // Para la miniatura: m√°s abierto y centrado en el mundo
    // Preview: usaremos fitBounds para recortar polos en la miniatura
    const baseZoom = ZOOM;
    const minZoom = isPreview ? 1.0 : ZOOM;

    const map = L.map('map', {
      zoomControl: true,
      attributionControl: false,
      minZoom,
      maxZoom: 17,
      scrollWheelZoom: true,
      doubleClickZoom: false,
      boxZoom: true,
      dragging: true,
      touchZoom: true,
      keyboard: true,
      worldCopyJump: false,
      noWrap: true,
      maxBounds: [[-61, -180], [84, 180]],
      maxBoundsViscosity: 1.0,
      preferCanvas: true
    });

    // Guardar vista inicial
    let initialView = { center: CENTER, zoom: baseZoom };

    if (isPreview) {
      // Recorte: m√°s sur (Sudam√©rica completa) y un poco menos de norte
      const previewBounds = [[-65, -180], [68, 180]];
      map.fitBounds(previewBounds, { animate: false });
      map.setMaxBounds(previewBounds);
    } else {
      map.setView(CENTER, baseZoom);
    }

    // Funci√≥n para restablecer vista con animaci√≥n
    function resetMapView() {
      const btn = document.getElementById('reset-view');
      btn.classList.add('resetting');
      
      map.setView(initialView.center, initialView.zoom, { 
        animate: true,
        duration: 1.0
      });

      setTimeout(() => {
        btn.classList.remove('resetting');
      }, 1000);
    }

    // Doble clic en el mapa para restablecer vista
    map.on('dblclick', function(e) {
      resetMapView();
    });

    // --- Mapa base oscuro fijo, SIN repetir
    L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
      maxZoom: 19, minZoom: 1, noWrap: true
    }).addTo(map);

    // --- Capa de l√≠neas GPS p√∫blicas, SIN repetir
    L.tileLayer('https://gps-{s}.tile.openstreetmap.org/lines/{z}/{x}/{y}.png', {
      maxZoom: 19, minZoom: 1, opacity: 0.85, noWrap: true
    }).addTo(map);

    // --- ZONAS HORARIAS Y RELOJES ---
    const zonaHorariaLines = L.layerGroup();
    const relojMarkers = [];
    let utcRef = new Date(); // base inicial, se ajusta con reloj at√≥mico
    let utcError = false;

    for(let i = -12; i <= 14; i++) {
      const lon = i * 15;
      if (lon < -180 || lon > 180) continue;
      const isCentral = (i === 0);
      const line = L.polyline([[-59.98, lon], [82.26, lon]],
        { color: "#2cfdff", weight: 2.3, opacity: 0.65, dashArray: "5,14", interactive: false });
      zonaHorariaLines.addLayer(line);
      const latLabel = 82.15;
      const relojId = `reloj-tz${i}`;
      const extraClass = isCentral ? " gmt-central" : "";
      const ancla = isCentral ? [52, 10] : [31, 10];
      const marker = L.marker([latLabel, lon], {
        icon: L.divIcon({
          className: 'zona-horaria-label' + extraClass,
          html: isCentral
            ? `<div class="gmt-utc-clock" id="${relojId}">--:--</div>`
            : `<div id="${relojId}" style="font-family:monospace;font-size:1.18em;color:#72fdff;background:transparent;padding:0;border:none;min-width:62px;text-align:center;box-shadow:none"></div>`,
          iconAnchor: ancla
        }),
        interactive: false
      });
      relojMarkers.push({ id: relojId, offset: i });
      zonaHorariaLines.addLayer(marker);
    }
    zonaHorariaLines.addTo(map);

    // --- RELOJES DE CIUDADES (zona horaria real para DST autom√°tico) ---
    const cityMarkers = [
      { name: "Los √Ångeles", lat:34.05, lon:-118.25, tz: "America/Los_Angeles", id:"clkla" },
      { name: "Denver", lat:39.74, lon:-104.99, tz: "America/Denver", id:"clkden" },
      { name: "M√©xico", lat:19.43, lon:-99.13, tz: "America/Mexico_City", id:"clkcdmx" },
      { name: "Nueva York", lat:40.71, lon:-74.01, tz: "America/New_York", id:"clkny" },
      { name: "Buenos Aires", lat:-34.61, lon:-58.38, tz: "America/Argentina/Buenos_Aires", id:"clkbue" },
      { name: "Sao Paulo", lat:-23.55, lon:-46.63, tz: "America/Sao_Paulo", id:"clksp" },
      { name: "Londres", lat:51.51, lon:-0.13, tz: "Europe/London", id:"clklon" },
      { name: "Madrid", lat:40.42, lon:-3.70, tz: "Europe/Madrid", id:"clkmad" },
      { name: "El Cairo", lat:30.05, lon:31.25, tz: "Africa/Cairo", id:"clkcai" },
      { name: "Mosc√∫", lat:55.75, lon:37.62, tz: "Europe/Moscow", id:"clkmsk" },
      { name: "Dub√°i", lat:25.20, lon:55.27, tz: "Asia/Dubai", id:"clkdx" },
      { name: "Nueva Delhi", lat:28.61, lon:77.20, tz: "Asia/Kolkata", id:"clkdel" },
      { name: "Pek√≠n", lat:39.90, lon:116.40, tz: "Asia/Shanghai", id:"clkpek" },
      { name: "Tokio", lat:35.68, lon:139.69, tz: "Asia/Tokyo", id:"clktok" },
      { name: "S√≠dney", lat:-33.87, lon:151.21, tz: "Australia/Sydney", id:"clksyd" },
      { name: "Perth", lat:-31.95, lon:115.86, tz: "Australia/Perth", id:"clkper" }
    ];
    cityMarkers.forEach(city => {
      L.marker([city.lat, city.lon], {
        icon: L.divIcon({
          className: "city-clock-label",
          html: `<span class="hora" id="${city.id}-hora">--:--</span>
                 <span class="city">${city.name}</span>`,
          iconAnchor: [11, 10]
        }),
        interactive: false
      }).addTo(map);
    });

    function formatTimeInTZ(tz, ts) {
      return new Intl.DateTimeFormat('es-ES', {
        hour: '2-digit',
        minute: '2-digit',
        hourCycle: 'h23',
        timeZone: tz
      }).format(ts);
    }

    function updateCentralUTCAndRelojes() {
      const nowBase = utcRef instanceof Date ? utcRef : new Date();
      const nowTs = nowBase.getTime();
      const centralClock = document.getElementById('reloj-tz0');
      if (centralClock) {
        const h = String(nowBase.getUTCHours()).padStart(2,"0");
        const m = String(nowBase.getUTCMinutes()).padStart(2,"0");
        centralClock.textContent = `${h}:${m}`;
        centralClock.title = utcError ? "UTC (fallback local)" : "Hora GMT/UTC at√≥mica";
      }
      relojMarkers.forEach(({id, offset}) => {
        if (id === 'reloj-tz0') return;
        const el = document.getElementById(id);
        if (!el) return;
        const t = new Date(nowTs + offset * 60 * 60 * 1000);
        const hh = String(t.getUTCHours()).padStart(2, "0");
        const mm = String(t.getUTCMinutes()).padStart(2, "0");
        el.textContent = `${hh}:${mm}`;
      });
      cityMarkers.forEach(city => {
        const el = document.getElementById(city.id + "-hora");
        if (!el) return;
        el.textContent = formatTimeInTZ(city.tz, nowTs);
      });
    }

    // Sincronizaci√≥n UTC at√≥mica + fallback
    async function syncUTCAtomic() {
      try {
        const resp = await fetch('https://timeapi.io/api/Time/current/zone?timeZone=UTC', { cache: 'no-store' });
        const data = await resp.json();
        utcRef = new Date(data.dateTime);
        utcError = false;
      } catch(e) {
        utcRef = new Date();
        utcError = true;
      }
      updateCentralUTCAndRelojes();
    }

    // Primera actualizaci√≥n inmediata
    updateCentralUTCAndRelojes();
    syncUTCAtomic();
    setInterval(syncUTCAtomic, 5 * 60 * 1000); // cada 5 min
    setInterval(updateCentralUTCAndRelojes, 60000); // cada 1 min (usa utcRef vigente)
    // --- CAPA DE EVENTOS (IP maliciosas desde funci√≥n serverless)
    const attacksLayer = L.layerGroup().addTo(map);
    const ransomwareLayer = L.layerGroup().addTo(map);
    const urlhausLayer = L.layerGroup().addTo(map);
    let heatmapLayers = [];
    const previousIps = new Set();
    const previousRansomware = new Set();
    const previousUrlhaus = new Set();
    const pulseRefs = [];
    const recentAttacksList = [];
    let layersVisible = { ips: true, ransomware: true, urlhaus: true };
    let heatmapMode = false;
    const DEMO_EVENTS = [
      { ip: 'demo-1', lat: 40.71, lon: -74.01, country: 'US' },
      { ip: 'demo-2', lat: 51.50, lon: -0.12, country: 'UK' },
      { ip: 'demo-3', lat: 35.68, lon: 139.69, country: 'JP' },
      { ip: 'demo-4', lat: 19.43, lon: -99.13, country: 'MX' }
    ];
    const FIREHOL_URLS = [
      'https://raw.githubusercontent.com/firehol/blocklist-ipsets/master/firehol_level1.netset',
      'https://cdn.jsdelivr.net/gh/firehol/blocklist-ipsets@master/firehol_level1.netset',
      'https://raw.githack.com/firehol/blocklist-ipsets/master/firehol_level1.netset'
    ];
    const MAX_FIREHOL_IPS = 120;
    const GEO_ENDPOINT = (ip) => `https://ipwho.is/${ip}`;
    const CACHE_KEY = 'cyber_attacks_cache';
    const RANSOMWARE_CACHE_KEY = 'ransomware_victims_cache';
    const URLHAUS_CACHE_KEY = 'feodo_botnets_cache';
    const CACHE_MS = 6 * 60 * 60 * 1000; // 6h
    const RANSOMWARE_API = 'https://api.ransomware.live/recentvictims';
    const FEODO_TRACKER_API = 'https://feodotracker.abuse.ch/downloads/ipblocklist.json';
    let lastEvents = [];
    let lastRansomwareVictims = [];
    let lastUrlhausUrls = [];
    
    // Intentar recuperar cache de sesiones previas (IPs maliciosas)
    try {
      const stored = localStorage.getItem(CACHE_KEY);
      if (stored) {
        const parsed = JSON.parse(stored);
        if (parsed && parsed.ts && (Date.now() - parsed.ts) < CACHE_MS && Array.isArray(parsed.data) && parsed.data.length) {
          lastEvents = parsed.data;
          console.log(`‚Ü∫ Cache cyber: ${parsed.data.length} eventos (<=6h)`);
        }
      }
    } catch(_) {}
    
    // Intentar recuperar cache de ransomware
    try {
      const stored = localStorage.getItem(RANSOMWARE_CACHE_KEY);
      if (stored) {
        const parsed = JSON.parse(stored);
        if (parsed && parsed.ts && (Date.now() - parsed.ts) < CACHE_MS && Array.isArray(parsed.data) && parsed.data.length) {
          lastRansomwareVictims = parsed.data;
          console.log(`‚Ü∫ Cache ransomware: ${parsed.data.length} v√≠ctimas (<=6h)`);
        }
      }
    } catch(_) {}

    // Intentar recuperar cache de Feodo/Botnets
    try {
      const stored = localStorage.getItem(URLHAUS_CACHE_KEY);
      if (stored) {
        const parsed = JSON.parse(stored);
        if (parsed && parsed.ts && (Date.now() - parsed.ts) < CACHE_MS && Array.isArray(parsed.data) && parsed.data.length) {
          lastUrlhausUrls = parsed.data;
          console.log(`‚Ü∫ Cache Feodo: ${parsed.data.length} botnets (<=6h)`);
        }
      }
    } catch(_) {}

    function createPulse(lat, lon, color = '#d32f2f', layer = attacksLayer) {
      const baseRadius = 70000;
      const circle = L.circle([lat, lon], {
        radius: baseRadius,
        color: color,
        weight: 2,
        opacity: 0.8,
        fillOpacity: 0.15,
        interactive: false
      }).addTo(layer);

      let growing = true;
      let scale = 1;
      const maxScale = 3;
      const minScale = 1;
      const step = 0.05;

      const interval = setInterval(() => {
        scale += growing ? step : -step;
        if (scale >= maxScale) growing = false;
        if (scale <= minScale) growing = true;
        circle.setRadius(baseRadius * scale);
        circle.setStyle({ opacity: 0.8 / scale, fillOpacity: 0.2 / scale });
      }, 50);

      setTimeout(() => {
        clearInterval(interval);
        if (layer.hasLayer(circle)) layer.removeLayer(circle);
      }, 15000); // 15s de pulso

      pulseRefs.push({ circle, interval });
    }

    function filterAttacks(events) {
      const ipSeen = new Set();
      const cellSeen = new Set(); // celda aproximada para evitar clusters densos
      const filtered = [];
      for (const ev of events || []) {
        if (typeof ev.lat !== 'number' || typeof ev.lon !== 'number') continue;
        if (!ev.ip) continue;
        if (ipSeen.has(ev.ip)) continue;
        ipSeen.add(ev.ip);
        const cell = `${Math.round(ev.lat * 2) / 2}_${Math.round(ev.lon * 2) / 2}`; // cuadr√≠cula 0.5¬∞
        if (cellSeen.has(cell)) continue;
        cellSeen.add(cell);
        filtered.push(ev);
        if (filtered.length >= 200) break; // l√≠mite duro
      }
      return filtered;
    }

    function renderAttacks(events, { forcePulse = false } = {}) {
      if (!Array.isArray(events) || !events.length) return;
      console.log(`‚ñ∂ Pintando ${events.length} eventos cyber`);
      attacksLayer.clearLayers();
      // limpiar pulsos previos
      pulseRefs.forEach(({ interval }) => clearInterval(interval));
      pulseRefs.length = 0;

      events.forEach(ev => {
        const circle = L.circleMarker([ev.lat, ev.lon], {
          radius: 9,
          color: '#d32f2f',
          fillColor: '#ff6b6b',
          fillOpacity: 0.6,
          weight: 2.5,
          opacity: 0.9
        }).addTo(attacksLayer);
        circle.bindPopup(
          `IP en lista negra: ${ev.ip}<br>` +
          `Pa√≠s: ${ev.country || 'N/D'}`
        );

        const isNew = forcePulse || !previousIps.has(ev.ip);
        if (isNew) {
          createPulse(ev.lat, ev.lon);
          addToRecentAttacks('ip', ev);
        }
        // marcar como vista
        previousIps.add(ev.ip);
      });

      updateCounters();
      if (heatmapMode) updateHeatmap();
    }

    function delay(ms) { return new Promise(res => setTimeout(res, ms)); }

    async function fetchFireholIPs() {
      let lastError = null;
      for (const url of FIREHOL_URLS) {
        try {
          const res = await fetch(url, { cache: 'no-store' });
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const txt = await res.text();
          const ips = txt
            .split('\n')
            .map(l => l.trim())
            .filter(l => l && !l.startsWith('#'))
            .map(l => {
              const mCidr = l.match(/^(\d+\.\d+\.\d+\.\d+)\/\d+/);
              const mIp = l.match(/^(\d+\.\d+\.\d+\.\d+)$/);
              return mCidr ? mCidr[1] : (mIp ? mIp[1] : null);
            })
            .filter(Boolean);
          const uniq = Array.from(new Set(ips)).slice(0, MAX_FIREHOL_IPS);
          console.log(`FireHOL desde ${url} -> ${uniq.length} IPs`);
          if (uniq.length > 0) return uniq;
        } catch (e) {
          lastError = e;
          console.warn(`FireHOL fallo ${url}`, e);
        }
      }
      if (lastError) throw lastError;
      return [];
    }

    async function geolocateIPs(ips) {
      const results = [];
      for (const ip of ips) {
        try {
          const geo = await fetch(GEO_ENDPOINT(ip), { cache: 'no-store' }).then(r => r.json());
          if (geo && geo.success && typeof geo.latitude === 'number' && typeof geo.longitude === 'number') {
            results.push({ ip, lat: geo.latitude, lon: geo.longitude, country: geo.country });
          }
        } catch (_) {}
        await delay(180); // throttle para no quemar la API
      }
      console.log(`Geolocalizadas ${results.length} / ${ips.length} IPs`);
      return results;
    }

    // --- FUNCIONES DE UI (CONTADORES, LISTA, TOGGLE) ---
    function updateCounters() {
      document.getElementById('count-ips').textContent = lastEvents.length;
      document.getElementById('count-ransomware').textContent = lastRansomwareVictims.length;
      document.getElementById('count-urlhaus').textContent = lastUrlhausUrls.length;
    }

    function addToRecentAttacks(type, data) {
      const timestamp = new Date();
      const attack = { type, data, timestamp };
      recentAttacksList.unshift(attack);
      if (recentAttacksList.length > 50) recentAttacksList.pop();
      updateAttacksList();
    }

    function updateAttacksList() {
      const container = document.getElementById('attacks-list');
      const toShow = recentAttacksList.slice(0, 20);
      
      if (toShow.length === 0) {
        container.innerHTML = '<div style="color:#888;font-size:0.9em;text-align:center;padding:20px;">Sin ataques recientes</div>';
        return;
      }

      container.innerHTML = toShow.map(attack => {
        const isRansomware = attack.type === 'ransomware';
        const isUrlhaus = attack.type === 'urlhaus';
        let className = 'attack-item';
        if (isRansomware) className = 'attack-item ransomware';
        if (isUrlhaus) className = 'attack-item urlhaus';
        
        let details = '';
        if (isRansomware) {
          details = `
            <div class="attack-type">üîí RANSOMWARE</div>
            <div class="attack-details">
              <strong>${attack.data.name}</strong><br>
              Grupo: ${attack.data.group}<br>
              Pa√≠s: ${attack.data.country}
            </div>
          `;
        } else if (isUrlhaus) {
          details = `
            <div class="attack-type">ü§ñ BOTNET C&C</div>
            <div class="attack-details">
              <strong>${attack.data.threat || 'Botnet'}</strong><br>
              IP: ${attack.data.host || 'N/D'}<br>
              Pa√≠s: ${attack.data.country || 'Desconocido'}
            </div>
          `;
        } else {
          details = `
            <div class="attack-type">üö® IP MALICIOSA</div>
            <div class="attack-details">
              IP: ${attack.data.ip}<br>
              Pa√≠s: ${attack.data.country || 'Desconocido'}
            </div>
          `;
        }
        
        const timeAgo = getTimeAgo(attack.timestamp);
        return `
          <div class="${className}" data-lat="${attack.data.lat}" data-lon="${attack.data.lon}">
            ${details}
            <div class="attack-time">${timeAgo}</div>
          </div>
        `;
      }).join('');

      // Agregar click handlers
      container.querySelectorAll('.attack-item').forEach(item => {
        item.addEventListener('click', () => {
          const lat = parseFloat(item.dataset.lat);
          const lon = parseFloat(item.dataset.lon);
          map.setView([lat, lon], 6, { animate: true });
        });
      });
    }

    function getTimeAgo(date) {
      const seconds = Math.floor((new Date() - date) / 1000);
      if (seconds < 60) return 'Hace unos segundos';
      if (seconds < 3600) return `Hace ${Math.floor(seconds / 60)} min`;
      if (seconds < 86400) return `Hace ${Math.floor(seconds / 3600)} h`;
      return `Hace ${Math.floor(seconds / 86400)} d√≠as`;
    }

    async function loadAttacks() {
      // Mostrar inmediatamente cache previa si existe
      if (lastEvents.length) {
        renderAttacks(lastEvents, { forcePulse: true });
      }

      let fetched = [];
      try {
        const ips = await fetchFireholIPs();
        const geos = await geolocateIPs(ips);
        fetched = filterAttacks(geos);
      } catch (e) {
        console.warn('No se pudieron cargar/geolocalizar IPs FireHOL', e);
      }

      if (fetched.length > 0) {
        lastEvents = fetched;
        try { localStorage.setItem(CACHE_KEY, JSON.stringify({ ts: Date.now(), data: fetched })); } catch(_) {}
        renderAttacks(fetched, { forcePulse: false });
        console.log(`‚úì Cyber eventos cargados (FireHOL+geo): ${fetched.length}`);
        return;
      }

      if (lastEvents.length) {
        console.warn('Eventos vac√≠os, reutilizando √∫ltimo dataset en cache');
        renderAttacks(lastEvents, { forcePulse: false });
        return;
      }

      console.warn('Sin datos (FireHOL+cache vac√≠os). No se muestran eventos.');
    }

    loadAttacks();
    setInterval(loadAttacks, 5 * 60 * 1000); // cada 5 min

    // --- CAPA DE RANSOMWARE (v√≠ctimas recientes desde Ransomware.live)
    const COUNTRY_COORDS = {
      'US': [37.09, -95.71], 'CA': [56.13, -106.34], 'MX': [23.63, -102.55],
      'BR': [-14.23, -51.92], 'AR': [-38.41, -63.61], 'CL': [-35.67, -71.54],
      'GB': [55.37, -3.43], 'FR': [46.22, 2.21], 'DE': [51.16, 10.45], 'IT': [41.87, 12.56],
      'ES': [40.46, -3.74], 'NL': [52.13, 5.29], 'BE': [50.50, 4.47], 'CH': [46.81, 8.22],
      'SE': [60.12, 18.64], 'NO': [60.47, 8.46], 'DK': [56.26, 9.50], 'FI': [61.92, 25.74],
      'PL': [51.91, 19.14], 'RU': [61.52, 105.31], 'UA': [48.37, 31.16], 'TR': [38.96, 35.24],
      'IN': [20.59, 78.96], 'CN': [35.86, 104.19], 'JP': [36.20, 138.25], 'KR': [35.90, 127.76],
      'AU': [-25.27, 133.77], 'NZ': [-40.90, 174.88], 'ZA': [-30.55, 22.93], 'EG': [26.82, 30.80],
      'IL': [31.04, 34.85], 'SA': [23.88, 45.07], 'AE': [23.42, 53.84], 'SG': [1.35, 103.81],
      'TH': [15.87, 100.99], 'VN': [14.05, 108.27], 'PH': [12.87, 121.77], 'ID': [-0.78, 113.92],
      'MY': [4.21, 101.97], 'CO': [4.57, -74.29], 'PE': [-9.18, -75.01], 'VE': [6.42, -66.58],
      'AT': [47.51, 14.55], 'CZ': [49.81, 15.47], 'PT': [39.39, -8.22], 'GR': [39.07, 21.82],
      'RO': [45.94, 24.96], 'HU': [47.16, 19.50], 'IE': [53.41, -8.24], 'HR': [45.10, 15.20],
      'RS': [44.01, 21.00], 'BG': [42.73, 25.48], 'SK': [48.66, 19.69], 'LT': [55.16, 23.88],
      'LV': [56.87, 24.60], 'EE': [58.59, 25.01], 'SI': [46.15, 14.99], 'LU': [49.81, 6.12]
    };

    async function loadRansomwareVictims() {
      // Mostrar cache inmediatamente si existe
      if (lastRansomwareVictims.length) {
        renderRansomwareVictims(lastRansomwareVictims, { forcePulse: true });
      }

      try {
        // Usar proxy CORS para evitar bloqueos desde file://
        const proxies = [
          `https://api.allorigins.win/raw?url=${encodeURIComponent(RANSOMWARE_API)}`,
          `https://corsproxy.io/?${encodeURIComponent(RANSOMWARE_API)}`,
          RANSOMWARE_API // Intentar directo como √∫ltimo recurso
        ];
        
        let response = null;
        let lastError = null;
        
        for (const proxyUrl of proxies) {
          try {
            response = await fetch(proxyUrl, { cache: 'no-store' });
            if (response.ok) break;
          } catch (e) {
            lastError = e;
            console.warn(`Proxy fall√≥: ${proxyUrl}`);
          }
        }
        
        if (!response || !response.ok) throw lastError || new Error('Todos los proxies fallaron');
        
        const data = await response.json();
        if (!Array.isArray(data) || data.length === 0) {
          console.warn('Ransomware API: sin datos v√°lidos');
          return;
        }

        // Filtrar y procesar v√≠ctimas con coordenadas v√°lidas
        const victims = data
          .filter(v => v.country && COUNTRY_COORDS[v.country])
          .slice(0, 100) // l√≠mite de 100 v√≠ctimas
          .map((v, idx) => {
            const [baseLat, baseLon] = COUNTRY_COORDS[v.country];
            // Agregar peque√±a variaci√≥n aleatoria para evitar superposici√≥n
            const lat = baseLat + (Math.random() - 0.5) * 4;
            const lon = baseLon + (Math.random() - 0.5) * 6;
            return {
              id: v.post_url || `victim-${idx}`,
              name: v.post_title || 'Desconocido',
              country: v.country,
              group: v.group_name || 'Desconocido',
              discovered: v.discovered || v.published || 'N/D',
              lat,
              lon
            };
          });

        if (victims.length > 0) {
          lastRansomwareVictims = victims;
          try {
            localStorage.setItem(RANSOMWARE_CACHE_KEY, JSON.stringify({ 
              ts: Date.now(), 
              data: victims 
            }));
          } catch(_) {}
          renderRansomwareVictims(victims, { forcePulse: false });
          console.log(`‚úì Ransomware v√≠ctimas cargadas: ${victims.length}`);
        }
      } catch (e) {
        console.warn('Error cargando Ransomware.live:', e);
        if (lastRansomwareVictims.length) {
          console.log('Reutilizando cache de ransomware');
          renderRansomwareVictims(lastRansomwareVictims, { forcePulse: false });
        }
      }
    }

    function renderRansomwareVictims(victims, { forcePulse = false } = {}) {
      if (!Array.isArray(victims) || !victims.length) return;
      console.log(`‚ñ∂ Pintando ${victims.length} v√≠ctimas de ransomware`);
      
      ransomwareLayer.clearLayers();

      victims.forEach(victim => {
        const circle = L.circleMarker([victim.lat, victim.lon], {
          radius: 8,
          color: '#f57c00',
          fillColor: '#ffb74d',
          fillOpacity: 0.7,
          weight: 2.5,
          opacity: 0.9
        }).addTo(ransomwareLayer);

        const discoveredDate = victim.discovered !== 'N/D' 
          ? new Date(victim.discovered).toLocaleDateString('es-ES')
          : 'N/D';

        circle.bindPopup(
          `<strong style="color:#ff8c00;">üîí V√≠ctima Ransomware</strong><br>` +
          `<strong>V√≠ctima:</strong> ${victim.name}<br>` +
          `<strong>Grupo:</strong> ${victim.group}<br>` +
          `<strong>Pa√≠s:</strong> ${victim.country}<br>` +
          `<strong>Descubierto:</strong> ${discoveredDate}`
        );

        const isNew = forcePulse || !previousRansomware.has(victim.id);
        if (isNew) {
          createPulse(victim.lat, victim.lon, '#f57c00', ransomwareLayer);
          addToRecentAttacks('ransomware', victim);
        }
        previousRansomware.add(victim.id);
      });

      updateCounters();
      if (heatmapMode) updateHeatmap();
    }

    loadRansomwareVictims();
    setInterval(loadRansomwareVictims, 10 * 60 * 1000); // cada 10 min

    // --- CAPA DE FEODO TRACKER (Botnets C&C)
    async function loadUrlhausUrls() {
      // Mostrar cache inmediatamente si existe (sin forzar pulsos en carga inicial)
      if (lastUrlhausUrls.length) {
        renderUrlhausUrls(lastUrlhausUrls, { forcePulse: false, append: false });
        console.log(`‚Ü∫ Mostrando ${lastUrlhausUrls.length} botnets desde cache`);
      }

      try {
        console.log('ü§ñ Cargando Feodo Tracker (Botnets)...');
        // Intentar con m√∫ltiples proxies CORS
        const proxies = [
          `https://api.allorigins.win/raw?url=${encodeURIComponent(FEODO_TRACKER_API)}`,
          `https://corsproxy.io/?${encodeURIComponent(FEODO_TRACKER_API)}`,
          FEODO_TRACKER_API // Directo como √∫ltimo recurso
        ];
        
        let response = null;
        let lastError = null;
        
        for (const proxyUrl of proxies) {
          try {
            response = await fetch(proxyUrl, { cache: 'no-store' });
            if (response.ok) {
              console.log(`‚úì Proxy exitoso: ${proxyUrl.substring(0, 30)}...`);
              break;
            }
          } catch (e) {
            lastError = e;
            console.warn(`Proxy fall√≥: ${proxyUrl.substring(0, 30)}...`);
          }
        }
        
        if (!response || !response.ok) throw lastError || new Error('Todos los proxies fallaron');
        
        const data = await response.json();
        console.log(`‚úì Feodo Tracker respondi√≥ con ${data.length} IPs de botnets`);
        
        // Procesar IPs de botnets C&C
        const processedUrls = [];
        const seenIps = new Set();
        
        // Filtrar IPs activas recientes (√∫ltimos 30 d√≠as)
        const now = new Date();
        const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
        
        const recentBots = data
          .filter(item => {
            if (!item.ip_address) return false;
            // Incluir tanto online como offline recientes
            if (item.status === 'online') return true;
            if (item.last_online) {
              const lastOnline = new Date(item.last_online);
              return lastOnline > thirtyDaysAgo;
            }
            return false;
          })
          .slice(0, 120); // Aumentado para m√°s IPs
        
        console.log(`üìä ${recentBots.length} botnets encontrados, geolocalizando...`);
        
        let successCount = 0;
        let failCount = 0;
        
        for (const item of recentBots) {
          const ip = item.ip_address;
          
          if (seenIps.has(ip)) continue;
          seenIps.add(ip);
          
          // Intentar geolocalizar con reintentos
          let geoSuccess = false;
          for (let attempt = 1; attempt <= 2; attempt++) {
            try {
              const geo = await fetch(GEO_ENDPOINT(ip), { cache: 'no-store' }).then(r => r.json());
              if (geo && geo.success && typeof geo.latitude === 'number' && typeof geo.longitude === 'number') {
                processedUrls.push({
                  id: ip,
                  url: `${ip}:${item.port || 'N/D'}`,
                  host: ip,
                  threat: item.malware || 'Botnet C&C',
                  lat: geo.latitude,
                  lon: geo.longitude,
                  country: geo.country || 'N/D'
                });
                
                successCount++;
                console.log(`  ‚úì ${successCount}/${recentBots.length} - ${ip} (${item.malware || 'botnet'}) ‚Üí ${geo.country}`);
                geoSuccess = true;
                break;
              }
            } catch (e) {
              if (attempt === 2) {
                failCount++;
                console.warn(`  ‚úó Error geolocalizando ${ip} (2 intentos)`);
              }
              await delay(50); // Pausa breve antes de reintentar
            }
          }
          
          if (!geoSuccess) failCount++;
          
          await delay(100); // Throttle optimizado
          
          if (processedUrls.length >= 60) break;
        }
        
        console.log(`üìà Estad√≠sticas: ${successCount} √©xitos, ${failCount} fallos`);

        if (processedUrls.length > 0) {
          // Sistema acumulativo: agregar nuevos sin borrar anteriores
          const newBots = processedUrls.filter(bot => {
            return !lastUrlhausUrls.some(existing => existing.id === bot.id);
          });
          
          console.log(`üÜï ${newBots.length} botnets nuevos (${lastUrlhausUrls.length} existentes)`);
          
          // Agregar solo los nuevos a la lista
          lastUrlhausUrls.push(...newBots);
          
          // Guardar cache actualizado
          try {
            localStorage.setItem(URLHAUS_CACHE_KEY, JSON.stringify({ 
              ts: Date.now(), 
              data: lastUrlhausUrls 
            }));
          } catch(_) {}
          
          // Renderizar solo los nuevos con animaci√≥n
          if (newBots.length > 0) {
            renderUrlhausUrls(newBots, { forcePulse: true, append: true });
            console.log(`üéâ ${newBots.length} botnets nuevos agregados con pulsos morados!`);
          } else {
            console.log(`‚ÑπÔ∏è Sin botnets nuevos esta vez (todos ya estaban)`);
          }
          
          console.log(`‚úì Total Botnets C&C acumulados: ${lastUrlhausUrls.length}`);
        }
      } catch (e) {
        console.warn('Error cargando Feodo Tracker:', e);
        if (lastUrlhausUrls.length) {
          console.log('Reutilizando cache de Feodo');
          renderUrlhausUrls(lastUrlhausUrls, { forcePulse: false });
        }
      }
    }

    function renderUrlhausUrls(urls, { forcePulse = false, append = false } = {}) {
      if (!Array.isArray(urls) || !urls.length) return;
      console.log(`‚ñ∂ Pintando ${urls.length} servidores Botnet C&C (${append ? 'agregando' : 'reemplazando'})`);
      
      // Solo limpiar si no es modo append
      if (!append) {
        urlhausLayer.clearLayers();
      }

      urls.forEach(urlData => {
        const circle = L.circleMarker([urlData.lat, urlData.lon], {
          radius: 9,
          color: '#7b1fa2',
          fillColor: '#ba68c8',
          fillOpacity: 0.6,
          weight: 2.5,
          opacity: 0.9
        }).addTo(urlhausLayer);

        circle.bindPopup(
          `<strong style="color:#ba68c8;">ü§ñ Botnet C&C</strong><br>` +
          `<strong>Malware:</strong> ${urlData.threat}<br>` +
          `<strong>IP:</strong> ${urlData.host}<br>` +
          `<strong>Pa√≠s:</strong> ${urlData.country}<br>` +
          `<strong>Puerto:</strong> ${urlData.url.split(':')[1] || 'N/D'}`
        );

        const isNew = forcePulse || !previousUrlhaus.has(urlData.id);
        if (isNew) {
          createPulse(urlData.lat, urlData.lon, '#7b1fa2', urlhausLayer);
          addToRecentAttacks('urlhaus', urlData);
        }
        previousUrlhaus.add(urlData.id);
      });

      updateCounters();
      if (heatmapMode) updateHeatmap();
    }

    loadUrlhausUrls();
    setInterval(loadUrlhausUrls, 15 * 60 * 1000); // cada 15 min

    // Inicializar UI
    updateCounters();
    updateAttacksList();

    // --- BARRA DE NOTICIAS (ciberseguridad, RSS)
    // Fuentes en espa√±ol
    const RSS_SOURCES = [
      'https://www.incibe-cert.es/alerta-temprana/avisos-seguridad/feed', // INCIBE-CERT avisos
      'https://www.ccn-cert.cni.es/feeds/avisos.xml',                    // CCN-CERT avisos
      'https://unaaldia.hispasec.com/feed',                             // Hispasec Una al d√≠a
      'https://www.welivesecurity.com/la-es/feed/'                      // ESET en espa√±ol
    ];

    const FALLBACK_NEWS = [
      { title: 'Sin noticias en vivo. Ciberseguridad en modo fallback.', link: '#' },
      { title: 'A√±ade m√°s RSS o revisa la conexi√≥n para ver alertas en tiempo real.', link: '#' }
    ];

    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function parseRSS(xmlText) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(xmlText, 'text/xml');
      const items = [...doc.querySelectorAll('item')].map(item => {
        const title = item.querySelector('title')?.textContent?.trim() || '';
        const link = item.querySelector('link')?.textContent?.trim() || '#';
        return title ? { title, link } : null;
      }).filter(Boolean);
      return items;
    }

    async function fetchFeed(url) {
      const proxied = `https://corsproxy.io/?${encodeURIComponent(url)}`;
      const res = await fetch(proxied, { cache: 'no-store' });
      const text = await res.text();
      return parseRSS(text);
    }

    async function loadNews() {
      const results = [];
      for (const src of RSS_SOURCES) {
        try {
          const items = await fetchFeed(src);
          if (items && items.length) {
            results.push(...items.slice(0, 8));
          }
        } catch (e) {
          console.warn('RSS fallo', src, e);
        }
      }
      if (!results.length) return FALLBACK_NEWS;
      return shuffle(results).slice(0, 40);
    }

    function renderTicker(items) {
      const inner = document.getElementById('noticias-inner');
      const sep = `<span style="color:#44c4ff;font-size:1.1em;font-weight:bold;">&nbsp;&nbsp;‚Ä¢&nbsp;&nbsp;</span>`;
      inner.innerHTML = items.map(n => `<span onclick="window.open('${n.link}', '_blank')" style="cursor:pointer;">${n.title}</span>`).join(sep);
      setTimeout(() => {
        const ancho = inner.offsetWidth / 2;
        const dur = Math.max(24, inner.textContent.length / 10);
        inner.getAnimations().forEach(a => a.cancel());
        inner.animate([
          { transform: "translateX(0)" },
          { transform: `translateX(-${ancho}px)` }
        ], {
          duration: dur * 1000,
          iterations: Infinity,
          easing: "linear"
        });
      }, 150);
    }

    async function startTicker() {
      if (isPreview) return; // no ticker en miniatura
      const items = await loadNews();
      renderTicker(items);
    }

    startTicker();
    setInterval(startTicker, 15 * 60 * 1000); // refresca cada 15 min

    // --- MODO HEATMAP MULTICOLOR ---
    function updateHeatmap() {
      // Limpiar capas anteriores
      heatmapLayers.forEach(layer => {
        if (map.hasLayer(layer)) map.removeLayer(layer);
      });
      heatmapLayers = [];

      if (!heatmapMode) return;

      // Heatmap ROJO para IPs maliciosas
      if (layersVisible.ips && lastEvents.length > 0) {
        const redData = lastEvents.map(ev => [ev.lat, ev.lon, 0.8]);
        const redHeat = L.heatLayer(redData, {
          radius: 30,
          blur: 40,
          maxZoom: 10,
          max: 0.6,
          minOpacity: 0.4,
          gradient: {
            0.0: 'rgba(211, 47, 47, 0)',
            0.2: 'rgba(211, 47, 47, 0.2)',
            0.4: 'rgba(229, 57, 53, 0.4)',
            0.6: 'rgba(244, 67, 54, 0.6)',
            0.8: 'rgba(255, 107, 107, 0.8)',
            1.0: 'rgba(255, 82, 82, 1.0)'
          }
        }).addTo(map);
        heatmapLayers.push(redHeat);
      }
      
      // Heatmap NARANJA para ransomware
      if (layersVisible.ransomware && lastRansomwareVictims.length > 0) {
        const orangeData = lastRansomwareVictims.map(v => [v.lat, v.lon, 1.0]);
        const orangeHeat = L.heatLayer(orangeData, {
          radius: 30,
          blur: 40,
          maxZoom: 10,
          max: 0.6,
          minOpacity: 0.4,
          gradient: {
            0.0: 'rgba(245, 124, 0, 0)',
            0.2: 'rgba(245, 124, 0, 0.2)',
            0.4: 'rgba(251, 140, 0, 0.4)',
            0.6: 'rgba(255, 152, 0, 0.6)',
            0.8: 'rgba(255, 183, 77, 0.8)',
            1.0: 'rgba(255, 204, 0, 1.0)'
          }
        }).addTo(map);
        heatmapLayers.push(orangeHeat);
      }

      // Heatmap MORADO para botnets
      if (layersVisible.urlhaus && lastUrlhausUrls.length > 0) {
        const purpleData = lastUrlhausUrls.map(u => [u.lat, u.lon, 0.9]);
        const purpleHeat = L.heatLayer(purpleData, {
          radius: 30,
          blur: 40,
          maxZoom: 10,
          max: 0.6,
          minOpacity: 0.4,
          gradient: {
            0.0: 'rgba(123, 31, 162, 0)',
            0.2: 'rgba(123, 31, 162, 0.2)',
            0.4: 'rgba(142, 36, 170, 0.4)',
            0.6: 'rgba(156, 39, 176, 0.6)',
            0.8: 'rgba(186, 104, 200, 0.8)',
            1.0: 'rgba(206, 147, 216, 1.0)'
          }
        }).addTo(map);
        heatmapLayers.push(purpleHeat);
      }
    }

    // --- TOGGLE DE CAPAS Y HEATMAP ---
    document.getElementById('legend-ips').addEventListener('click', () => {
      layersVisible.ips = !layersVisible.ips;
      const element = document.getElementById('legend-ips');
      
      if (layersVisible.ips) {
        map.addLayer(attacksLayer);
        element.classList.remove('disabled');
      } else {
        map.removeLayer(attacksLayer);
        element.classList.add('disabled');
      }
      
      if (heatmapMode) updateHeatmap();
    });

    document.getElementById('legend-ransomware').addEventListener('click', () => {
      layersVisible.ransomware = !layersVisible.ransomware;
      const element = document.getElementById('legend-ransomware');
      
      if (layersVisible.ransomware) {
        map.addLayer(ransomwareLayer);
        element.classList.remove('disabled');
      } else {
        map.removeLayer(ransomwareLayer);
        element.classList.add('disabled');
      }
      
      if (heatmapMode) updateHeatmap();
    });

    document.getElementById('legend-urlhaus').addEventListener('click', () => {
      layersVisible.urlhaus = !layersVisible.urlhaus;
      const element = document.getElementById('legend-urlhaus');
      
      if (layersVisible.urlhaus) {
        map.addLayer(urlhausLayer);
        element.classList.remove('disabled');
      } else {
        map.removeLayer(urlhausLayer);
        element.classList.add('disabled');
      }
      
      if (heatmapMode) updateHeatmap();
    });

    document.getElementById('heatmap-toggle').addEventListener('click', function() {
      heatmapMode = !heatmapMode;
      
      if (heatmapMode) {
        // Activar heatmap: ocultar marcadores
        this.classList.add('active');
        this.textContent = 'üìç Modo Normal';
        map.removeLayer(attacksLayer);
        map.removeLayer(ransomwareLayer);
        map.removeLayer(urlhausLayer);
        updateHeatmap();
      } else {
        // Desactivar heatmap: mostrar marcadores
        this.classList.remove('active');
        this.textContent = 'üî• Modo Mapa de Calor';
        if (layersVisible.ips) map.addLayer(attacksLayer);
        if (layersVisible.ransomware) map.addLayer(ransomwareLayer);
        if (layersVisible.urlhaus) map.addLayer(urlhausLayer);
        heatmapLayers.forEach(layer => {
          if (map.hasLayer(layer)) map.removeLayer(layer);
        });
        heatmapLayers = [];
      }
    });

    // Bot√≥n de reset
    document.getElementById('reset-view').addEventListener('click', resetMapView);
  </script>
</body>
</html>

