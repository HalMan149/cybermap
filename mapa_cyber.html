<!DOCTYPE html>
<html lang="es">
<head>
  <meta charset="utf-8" />
  <title>Mapa Cyberpunk + GPS p√∫blico</title>
  <meta name="viewport" content="width=device-width, initial-scale=1.0"/>
  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
  <style>
    html, body {
      height: 100vh; width: 100vw; margin: 0; padding: 0; background: #0b1021;
      box-sizing: border-box;
    }
    #map {
      width: 100vw; height: 100vh; margin: 0; padding: 0; background: #0b1021;
      box-sizing: border-box;
    }
    .zona-horaria-label, .city-clock-label { pointer-events: none; user-select: none; }
    .gmt-utc-clock {
      font-family: 'Consolas', monospace; font-size: 1.25em;
      padding: 2px 12px; border-radius: 12px; border: 2.2px solid #00ffd9a0;
      background: #0a233bf2; color: #1fffb7; font-weight: 600;
      margin-top: 6px; margin-bottom: 0; text-align: center; width: 76px;
      box-shadow: 0 0 8px #0ff8; letter-spacing: 0.04em;
      text-shadow: 0 0 5px #0ff7; transition: color 0.2s, border 0.2s, background 0.2s;
      cursor: pointer;
    }
    .gmt-utc-clock.sync-error {
      color: #ffae47 !important;
      border-color: #ffc66a !important;
      background: #2d1c05ea !important;
      box-shadow: 0 0 18px #ffc66a77 !important;
    }
    .zona-horaria-label.gmt-central { font-weight: bold; }
    .city-clock-label {
      background: transparent !important; border: none !important; box-shadow: none !important; min-width: 0 !important; padding: 0 !important;
      font-family: 'Segoe UI', 'Roboto', sans-serif; color: #63faff;
      text-align: center;
      text-shadow: 0 0 8px #29eaffb8, 0 0 2px #09e7;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
    }
    .city-clock-label .hora {
      font-family: 'Consolas', monospace; font-size: 1.24em; color: #73fdff; font-weight: 800;
      margin-bottom: 0px; text-shadow: 0 0 13px #5efcff, 0 0 3px #33eaffb8; background: transparent; border: none; letter-spacing: 0.03em; line-height: 1.2;
    }
    .city-clock-label .city {
      font-size: 1em; color: #fff; font-weight: 600; margin-top: 0px; line-height: 1.08; background: transparent; border: none; text-shadow: 0 0 4px #00f8, 0 0 1px #0af9;
    }
    .leaflet-overlay-pane svg polyline {
      stroke: #2cfdff !important; filter: drop-shadow(0 0 6px #12fd) drop-shadow(0 0 2px #00f8); stroke-width: 2.3 !important; stroke-opacity: 0.65 !important;
    }
    #noticias-ticker {
      position: absolute; bottom: 0; left: 0; width: 100vw;
      z-index: 3000; background: rgba(8, 26, 31, 0.54); backdrop-filter: blur(2.5px);
      color: #6bf; font-family: 'Segoe UI', Arial, sans-serif; font-size: 1.13em;
      height: 33px; display: flex; align-items: center; overflow: hidden;
      border-top: 2px solid #13f5ff; box-shadow: 0 1px 7px #00f3;
      text-shadow: 0 0 8px #27fd;
    }
    #noticias-inner { white-space: nowrap; display: inline-block; will-change: transform; }

    /* Ocultar ticker en miniatura */
    body.preview #noticias-ticker { display: none; }

    /* Animaciones */
    @keyframes pulseGlow {
      0%, 100% { box-shadow: 0 0 12px rgba(19, 245, 255, 0.4); transform: scale(1); }
      50% { box-shadow: 0 0 25px rgba(19, 245, 255, 0.8); transform: scale(1.03); }
    }
    @keyframes resetPulse {
      0% { box-shadow: 0 0 0 0 rgba(19, 245, 255, 0.7); }
      70% { box-shadow: 0 0 0 15px rgba(19, 245, 255, 0); }
      100% { box-shadow: 0 0 0 0 rgba(19, 245, 255, 0); }
    }
    @keyframes slideIn {
      from { opacity: 0; transform: translateX(20px); }
      to { opacity: 1; transform: translateX(0); }
    }

    /* Leyenda */
    #legend {
      position: absolute; top: 15px; left: 15px; z-index: 2000;
      background: rgba(11, 16, 33, 0.35); backdrop-filter: blur(14px);
      border: 2px solid #13f5ff; border-radius: 12px; padding: 0;
      font-family: 'Segoe UI', sans-serif; color: #fff;
      box-shadow: 0 4px 15px rgba(0, 255, 255, 0.3); min-width: 220px;
      transition: all 0.3s ease;
    }
    #legend.collapsed { width: 60px; }
    #legend-header {
      padding: 12px 15px; cursor: pointer;
      display: flex; align-items: center; justify-content: space-between;
      border-bottom: 1px solid rgba(19, 245, 255, 0.3);
    }
    #legend-header:hover { background: rgba(19, 245, 255, 0.1); }
    #legend h3 {
      margin: 0; font-size: 1.1em; color: #13f5ff;
      text-shadow: 0 0 8px #13f5ff; font-weight: 600;
    }
    #legend-toggle {
      font-size: 1.2em; color: #13f5ff; transition: transform 0.3s;
    }
    #legend.collapsed #legend-toggle { transform: rotate(180deg); }
    #legend-content {
      padding: 12px 15px;
      max-height: 600px;
      overflow: hidden;
      transition: max-height 0.3s ease, opacity 0.3s ease;
    }
    #legend.collapsed #legend-content {
      max-height: 0;
      opacity: 0;
      padding-top: 0;
      padding-bottom: 0;
    }
    #legend.collapsed h3 { display: none; }
    .legend-item {
      display: flex; align-items: center; margin-bottom: 10px;
      cursor: pointer; transition: opacity 0.3s;
    }
    .legend-item:hover { opacity: 0.8; }
    .legend-item.disabled { opacity: 0.4; }
    .legend-color {
      width: 18px; height: 18px; border-radius: 50%;
      margin-right: 10px; border: 2px solid currentColor;
    }
    .legend-label { font-size: 0.95em; flex: 1; }
    .legend-count {
      font-size: 0.85em; color: #13f5ff; font-weight: 600; margin-left: 8px;
    }
    #heatmap-toggle, #reset-view {
      padding: 8px 12px; width: 100%;
      background: linear-gradient(135deg, #1a4d5e, #0d2838);
      border: 2px solid #13f5ff; border-radius: 8px;
      color: #fff; font-size: 0.9em; cursor: pointer;
      transition: all 0.3s; font-weight: 600;
      text-shadow: 0 0 5px #13f5ff; margin-top: 10px;
    }
    #heatmap-toggle:hover, #reset-view:hover {
      background: linear-gradient(135deg, #2a6d7e, #1d4858);
      animation: pulseGlow 1.5s ease-in-out infinite;
    }
    #heatmap-toggle.active {
      background: linear-gradient(135deg, #2a6d7e, #1d5868);
      border-color: #13f5ff; text-shadow: 0 0 5px #13f5ff;
    }
    #reset-view.resetting { animation: resetPulse 1s ease-out; }

    /* Lista lateral de ataques */
    #recent-attacks {
      position: absolute; top: 15px; right: 15px; z-index: 2000;
      background: rgba(11, 16, 33, 0.35); backdrop-filter: blur(14px);
      border: 2px solid #ff6b6b; border-radius: 12px; padding: 0;
      font-family: 'Segoe UI', sans-serif; color: #fff;
      box-shadow: 0 4px 15px rgba(255, 107, 107, 0.3);
      width: 320px;
      transition: all 0.3s ease;
    }
    #recent-attacks.collapsed { width: 60px; }
    #attacks-header {
      padding: 12px 15px; cursor: pointer;
      display: flex; align-items: center; justify-content: space-between;
      border-bottom: 1px solid rgba(255, 107, 107, 0.3);
    }
    #attacks-header:hover { background: rgba(255, 107, 107, 0.1); }
    #recent-attacks h3 {
      margin: 0; font-size: 1.1em; color: #ff6b6b;
      text-shadow: 0 0 8px #ff6b6b; font-weight: 600;
    }
    #attacks-toggle {
      font-size: 1.2em; color: #ff6b6b; transition: transform 0.3s;
    }
    #recent-attacks.collapsed #attacks-toggle { transform: rotate(180deg); }
    #attacks-content {
      max-height: 500px;
      overflow-y: auto;
      transition: max-height 0.3s ease, opacity 0.3s ease;
    }
    #recent-attacks.collapsed #attacks-content {
      max-height: 0;
      opacity: 0;
    }
    #recent-attacks.collapsed h3 { display: none; }
    .attack-item {
      background: rgba(255, 107, 107, 0.08);
      border-left: 3px solid #ff6b6b;
      padding: 10px; margin-bottom: 8px; border-radius: 6px;
      font-size: 0.85em; cursor: pointer;
      transition: all 0.3s; animation: slideIn 0.4s ease-out;
    }
    .attack-item:hover {
      background: rgba(255, 107, 107, 0.15); transform: translateX(-3px);
    }
    .attack-item.ransomware {
      border-left-color: #ffa500; background: rgba(255, 165, 0, 0.08);
    }
    .attack-item.ransomware:hover { background: rgba(255, 165, 0, 0.15); }
    .attack-item.urlhaus {
      border-left-color: #ba68c8; background: rgba(186, 104, 200, 0.08);
    }
    .attack-item.urlhaus:hover { background: rgba(186, 104, 200, 0.15); }
    .attack-type {
      font-weight: 600; color: #ff6b6b; font-size: 0.9em; margin-bottom: 4px;
    }
    .attack-item.ransomware .attack-type { color: #ffa500; }
    .attack-item.urlhaus .attack-type { color: #ba68c8; }
    .attack-item.threatfox {
      border-left-color: #ff6f00; background: rgba(255, 111, 0, 0.08);
    }
    .attack-item.threatfox:hover { background: rgba(255, 111, 0, 0.15); }
    .attack-item.threatfox .attack-type { color: #ff6f00; }
    .attack-item.blocklist {
      border-left-color: #00bcd4; background: rgba(0, 188, 212, 0.08);
    }
    .attack-item.blocklist:hover { background: rgba(0, 188, 212, 0.15); }
    .attack-item.blocklist .attack-type { color: #00bcd4; }
    .attack-details { color: #ccc; line-height: 1.5; }
    .attack-time {
      font-size: 0.8em; color: #13f5ff; margin-top: 4px;
      font-family: 'Consolas', monospace;
    }
    #recent-attacks::-webkit-scrollbar { width: 6px; }
    #recent-attacks::-webkit-scrollbar-track { background: rgba(0,0,0,0.3); }
    #recent-attacks::-webkit-scrollbar-thumb {
      background: #ff6b6b; border-radius: 3px;
    }

    /* Ocultar paneles en preview */
    body.preview #legend, body.preview #recent-attacks { display: none; }
  </style>
</head>
<body class="">
  <div id="map"></div>
  
  <!-- Leyenda -->
  <div id="legend">
    <div id="legend-header">
      <h3>üó∫Ô∏è Capas del Mapa</h3>
      <span id="legend-toggle">‚óÄ</span>
    </div>
    <div id="legend-content">
    <div class="legend-item" id="legend-ips" data-layer="ips">
      <div class="legend-color" style="background: #ff4757;"></div>
      <span class="legend-label">IPs Maliciosas</span>
      <span class="legend-count" id="count-ips">0</span>
    </div>
    <div class="legend-item" id="legend-threatfox" data-layer="threatfox">
      <div class="legend-color" style="background: #ff6f00;"></div>
      <span class="legend-label">IPs Malware (IPsum)</span>
      <span class="legend-count" id="count-threatfox">0</span>
    </div>
    <div class="legend-item" id="legend-ransomware" data-layer="ransomware">
      <div class="legend-color" style="background: #ffa500;"></div>
      <span class="legend-label">V√≠ctimas Ransomware</span>
      <span class="legend-count" id="count-ransomware">0</span>
    </div>
    <div class="legend-item" id="legend-urlhaus" data-layer="urlhaus">
      <div class="legend-color" style="background: #ba68c8;"></div>
      <span class="legend-label">Botnets C&C</span>
      <span class="legend-count" id="count-urlhaus">0</span>
    </div>
    <div class="legend-item" id="legend-blocklist" data-layer="blocklist">
      <div class="legend-color" style="background: #00bcd4;"></div>
      <span class="legend-label">Ataques SSH/FTP</span>
      <span class="legend-count" id="count-blocklist">0</span>
    </div>
    <button id="heatmap-toggle">üìç Modo Puntos</button>
    <button id="reset-view">üéØ Restablecer Vista</button>
    </div>
  </div>

  <!-- Lista de ataques recientes -->
  <div id="recent-attacks">
    <div id="attacks-header">
      <h3>‚ö° Ataques Recientes</h3>
      <span id="attacks-toggle">‚ñ∂</span>
    </div>
    <div id="attacks-content">
      <div id="attacks-list"></div>
    </div>
  </div>

  <div id="noticias-ticker"><span id="noticias-inner"></span></div>
  
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
  <script src="https://unpkg.com/leaflet.heat@0.2.0/dist/leaflet-heat.js"></script>
  <script>
    const urlParams = new URLSearchParams(window.location.search);
    const isPreview = urlParams.has('preview');
    if (isPreview) {
      document.body.classList.add('preview');
    }

    const CENTER = [38.3373, -0.5266];
    const ZOOM = 3;
    // Para la miniatura: m√°s abierto y centrado en el mundo
    // Preview: usaremos fitBounds para recortar polos en la miniatura
    const baseZoom = ZOOM;
    const minZoom = isPreview ? 1.0 : ZOOM;

    const map = L.map('map', {
      zoomControl: true,
      attributionControl: false,
      minZoom,
      maxZoom: 17,
      scrollWheelZoom: true,
      doubleClickZoom: false,
      boxZoom: true,
      dragging: true,
      touchZoom: true,
      keyboard: true,
      worldCopyJump: false,
      noWrap: true,
      maxBounds: [[-61, -180], [84, 180]],
      maxBoundsViscosity: 1.0,
      preferCanvas: true
    });

    // Guardar vista inicial
    let initialView = { center: CENTER, zoom: baseZoom };

    if (isPreview) {
      // Recorte: m√°s sur (Sudam√©rica completa) y un poco menos de norte
      const previewBounds = [[-65, -180], [68, 180]];
      map.fitBounds(previewBounds, { animate: false });
      map.setMaxBounds(previewBounds);
    } else {
      map.setView(CENTER, baseZoom);
    }

    // Funci√≥n para restablecer vista con animaci√≥n
    function resetMapView() {
      const btn = document.getElementById('reset-view');
      btn.classList.add('resetting');
      
      map.setView(initialView.center, initialView.zoom, { 
        animate: true,
        duration: 1.0
      });

      setTimeout(() => {
        btn.classList.remove('resetting');
      }, 1000);
    }

    // Doble clic en el mapa para restablecer vista
    map.on('dblclick', function(e) {
      resetMapView();
    });

    // --- Mapa base oscuro fijo, SIN repetir
    L.tileLayer('https://{s}.basemaps.cartocdn.com/dark_all/{z}/{x}/{y}{r}.png', {
      maxZoom: 19, minZoom: 1, noWrap: true
    }).addTo(map);

    // --- Capa de l√≠neas GPS p√∫blicas, SIN repetir
    L.tileLayer('https://gps-{s}.tile.openstreetmap.org/lines/{z}/{x}/{y}.png', {
      maxZoom: 19, minZoom: 1, opacity: 0.85, noWrap: true
    }).addTo(map);

    // --- ZONAS HORARIAS Y RELOJES ---
    const zonaHorariaLines = L.layerGroup();
    const relojMarkers = [];
    let utcRef = new Date(); // base inicial, se ajusta con reloj at√≥mico
    let utcError = false;

    for(let i = -12; i <= 14; i++) {
      const lon = i * 15;
      if (lon < -180 || lon > 180) continue;
      const isCentral = (i === 0);
      const line = L.polyline([[-59.98, lon], [82.26, lon]],
        { color: "#2cfdff", weight: 2.3, opacity: 0.65, dashArray: "5,14", interactive: false });
      zonaHorariaLines.addLayer(line);
      const latLabel = 82.15;
      const relojId = `reloj-tz${i}`;
      const extraClass = isCentral ? " gmt-central" : "";
      const ancla = isCentral ? [52, 10] : [31, 10];
      const marker = L.marker([latLabel, lon], {
        icon: L.divIcon({
          className: 'zona-horaria-label' + extraClass,
          html: isCentral
            ? `<div class="gmt-utc-clock" id="${relojId}">--:--</div>`
            : `<div id="${relojId}" style="font-family:monospace;font-size:1.18em;color:#72fdff;background:transparent;padding:0;border:none;min-width:62px;text-align:center;box-shadow:none"></div>`,
          iconAnchor: ancla
        }),
        interactive: false
      });
      relojMarkers.push({ id: relojId, offset: i });
      zonaHorariaLines.addLayer(marker);
    }
    zonaHorariaLines.addTo(map);

    // --- RELOJES DE CIUDADES (zona horaria real para DST autom√°tico) ---
    const cityMarkers = [
      { name: "Los √Ångeles", lat:34.05, lon:-118.25, tz: "America/Los_Angeles", id:"clkla" },
      { name: "Denver", lat:39.74, lon:-104.99, tz: "America/Denver", id:"clkden" },
      { name: "M√©xico", lat:19.43, lon:-99.13, tz: "America/Mexico_City", id:"clkcdmx" },
      { name: "Nueva York", lat:40.71, lon:-74.01, tz: "America/New_York", id:"clkny" },
      { name: "Buenos Aires", lat:-34.61, lon:-58.38, tz: "America/Argentina/Buenos_Aires", id:"clkbue" },
      { name: "Sao Paulo", lat:-23.55, lon:-46.63, tz: "America/Sao_Paulo", id:"clksp" },
      { name: "Londres", lat:51.51, lon:-0.13, tz: "Europe/London", id:"clklon" },
      { name: "Madrid", lat:40.42, lon:-3.70, tz: "Europe/Madrid", id:"clkmad" },
      { name: "El Cairo", lat:30.05, lon:31.25, tz: "Africa/Cairo", id:"clkcai" },
      { name: "Mosc√∫", lat:55.75, lon:37.62, tz: "Europe/Moscow", id:"clkmsk" },
      { name: "Dub√°i", lat:25.20, lon:55.27, tz: "Asia/Dubai", id:"clkdx" },
      { name: "Nueva Delhi", lat:28.61, lon:77.20, tz: "Asia/Kolkata", id:"clkdel" },
      { name: "Pek√≠n", lat:39.90, lon:116.40, tz: "Asia/Shanghai", id:"clkpek" },
      { name: "Tokio", lat:35.68, lon:139.69, tz: "Asia/Tokyo", id:"clktok" },
      { name: "S√≠dney", lat:-33.87, lon:151.21, tz: "Australia/Sydney", id:"clksyd" },
      { name: "Perth", lat:-31.95, lon:115.86, tz: "Australia/Perth", id:"clkper" }
    ];
    cityMarkers.forEach(city => {
      L.marker([city.lat, city.lon], {
        icon: L.divIcon({
          className: "city-clock-label",
          html: `<span class="hora" id="${city.id}-hora">--:--</span>
                 <span class="city">${city.name}</span>`,
          iconAnchor: [11, 10]
        }),
        interactive: false
      }).addTo(map);
    });

    function formatTimeInTZ(tz, ts) {
      return new Intl.DateTimeFormat('es-ES', {
        hour: '2-digit',
        minute: '2-digit',
        hourCycle: 'h23',
        timeZone: tz
      }).format(ts);
    }

    function updateCentralUTCAndRelojes() {
      const nowBase = utcRef instanceof Date ? utcRef : new Date();
      const nowTs = nowBase.getTime();
      const centralClock = document.getElementById('reloj-tz0');
      if (centralClock) {
        const h = String(nowBase.getUTCHours()).padStart(2,"0");
        const m = String(nowBase.getUTCMinutes()).padStart(2,"0");
        centralClock.textContent = `${h}:${m}`;
        centralClock.title = utcError ? "UTC (fallback local)" : "Hora GMT/UTC at√≥mica";
      }
      relojMarkers.forEach(({id, offset}) => {
        if (id === 'reloj-tz0') return;
        const el = document.getElementById(id);
        if (!el) return;
        const t = new Date(nowTs + offset * 60 * 60 * 1000);
        const hh = String(t.getUTCHours()).padStart(2, "0");
        const mm = String(t.getUTCMinutes()).padStart(2, "0");
        el.textContent = `${hh}:${mm}`;
      });
      cityMarkers.forEach(city => {
        const el = document.getElementById(city.id + "-hora");
        if (!el) return;
        el.textContent = formatTimeInTZ(city.tz, nowTs);
      });
    }

    // Sincronizaci√≥n UTC at√≥mica + fallback
    async function syncUTCAtomic() {
      try {
        const resp = await fetch('https://timeapi.io/api/Time/current/zone?timeZone=UTC', { cache: 'no-store' });
        const data = await resp.json();
        utcRef = new Date(data.dateTime);
        utcError = false;
      } catch(e) {
        utcRef = new Date();
        utcError = true;
      }
      updateCentralUTCAndRelojes();
    }

    // Primera actualizaci√≥n inmediata
    updateCentralUTCAndRelojes();
    syncUTCAtomic();
    setInterval(syncUTCAtomic, 5 * 60 * 1000); // cada 5 min
    setInterval(updateCentralUTCAndRelojes, 60000); // cada 1 min (usa utcRef vigente)
    // --- CAPA DE EVENTOS (IP maliciosas desde funci√≥n serverless)
    const attacksLayer = L.layerGroup().addTo(map);
    const ransomwareLayer = L.layerGroup().addTo(map);
    const urlhausLayer = L.layerGroup().addTo(map);
    const threatfoxLayer = L.layerGroup().addTo(map);
    const blocklistLayer = L.layerGroup().addTo(map);
    let heatmapLayers = [];
    const previousIps = new Set();
    const previousRansomware = new Set();
    const previousUrlhaus = new Set();
    const previousThreatfox = new Set();
    const previousBlocklist = new Set();
    const pulseRefs = [];
    const recentAttacksList = [];
    let layersVisible = { ips: true, ransomware: true, urlhaus: true, threatfox: true, blocklist: true };
    let heatmapMode = true; // Por defecto en modo heatmap
    let temporaryPointsTimeout = null;
    const DEMO_EVENTS = [
      { ip: 'demo-1', lat: 40.71, lon: -74.01, country: 'US' },
      { ip: 'demo-2', lat: 51.50, lon: -0.12, country: 'UK' },
      { ip: 'demo-3', lat: 35.68, lon: 139.69, country: 'JP' },
      { ip: 'demo-4', lat: 19.43, lon: -99.13, country: 'MX' }
    ];
    const FIREHOL_URLS = [
      'https://raw.githubusercontent.com/firehol/blocklist-ipsets/master/firehol_level1.netset',
      'https://cdn.jsdelivr.net/gh/firehol/blocklist-ipsets@master/firehol_level1.netset',
      'https://raw.githack.com/firehol/blocklist-ipsets/master/firehol_level1.netset'
    ];
    const MAX_FIREHOL_IPS = 120;
    const GEO_ENDPOINT = (ip) => `https://ipwho.is/${ip}`;
    const CACHE_KEY = 'cyber_attacks_cache';
    const RANSOMWARE_CACHE_KEY = 'ransomware_victims_cache';
    const URLHAUS_CACHE_KEY = 'feodo_botnets_cache';
    const THREATFOX_CACHE_KEY = 'threatfox_iocs_cache';
    const BLOCKLIST_CACHE_KEY = 'blocklist_attacks_cache';
    const CACHE_MS = 6 * 60 * 60 * 1000; // 6h
    const RANSOMWARE_API = 'https://api.ransomware.live/recentvictims';
    const FEODO_TRACKER_API = 'https://feodotracker.abuse.ch/downloads/ipblocklist.json';
    const THREATFOX_API = 'https://raw.githubusercontent.com/stamparm/ipsum/master/ipsum.txt';
    const BLOCKLIST_API = 'https://lists.blocklist.de/lists/all.txt';
    let lastEvents = [];
    let lastRansomwareVictims = [];
    let lastUrlhausUrls = [];
    let lastThreatfoxIocs = [];
    let lastBlocklistIps = [];
    
    // Intentar recuperar cache de sesiones previas (IPs maliciosas)
    try {
      const stored = localStorage.getItem(CACHE_KEY);
      if (stored) {
        const parsed = JSON.parse(stored);
        if (parsed && parsed.ts && (Date.now() - parsed.ts) < CACHE_MS && Array.isArray(parsed.data) && parsed.data.length) {
          lastEvents = parsed.data;
          console.log(`‚Ü∫ Cache cyber: ${parsed.data.length} eventos (<=6h)`);
        }
      }
    } catch(_) {}
    
    // Intentar recuperar cache de ransomware
    try {
      const stored = localStorage.getItem(RANSOMWARE_CACHE_KEY);
      if (stored) {
        const parsed = JSON.parse(stored);
        if (parsed && parsed.ts && (Date.now() - parsed.ts) < CACHE_MS && Array.isArray(parsed.data) && parsed.data.length) {
          lastRansomwareVictims = parsed.data;
          console.log(`‚Ü∫ Cache ransomware: ${parsed.data.length} v√≠ctimas (<=6h)`);
        }
      }
    } catch(_) {}

    // Intentar recuperar cache de Feodo/Botnets
    try {
      const stored = localStorage.getItem(URLHAUS_CACHE_KEY);
      if (stored) {
        const parsed = JSON.parse(stored);
        if (parsed && parsed.ts && (Date.now() - parsed.ts) < CACHE_MS && Array.isArray(parsed.data) && parsed.data.length) {
          lastUrlhausUrls = parsed.data;
          console.log(`‚Ü∫ Cache Feodo: ${parsed.data.length} botnets (<=6h)`);
        }
      }
    } catch(_) {}

    // Cache ThreatFox
    try {
      const stored = localStorage.getItem(THREATFOX_CACHE_KEY);
      if (stored) {
        const parsed = JSON.parse(stored);
        if (parsed && parsed.ts && (Date.now() - parsed.ts) < CACHE_MS && Array.isArray(parsed.data) && parsed.data.length) {
          lastThreatfoxIocs = parsed.data;
          console.log(`‚Ü∫ Cache ThreatFox: ${parsed.data.length} IOCs (<=6h)`);
        }
      }
    } catch(_) {}

    // Cache Blocklist.de
    try {
      const stored = localStorage.getItem(BLOCKLIST_CACHE_KEY);
      if (stored) {
        const parsed = JSON.parse(stored);
        if (parsed && parsed.ts && (Date.now() - parsed.ts) < CACHE_MS && Array.isArray(parsed.data) && parsed.data.length) {
          lastBlocklistIps = parsed.data;
          console.log(`‚Ü∫ Cache Blocklist: ${parsed.data.length} IPs atacantes (<=6h)`);
        }
      }
    } catch(_) {}

    function createPulse(lat, lon, color = '#d32f2f', layer = attacksLayer) {
      const baseRadius = 70000;
      const circle = L.circle([lat, lon], {
        radius: baseRadius,
        color: color,
        weight: 2,
        opacity: 0.8,
        fillOpacity: 0.15,
        interactive: false
      }).addTo(layer);

      let growing = true;
      let scale = 1;
      const maxScale = 3;
      const minScale = 1;
      const step = 0.05;

      const interval = setInterval(() => {
        scale += growing ? step : -step;
        if (scale >= maxScale) growing = false;
        if (scale <= minScale) growing = true;
        circle.setRadius(baseRadius * scale);
        circle.setStyle({ opacity: 0.8 / scale, fillOpacity: 0.2 / scale });
      }, 50);

      setTimeout(() => {
        clearInterval(interval);
        if (layer.hasLayer(circle)) layer.removeLayer(circle);
      }, 15000); // 15s de pulso

      pulseRefs.push({ circle, interval });
    }

    function filterAttacks(events) {
      const ipSeen = new Set();
      const cellSeen = new Set(); // celda aproximada para evitar clusters densos
      const filtered = [];
      for (const ev of events || []) {
        if (typeof ev.lat !== 'number' || typeof ev.lon !== 'number') continue;
        if (!ev.ip) continue;
        if (ipSeen.has(ev.ip)) continue;
        ipSeen.add(ev.ip);
        const cell = `${Math.round(ev.lat * 2) / 2}_${Math.round(ev.lon * 2) / 2}`; // cuadr√≠cula 0.5¬∞
        if (cellSeen.has(cell)) continue;
        cellSeen.add(cell);
        filtered.push(ev);
        if (filtered.length >= 200) break; // l√≠mite duro
      }
      return filtered;
    }

    function renderAttacks(events, { forcePulse = false } = {}) {
      if (!Array.isArray(events) || !events.length) return;
      console.log(`‚ñ∂ Pintando ${events.length} eventos cyber`);
      attacksLayer.clearLayers();
      // limpiar pulsos previos
      pulseRefs.forEach(({ interval }) => clearInterval(interval));
      pulseRefs.length = 0;

      events.forEach(ev => {
        const circle = L.circleMarker([ev.lat, ev.lon], {
          radius: 9,
          color: '#d32f2f',
          fillColor: '#ff6b6b',
          fillOpacity: 0.6,
          weight: 2.5,
          opacity: 0.9
        }).addTo(attacksLayer);
        circle.bindPopup(
          `IP en lista negra: ${ev.ip}<br>` +
          `Pa√≠s: ${ev.country || 'N/D'}`
        );

        const isNew = forcePulse || !previousIps.has(ev.ip);
        if (isNew) {
          createPulse(ev.lat, ev.lon);
          addToRecentAttacks('ip', ev);
        }
        // marcar como vista
        previousIps.add(ev.ip);
      });

      updateCounters();
      if (heatmapMode) updateHeatmap();
    }

    function delay(ms) { return new Promise(res => setTimeout(res, ms)); }

    async function fetchFireholIPs() {
      let lastError = null;
      for (const url of FIREHOL_URLS) {
        try {
          const res = await fetch(url, { cache: 'no-store' });
          if (!res.ok) throw new Error(`HTTP ${res.status}`);
          const txt = await res.text();
          const ips = txt
            .split('\n')
            .map(l => l.trim())
            .filter(l => l && !l.startsWith('#'))
            .map(l => {
              const mCidr = l.match(/^(\d+\.\d+\.\d+\.\d+)\/\d+/);
              const mIp = l.match(/^(\d+\.\d+\.\d+\.\d+)$/);
              return mCidr ? mCidr[1] : (mIp ? mIp[1] : null);
            })
            .filter(Boolean);
          const uniq = Array.from(new Set(ips)).slice(0, MAX_FIREHOL_IPS);
          console.log(`FireHOL desde ${url} -> ${uniq.length} IPs`);
          if (uniq.length > 0) return uniq;
        } catch (e) {
          lastError = e;
          console.warn(`FireHOL fallo ${url}`, e);
        }
      }
      if (lastError) throw lastError;
      return [];
    }

    async function geolocateIPs(ips) {
      const results = [];
      for (const ip of ips) {
        try {
          const geo = await fetch(GEO_ENDPOINT(ip), { cache: 'no-store' }).then(r => r.json());
          if (geo && geo.success && typeof geo.latitude === 'number' && typeof geo.longitude === 'number') {
            results.push({ ip, lat: geo.latitude, lon: geo.longitude, country: geo.country });
          }
        } catch (_) {}
        await delay(180); // throttle para no quemar la API
      }
      console.log(`Geolocalizadas ${results.length} / ${ips.length} IPs`);
      return results;
    }

    // --- FUNCIONES DE UI (CONTADORES, LISTA, TOGGLE) ---
    function updateCounters() {
      document.getElementById('count-ips').textContent = lastEvents.length;
      document.getElementById('count-ransomware').textContent = lastRansomwareVictims.length;
      document.getElementById('count-urlhaus').textContent = lastUrlhausUrls.length;
      document.getElementById('count-threatfox').textContent = lastThreatfoxIocs.length;
      document.getElementById('count-blocklist').textContent = lastBlocklistIps.length;
    }

    function addToRecentAttacks(type, data) {
      const timestamp = new Date();
      const attack = { type, data, timestamp };
      recentAttacksList.unshift(attack);
      if (recentAttacksList.length > 50) recentAttacksList.pop();
      updateAttacksList();
    }

    function updateAttacksList() {
      const container = document.getElementById('attacks-list');
      if (!container) return;
      const toShow = recentAttacksList.slice(0, 20);
      
      if (toShow.length === 0) {
        container.innerHTML = '<div style="color:#888;font-size:0.9em;text-align:center;padding:20px;">Sin ataques recientes</div>';
        return;
      }

      container.innerHTML = toShow.map(attack => {
        const isRansomware = attack.type === 'ransomware';
        const isUrlhaus = attack.type === 'urlhaus';
        let className = 'attack-item';
        if (isRansomware) className = 'attack-item ransomware';
        if (isUrlhaus) className = 'attack-item urlhaus';
        
        let details = '';
        if (isRansomware) {
          details = `
            <div class="attack-type">üîí RANSOMWARE</div>
            <div class="attack-details">
              <strong>${attack.data.name}</strong><br>
              Grupo: ${attack.data.group}<br>
              Pa√≠s: ${attack.data.country}
            </div>
          `;
        } else if (isUrlhaus) {
          details = `
            <div class="attack-type">ü§ñ BOTNET C&C</div>
            <div class="attack-details">
              <strong>${attack.data.threat || 'Botnet'}</strong><br>
              IP: ${attack.data.host || 'N/D'}<br>
              Pa√≠s: ${attack.data.country || 'Desconocido'}
            </div>
          `;
        } else if (attack.type === 'threatfox') {
          details = `
            <div class="attack-type">üéØ IP MALWARE</div>
            <div class="attack-details">
              <strong>${attack.data.malware || 'Malware'}</strong><br>
              IP: ${attack.data.ioc || 'N/D'}<br>
              Pa√≠s: ${attack.data.country || 'Desconocido'}
            </div>
          `;
        } else if (attack.type === 'blocklist') {
          details = `
            <div class="attack-type">üõ°Ô∏è ATAQUE SSH/FTP</div>
            <div class="attack-details">
              IP: ${attack.data.ip}<br>
              Servicio: ${attack.data.service || 'N/D'}<br>
              Pa√≠s: ${attack.data.country || 'Desconocido'}
            </div>
          `;
        } else {
          details = `
            <div class="attack-type">üö® IP MALICIOSA</div>
            <div class="attack-details">
              IP: ${attack.data.ip}<br>
              Pa√≠s: ${attack.data.country || 'Desconocido'}
            </div>
          `;
        }
        
        const timeAgo = getTimeAgo(attack.timestamp);
        return `
          <div class="${className}" data-lat="${attack.data.lat}" data-lon="${attack.data.lon}">
            ${details}
            <div class="attack-time">${timeAgo}</div>
          </div>
        `;
      }).join('');

      // Agregar click handlers
      container.querySelectorAll('.attack-item').forEach(item => {
        item.addEventListener('click', () => {
          const lat = parseFloat(item.dataset.lat);
          const lon = parseFloat(item.dataset.lon);
          map.setView([lat, lon], 6, { animate: true });
        });
      });
    }

    function getTimeAgo(date) {
      const seconds = Math.floor((new Date() - date) / 1000);
      if (seconds < 60) return 'Hace unos segundos';
      if (seconds < 3600) return `Hace ${Math.floor(seconds / 60)} min`;
      if (seconds < 86400) return `Hace ${Math.floor(seconds / 3600)} h`;
      return `Hace ${Math.floor(seconds / 86400)} d√≠as`;
    }

    async function loadAttacks() {
      // Mostrar inmediatamente cache previa si existe
      if (lastEvents.length) {
        renderAttacks(lastEvents, { forcePulse: true });
      }

      let fetched = [];
      try {
        const ips = await fetchFireholIPs();
        const geos = await geolocateIPs(ips);
        fetched = filterAttacks(geos);
      } catch (e) {
        console.warn('No se pudieron cargar/geolocalizar IPs FireHOL', e);
      }

      if (fetched.length > 0) {
        lastEvents = fetched;
        try { localStorage.setItem(CACHE_KEY, JSON.stringify({ ts: Date.now(), data: fetched })); } catch(_) {}
        renderAttacks(fetched, { forcePulse: false });
        console.log(`‚úì Cyber eventos cargados (FireHOL+geo): ${fetched.length}`);
        return;
      }

      if (lastEvents.length) {
        console.warn('Eventos vac√≠os, reutilizando √∫ltimo dataset en cache');
        renderAttacks(lastEvents, { forcePulse: false });
        return;
      }

      console.warn('Sin datos (FireHOL+cache vac√≠os). No se muestran eventos.');
    }

    loadAttacks();
    setInterval(loadAttacks, 5 * 60 * 1000); // cada 5 min

    // --- CAPA DE RANSOMWARE (v√≠ctimas recientes desde Ransomware.live)
    const COUNTRY_COORDS = {
      'US': [37.09, -95.71], 'CA': [56.13, -106.34], 'MX': [23.63, -102.55],
      'BR': [-14.23, -51.92], 'AR': [-38.41, -63.61], 'CL': [-35.67, -71.54],
      'GB': [55.37, -3.43], 'FR': [46.22, 2.21], 'DE': [51.16, 10.45], 'IT': [41.87, 12.56],
      'ES': [40.46, -3.74], 'NL': [52.13, 5.29], 'BE': [50.50, 4.47], 'CH': [46.81, 8.22],
      'SE': [60.12, 18.64], 'NO': [60.47, 8.46], 'DK': [56.26, 9.50], 'FI': [61.92, 25.74],
      'PL': [51.91, 19.14], 'RU': [61.52, 105.31], 'UA': [48.37, 31.16], 'TR': [38.96, 35.24],
      'IN': [20.59, 78.96], 'CN': [35.86, 104.19], 'JP': [36.20, 138.25], 'KR': [35.90, 127.76],
      'AU': [-25.27, 133.77], 'NZ': [-40.90, 174.88], 'ZA': [-30.55, 22.93], 'EG': [26.82, 30.80],
      'IL': [31.04, 34.85], 'SA': [23.88, 45.07], 'AE': [23.42, 53.84], 'SG': [1.35, 103.81],
      'TH': [15.87, 100.99], 'VN': [14.05, 108.27], 'PH': [12.87, 121.77], 'ID': [-0.78, 113.92],
      'MY': [4.21, 101.97], 'CO': [4.57, -74.29], 'PE': [-9.18, -75.01], 'VE': [6.42, -66.58],
      'AT': [47.51, 14.55], 'CZ': [49.81, 15.47], 'PT': [39.39, -8.22], 'GR': [39.07, 21.82],
      'RO': [45.94, 24.96], 'HU': [47.16, 19.50], 'IE': [53.41, -8.24], 'HR': [45.10, 15.20],
      'RS': [44.01, 21.00], 'BG': [42.73, 25.48], 'SK': [48.66, 19.69], 'LT': [55.16, 23.88],
      'LV': [56.87, 24.60], 'EE': [58.59, 25.01], 'SI': [46.15, 14.99], 'LU': [49.81, 6.12]
    };

    async function loadRansomwareVictims() {
      // Mostrar cache inmediatamente si existe
      if (lastRansomwareVictims.length) {
        renderRansomwareVictims(lastRansomwareVictims, { forcePulse: true });
      }

      try {
        console.log('üîí Intentando cargar Ransomware.live...');
        // M√∫ltiples proxies CORS + directo
        const proxies = [
          `https://api.allorigins.win/get?url=${encodeURIComponent(RANSOMWARE_API)}`,
          `https://corsproxy.io/?${encodeURIComponent(RANSOMWARE_API)}`,
          `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(RANSOMWARE_API)}`,
          RANSOMWARE_API // Intentar directo como √∫ltimo recurso
        ];
        
        let data = null;
        let lastError = null;
        
        for (let i = 0; i < proxies.length; i++) {
          const proxyUrl = proxies[i];
          try {
            console.log(`  ‚Üí Probando proxy ${i+1}/${proxies.length}...`);
            const response = await fetch(proxyUrl, { cache: 'no-store' });
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            
            const responseData = await response.json();
            
            // allorigins.win devuelve { contents: "..." }
            if (responseData.contents) {
              data = JSON.parse(responseData.contents);
            } else {
              data = responseData;
            }
            
            if (Array.isArray(data) && data.length > 0) {
              console.log(`  ‚úì Proxy ${i+1} exitoso! (${data.length} v√≠ctimas)`);
              break;
            }
          } catch (e) {
            lastError = e;
            console.warn(`  ‚úó Proxy ${i+1} fall√≥: ${e.message}`);
          }
        }
        
        if (!data || !Array.isArray(data) || data.length === 0) {
          console.error('‚ùå RANSOMWARE.LIVE BLOQUEADO - Todos los proxies fallaron');
          throw lastError || new Error('Todos los proxies fallaron');
        }
        if (!Array.isArray(data) || data.length === 0) {
          console.warn('Ransomware API: sin datos v√°lidos');
          return;
        }

        // Filtrar y procesar v√≠ctimas con coordenadas v√°lidas
        const victims = data
          .filter(v => v.country && COUNTRY_COORDS[v.country])
          .slice(0, 100) // l√≠mite de 100 v√≠ctimas
          .map((v, idx) => {
            const [baseLat, baseLon] = COUNTRY_COORDS[v.country];
            // Agregar peque√±a variaci√≥n aleatoria para evitar superposici√≥n
            const lat = baseLat + (Math.random() - 0.5) * 4;
            const lon = baseLon + (Math.random() - 0.5) * 6;
            return {
              id: v.post_url || `victim-${idx}`,
              name: v.post_title || 'Desconocido',
              country: v.country,
              group: v.group_name || 'Desconocido',
              discovered: v.discovered || v.published || 'N/D',
              lat,
              lon
            };
          });

        if (victims.length > 0) {
          lastRansomwareVictims = victims;
          try {
            localStorage.setItem(RANSOMWARE_CACHE_KEY, JSON.stringify({ 
              ts: Date.now(), 
              data: victims 
            }));
          } catch(_) {}
          renderRansomwareVictims(victims, { forcePulse: false });
          console.log(`‚úÖ RANSOMWARE.LIVE: ${victims.length} v√≠ctimas cargadas`);
        }
      } catch (e) {
        console.error('‚ùå RANSOMWARE.LIVE FALL√ì:', e.message);
        if (lastRansomwareVictims.length) {
          console.log('  ‚Ü∫ Usando cache anterior (' + lastRansomwareVictims.length + ' v√≠ctimas)');
          renderRansomwareVictims(lastRansomwareVictims, { forcePulse: false });
        } else {
          console.warn('  ‚ö†Ô∏è Sin datos de Ransomware disponibles');
        }
      }
    }

    function renderRansomwareVictims(victims, { forcePulse = false } = {}) {
      if (!Array.isArray(victims) || !victims.length) return;
      console.log(`‚ñ∂ Pintando ${victims.length} v√≠ctimas de ransomware`);
      
      ransomwareLayer.clearLayers();

      victims.forEach(victim => {
        const circle = L.circleMarker([victim.lat, victim.lon], {
          radius: 8,
          color: '#f57c00',
          fillColor: '#ffb74d',
          fillOpacity: 0.7,
          weight: 2.5,
          opacity: 0.9
        }).addTo(ransomwareLayer);

        const discoveredDate = victim.discovered !== 'N/D' 
          ? new Date(victim.discovered).toLocaleDateString('es-ES')
          : 'N/D';

        circle.bindPopup(
          `<strong style="color:#ff8c00;">üîí V√≠ctima Ransomware</strong><br>` +
          `<strong>V√≠ctima:</strong> ${victim.name}<br>` +
          `<strong>Grupo:</strong> ${victim.group}<br>` +
          `<strong>Pa√≠s:</strong> ${victim.country}<br>` +
          `<strong>Descubierto:</strong> ${discoveredDate}`
        );

        const isNew = forcePulse || !previousRansomware.has(victim.id);
        if (isNew) {
          createPulse(victim.lat, victim.lon, '#f57c00', ransomwareLayer);
          addToRecentAttacks('ransomware', victim);
        }
        previousRansomware.add(victim.id);
      });

      updateCounters();
      
      // Si estamos en modo heatmap y hay datos nuevos, mostrar puntos temporalmente
      if (heatmapMode && victims.length > 0 && !forcePulse) {
        showNewPointsTemporarily(30000);
      } else if (heatmapMode) {
        updateHeatmap();
      }
    }

    loadRansomwareVictims();
    setInterval(loadRansomwareVictims, 10 * 60 * 1000); // cada 10 min

    // --- CAPA DE FEODO TRACKER (Botnets C&C)
    async function loadUrlhausUrls() {
      // Mostrar cache inmediatamente si existe (sin forzar pulsos en carga inicial)
      if (lastUrlhausUrls.length) {
        renderUrlhausUrls(lastUrlhausUrls, { forcePulse: false, append: false });
        console.log(`‚Ü∫ Mostrando ${lastUrlhausUrls.length} botnets desde cache`);
      }

      try {
        console.log('ü§ñ Cargando Feodo Tracker (Botnets)...');
        // Intentar con m√∫ltiples proxies CORS
        const proxies = [
          `https://api.allorigins.win/raw?url=${encodeURIComponent(FEODO_TRACKER_API)}`,
          `https://corsproxy.io/?${encodeURIComponent(FEODO_TRACKER_API)}`,
          FEODO_TRACKER_API // Directo como √∫ltimo recurso
        ];
        
        let response = null;
        let lastError = null;
        
        for (const proxyUrl of proxies) {
          try {
            response = await fetch(proxyUrl, { cache: 'no-store' });
            if (response.ok) {
              console.log(`‚úì Proxy exitoso: ${proxyUrl.substring(0, 30)}...`);
              break;
            }
          } catch (e) {
            lastError = e;
            console.warn(`Proxy fall√≥: ${proxyUrl.substring(0, 30)}...`);
          }
        }
        
        if (!response || !response.ok) throw lastError || new Error('Todos los proxies fallaron');
        
        const data = await response.json();
        console.log(`‚úì Feodo Tracker respondi√≥ con ${data.length} IPs de botnets`);
        
        // Procesar IPs de botnets C&C
        const processedUrls = [];
        const seenIps = new Set();
        
        // Filtrar IPs activas recientes (√∫ltimos 30 d√≠as)
        const now = new Date();
        const thirtyDaysAgo = new Date(now.getTime() - 30 * 24 * 60 * 60 * 1000);
        
        const recentBots = data
          .filter(item => {
            if (!item.ip_address) return false;
            // Incluir tanto online como offline recientes
            if (item.status === 'online') return true;
            if (item.last_online) {
              const lastOnline = new Date(item.last_online);
              return lastOnline > thirtyDaysAgo;
            }
            return false;
          })
          .slice(0, 120); // Aumentado para m√°s IPs
        
        console.log(`üìä ${recentBots.length} botnets encontrados, geolocalizando...`);
        
        let successCount = 0;
        let failCount = 0;
        
        for (const item of recentBots) {
          const ip = item.ip_address;
          
          if (seenIps.has(ip)) continue;
          seenIps.add(ip);
          
          // Intentar geolocalizar con reintentos
          let geoSuccess = false;
          for (let attempt = 1; attempt <= 2; attempt++) {
            try {
              const geo = await fetch(GEO_ENDPOINT(ip), { cache: 'no-store' }).then(r => r.json());
              if (geo && geo.success && typeof geo.latitude === 'number' && typeof geo.longitude === 'number') {
                processedUrls.push({
                  id: ip,
                  url: `${ip}:${item.port || 'N/D'}`,
                  host: ip,
                  threat: item.malware || 'Botnet C&C',
                  lat: geo.latitude,
                  lon: geo.longitude,
                  country: geo.country || 'N/D'
                });
                
                successCount++;
                console.log(`  ‚úì ${successCount}/${recentBots.length} - ${ip} (${item.malware || 'botnet'}) ‚Üí ${geo.country}`);
                geoSuccess = true;
                break;
              }
            } catch (e) {
              if (attempt === 2) {
                failCount++;
                console.warn(`  ‚úó Error geolocalizando ${ip} (2 intentos)`);
              }
              await delay(50); // Pausa breve antes de reintentar
            }
          }
          
          if (!geoSuccess) failCount++;
          
          await delay(100); // Throttle optimizado
          
          if (processedUrls.length >= 60) break;
        }
        
        console.log(`üìà Estad√≠sticas: ${successCount} √©xitos, ${failCount} fallos`);

        if (processedUrls.length > 0) {
          // Sistema acumulativo: agregar nuevos sin borrar anteriores
          const newBots = processedUrls.filter(bot => {
            return !lastUrlhausUrls.some(existing => existing.id === bot.id);
          });
          
          console.log(`üÜï ${newBots.length} botnets nuevos (${lastUrlhausUrls.length} existentes)`);
          
          // Agregar solo los nuevos a la lista
          lastUrlhausUrls.push(...newBots);
          
          // Guardar cache actualizado
          try {
            localStorage.setItem(URLHAUS_CACHE_KEY, JSON.stringify({ 
              ts: Date.now(), 
              data: lastUrlhausUrls 
            }));
          } catch(_) {}
          
          // Renderizar solo los nuevos con animaci√≥n
          if (newBots.length > 0) {
            renderUrlhausUrls(newBots, { forcePulse: true, append: true });
            console.log(`üéâ ${newBots.length} botnets nuevos agregados con pulsos morados!`);
          } else {
            console.log(`‚ÑπÔ∏è Sin botnets nuevos esta vez (todos ya estaban)`);
          }
          
          console.log(`‚úÖ FEODO TRACKER: Total ${lastUrlhausUrls.length} botnets acumulados`);
        }
      } catch (e) {
        console.error('‚ùå FEODO TRACKER FALL√ì:', e.message);
        if (lastUrlhausUrls.length) {
          console.log('  ‚Ü∫ Usando cache anterior (' + lastUrlhausUrls.length + ' botnets)');
          renderUrlhausUrls(lastUrlhausUrls, { forcePulse: false });
        } else {
          console.warn('  ‚ö†Ô∏è Sin datos de Feodo disponibles');
        }
      }
    }

    function renderUrlhausUrls(urls, { forcePulse = false, append = false } = {}) {
      if (!Array.isArray(urls) || !urls.length) return;
      console.log(`‚ñ∂ Pintando ${urls.length} servidores Botnet C&C (${append ? 'agregando' : 'reemplazando'})`);
      
      // Solo limpiar si no es modo append
      if (!append) {
        urlhausLayer.clearLayers();
      }

      urls.forEach(urlData => {
        const circle = L.circleMarker([urlData.lat, urlData.lon], {
          radius: 9,
          color: '#7b1fa2',
          fillColor: '#ba68c8',
          fillOpacity: 0.6,
          weight: 2.5,
          opacity: 0.9
        }).addTo(urlhausLayer);

        circle.bindPopup(
          `<strong style="color:#ba68c8;">ü§ñ Botnet C&C</strong><br>` +
          `<strong>Malware:</strong> ${urlData.threat}<br>` +
          `<strong>IP:</strong> ${urlData.host}<br>` +
          `<strong>Pa√≠s:</strong> ${urlData.country}<br>` +
          `<strong>Puerto:</strong> ${urlData.url.split(':')[1] || 'N/D'}`
        );

        const isNew = forcePulse || !previousUrlhaus.has(urlData.id);
        if (isNew) {
          createPulse(urlData.lat, urlData.lon, '#7b1fa2', urlhausLayer);
          addToRecentAttacks('urlhaus', urlData);
        }
        previousUrlhaus.add(urlData.id);
      });

      updateCounters();
      
      // Si estamos en modo heatmap y hay datos nuevos, mostrar puntos temporalmente
      if (heatmapMode && urls.length > 0 && append && forcePulse) {
        showNewPointsTemporarily(30000);
      } else if (heatmapMode) {
        updateHeatmap();
      }
    }

    loadUrlhausUrls();
    setInterval(loadUrlhausUrls, 15 * 60 * 1000); // cada 15 min

    // --- CAPA DE IPSUM (IPs Malware agregadas)
    async function loadThreatfoxIocs() {
      if (lastThreatfoxIocs.length) {
        renderThreatfoxIocs(lastThreatfoxIocs, { forcePulse: false, append: false });
        console.log(`‚Ü∫ Mostrando ${lastThreatfoxIocs.length} IPs desde cache`);
      }

      try {
        console.log('üü¢ Cargando IPsum (IPs Malware)...');
        // IPsum es un feed simple de texto, deber√≠a funcionar directo
        const response = await fetch(THREATFOX_API, { cache: 'no-store' });
        
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        
        const text = await response.text();
        
        // Parsear IPsum: formato "IP\tscore" (tab-separated)
        const lines = text.split('\n').filter(line => line && !line.startsWith('#'));
        const ips = [];
        
        for (const line of lines) {
          const parts = line.trim().split(/\s+/);
          if (parts[0] && /^\d+\.\d+\.\d+\.\d+$/.test(parts[0])) {
            const score = parseInt(parts[1]) || 1;
            ips.push({ ip: parts[0], score });
          }
        }
        
        // Ordenar por score (m√°s peligrosas primero)
        ips.sort((a, b) => b.score - a.score);
        const topIps = ips.slice(0, 80);
        
        console.log(`‚úì IPsum: ${topIps.length} IPs malware (score alto), geolocalizando...`);
        
        const processedIocs = [];
        const seenIps = new Set();
        let successCount = 0;
        
        for (const item of topIps) {
          const ip = item.ip;
          
          if (seenIps.has(ip)) continue;
          seenIps.add(ip);
          
          try {
            const geo = await fetch(GEO_ENDPOINT(ip), { cache: 'no-store' }).then(r => r.json());
            if (geo && geo.success && typeof geo.latitude === 'number' && typeof geo.longitude === 'number') {
              processedIocs.push({
                id: ip,
                ioc: ip,
                ip: ip,
                malware: `Malware (score: ${item.score})`,
                confidence: item.score,
                lat: geo.latitude,
                lon: geo.longitude,
                country: geo.country || 'N/D'
              });
              
              successCount++;
              if (successCount % 10 === 0) {
                console.log(`  ‚úì ${successCount}/${topIps.length} IPs geolocalizadas...`);
              }
            }
          } catch (e) {}
          
          await delay(100);
          
          if (processedIocs.length >= 50) break;
        }
        
        console.log(`‚úì IPsum: ${successCount} IPs geolocalizadas`);

        if (processedIocs.length > 0) {
          const newIocs = processedIocs.filter(ioc => 
            !lastThreatfoxIocs.some(existing => existing.id === ioc.id)
          );
          
          lastThreatfoxIocs.push(...newIocs);
          
          try {
            localStorage.setItem(THREATFOX_CACHE_KEY, JSON.stringify({ 
              ts: Date.now(), 
              data: lastThreatfoxIocs 
            }));
          } catch(_) {}
          
          if (newIocs.length > 0) {
            renderThreatfoxIocs(newIocs, { forcePulse: true, append: true });
            console.log(`üéâ ${newIocs.length} IPs malware nuevas!`);
          }
          
          console.log(`‚úÖ IPSUM: Total ${lastThreatfoxIocs.length} IPs`);
        }
      } catch (e) {
        console.error('‚ùå IPSUM FALL√ì:', e.message);
        if (lastThreatfoxIocs.length) {
          console.log('  ‚Ü∫ Usando cache anterior (' + lastThreatfoxIocs.length + ' IPs)');
          renderThreatfoxIocs(lastThreatfoxIocs, { forcePulse: false });
        } else {
          console.warn('  ‚ö†Ô∏è Sin datos de IPsum disponibles');
        }
      }
    }

    function renderThreatfoxIocs(iocs, { forcePulse = false, append = false } = {}) {
      if (!Array.isArray(iocs) || !iocs.length) return;
      console.log(`‚ñ∂ Pintando ${iocs.length} IOCs ThreatFox (${append ? 'agregando' : 'reemplazando'})`);
      
      if (!append) threatfoxLayer.clearLayers();

      iocs.forEach(ioc => {
        const circle = L.circleMarker([ioc.lat, ioc.lon], {
          radius: 9,
          color: '#e65100',
          fillColor: '#ff8a65',
          fillOpacity: 0.6,
          weight: 2.5,
          opacity: 0.9
        }).addTo(threatfoxLayer);

        circle.bindPopup(
          `<strong style="color:#ff6f00;">üéØ IP Malware</strong><br>` +
          `<strong>Tipo:</strong> ${ioc.malware}<br>` +
          `<strong>IP:</strong> ${ioc.ioc}<br>` +
          `<strong>Score:</strong> ${ioc.confidence}<br>` +
          `<strong>Pa√≠s:</strong> ${ioc.country}`
        );

        const isNew = forcePulse || !previousThreatfox.has(ioc.id);
        if (isNew) {
          createPulse(ioc.lat, ioc.lon, '#e65100', threatfoxLayer);
          addToRecentAttacks('threatfox', ioc);
        }
        previousThreatfox.add(ioc.id);
      });

      updateCounters();
      
      // Si estamos en modo heatmap y hay datos nuevos, mostrar puntos temporalmente
      if (heatmapMode && iocs.length > 0 && append && forcePulse) {
        showNewPointsTemporarily(30000);
      } else if (heatmapMode) {
        updateHeatmap();
      }
    }

    loadThreatfoxIocs();
    setInterval(loadThreatfoxIocs, 20 * 60 * 1000); // cada 20 min

    // --- CAPA DE BLOCKLIST.DE (Ataques SSH/FTP/Mail)
    async function loadBlocklistIps() {
      if (lastBlocklistIps.length) {
        renderBlocklistIps(lastBlocklistIps, { forcePulse: false, append: false });
        console.log(`‚Ü∫ Mostrando ${lastBlocklistIps.length} IPs atacantes desde cache`);
      }

      try {
        console.log('üõ°Ô∏è Cargando Blocklist.de...');
        const proxiedUrl = `https://api.allorigins.win/raw?url=${encodeURIComponent(BLOCKLIST_API)}`;
        const response = await fetch(proxiedUrl, { cache: 'no-store' });
        
        if (!response.ok) throw new Error(`HTTP ${response.status}`);
        
        const text = await response.text();
        const ips = text.split('\n')
          .map(line => line.trim())
          .filter(line => line && /^\d+\.\d+\.\d+\.\d+$/.test(line))
          .slice(0, 100);
        
        console.log(`‚úì Blocklist.de: ${ips.length} IPs, geolocalizando (r√°pido)...`);
        
        const processedIps = [];
        const seenIps = new Set();
        let successCount = 0;
        
        for (const ip of ips) {
          if (seenIps.has(ip)) continue;
          seenIps.add(ip);
          
          try {
            const geo = await fetch(GEO_ENDPOINT(ip), { cache: 'no-store' }).then(r => r.json());
            if (geo && geo.success && typeof geo.latitude === 'number' && typeof geo.longitude === 'number') {
              processedIps.push({
                id: ip,
                ip: ip,
                service: 'SSH/FTP/Mail',
                lat: geo.latitude,
                lon: geo.longitude,
                country: geo.country || 'N/D'
              });
              
              successCount++;
              if (successCount % 10 === 0) {
                console.log(`  ‚úì ${successCount}/${ips.length} atacantes geolocalizados...`);
              }
            }
          } catch (e) {}
          
          await delay(80);
          
          if (processedIps.length >= 50) break;
        }
        
        console.log(`‚úì Blocklist: ${successCount} IPs geolocalizadas (${ips.length - successCount} fallaron)`);

        if (processedIps.length > 0) {
          const newIps = processedIps.filter(ip => 
            !lastBlocklistIps.some(existing => existing.id === ip.id)
          );
          
          lastBlocklistIps.push(...newIps);
          
          try {
            localStorage.setItem(BLOCKLIST_CACHE_KEY, JSON.stringify({ 
              ts: Date.now(), 
              data: lastBlocklistIps 
            }));
          } catch(_) {}
          
          if (newIps.length > 0) {
            renderBlocklistIps(newIps, { forcePulse: true, append: true });
            console.log(`üéâ ${newIps.length} atacantes nuevos!`);
          }
          
          console.log(`‚úÖ BLOCKLIST.DE: Total ${lastBlocklistIps.length} IPs atacantes`);
        }
      } catch (e) {
        console.error('‚ùå BLOCKLIST.DE FALL√ì:', e.message);
        if (lastBlocklistIps.length) {
          console.log('  ‚Ü∫ Usando cache anterior (' + lastBlocklistIps.length + ' IPs)');
          renderBlocklistIps(lastBlocklistIps, { forcePulse: false });
        } else {
          console.warn('  ‚ö†Ô∏è Sin datos de Blocklist disponibles');
        }
      }
    }

    function renderBlocklistIps(ips, { forcePulse = false, append = false } = {}) {
      if (!Array.isArray(ips) || !ips.length) return;
      console.log(`‚ñ∂ Pintando ${ips.length} IPs atacantes Blocklist (${append ? 'agregando' : 'reemplazando'})`);
      
      if (!append) blocklistLayer.clearLayers();

      ips.forEach(ipData => {
        const circle = L.circleMarker([ipData.lat, ipData.lon], {
          radius: 9,
          color: '#0097a7',
          fillColor: '#4dd0e1',
          fillOpacity: 0.6,
          weight: 2.5,
          opacity: 0.9
        }).addTo(blocklistLayer);

        circle.bindPopup(
          `<strong style="color:#00bcd4;">üõ°Ô∏è Ataque SSH/FTP</strong><br>` +
          `<strong>IP Atacante:</strong> ${ipData.ip}<br>` +
          `<strong>Servicio:</strong> ${ipData.service}<br>` +
          `<strong>Pa√≠s:</strong> ${ipData.country}`
        );

        const isNew = forcePulse || !previousBlocklist.has(ipData.id);
        if (isNew) {
          createPulse(ipData.lat, ipData.lon, '#0097a7', blocklistLayer);
          addToRecentAttacks('blocklist', ipData);
        }
        previousBlocklist.add(ipData.id);
      });

      updateCounters();
      
      // Si estamos en modo heatmap y hay datos nuevos, mostrar puntos temporalmente
      if (heatmapMode && ips.length > 0 && append && forcePulse) {
        showNewPointsTemporarily(30000);
      } else if (heatmapMode) {
        updateHeatmap();
      }
    }

    loadBlocklistIps();
    setInterval(loadBlocklistIps, 20 * 60 * 1000); // cada 20 min

    // --- DASHBOARD DE ESTADO DE FUENTES ---
    function logSourcesStatus() {
      const total = lastEvents.length + lastRansomwareVictims.length + lastUrlhausUrls.length + lastThreatfoxIocs.length + lastBlocklistIps.length;
      console.log('\n' + '='.repeat(70));
      console.log('üìä ESTADO DE FUENTES DE DATOS DE CIBERSEGURIDAD');
      console.log('='.repeat(70));
      console.log(`üî¥ Firehol (IPs Maliciosas):        ${String(lastEvents.length).padEnd(3)} puntos ${lastEvents.length > 0 ? '‚úÖ' : '‚è≥'}`);
      console.log(`üü† IPsum (IPs Malware):             ${String(lastThreatfoxIocs.length).padEnd(3)} puntos ${lastThreatfoxIocs.length > 0 ? '‚úÖ' : '‚è≥'}`);
      console.log(`üü° Ransomware.live (V√≠ctimas):      ${String(lastRansomwareVictims.length).padEnd(3)} puntos ${lastRansomwareVictims.length === 0 ? '‚ùå BLOQUEADO' : '‚úÖ'}`);
      console.log(`üü£ Feodo Tracker (Botnets):         ${String(lastUrlhausUrls.length).padEnd(3)} puntos ${lastUrlhausUrls.length > 0 ? '‚úÖ' : '‚è≥'}`);
      console.log(`üîµ Blocklist.de (Ataques SSH/FTP):  ${String(lastBlocklistIps.length).padEnd(3)} puntos ${lastBlocklistIps.length > 0 ? '‚úÖ' : '‚è≥ Cargando...'}`);
      console.log('‚îÄ'.repeat(70));
      console.log(`üìç TOTAL EN MAPA: ${total} puntos de amenaza`);
      console.log('='.repeat(70) + '\n');
    }

    // Mostrar estado inicial
    setTimeout(() => logSourcesStatus(), 2000);
    // Actualizar cada 30 segundos mientras carga datos
    const statusInterval = setInterval(() => {
      logSourcesStatus();
    }, 30000);
    // Detener despu√©s de 5 minutos (ya habr√° cargado todo)
    setTimeout(() => clearInterval(statusInterval), 5 * 60 * 1000);

    // Inicializar en modo heatmap
    if (heatmapMode) {
      const btn = document.getElementById('heatmap-toggle');
      btn.classList.add('active');
      btn.textContent = 'üìç Modo Puntos';
      // Ocultar capas de puntos inicialmente
      map.removeLayer(attacksLayer);
      map.removeLayer(ransomwareLayer);
      map.removeLayer(urlhausLayer);
      map.removeLayer(threatfoxLayer);
      map.removeLayer(blocklistLayer);
      // El heatmap se activar√° cuando haya datos
    }

    // Inicializar UI
    updateCounters();
    updateAttacksList();

    // --- BARRA DE NOTICIAS (ciberseguridad, RSS)
    // Fuentes en espa√±ol
    const RSS_SOURCES = [
      'https://www.incibe-cert.es/alerta-temprana/avisos-seguridad/feed', // INCIBE-CERT avisos
      'https://www.ccn-cert.cni.es/feeds/avisos.xml',                    // CCN-CERT avisos
      'https://unaaldia.hispasec.com/feed',                             // Hispasec Una al d√≠a
      'https://www.welivesecurity.com/la-es/feed/'                      // ESET en espa√±ol
    ];

    const FALLBACK_NEWS = [
      { title: 'Sin noticias en vivo. Ciberseguridad en modo fallback.', link: '#' },
      { title: 'A√±ade m√°s RSS o revisa la conexi√≥n para ver alertas en tiempo real.', link: '#' }
    ];

    function shuffle(arr) {
      for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
      }
      return arr;
    }

    function parseRSS(xmlText) {
      const parser = new DOMParser();
      const doc = parser.parseFromString(xmlText, 'text/xml');
      const items = [...doc.querySelectorAll('item')].map(item => {
        const title = item.querySelector('title')?.textContent?.trim() || '';
        const link = item.querySelector('link')?.textContent?.trim() || '#';
        return title ? { title, link } : null;
      }).filter(Boolean);
      return items;
    }

    async function fetchFeed(url) {
      const proxied = `https://corsproxy.io/?${encodeURIComponent(url)}`;
      const res = await fetch(proxied, { cache: 'no-store' });
      const text = await res.text();
      return parseRSS(text);
    }

    async function loadNews() {
      const results = [];
      for (const src of RSS_SOURCES) {
        try {
          const items = await fetchFeed(src);
          if (items && items.length) {
            results.push(...items.slice(0, 8));
          }
        } catch (e) {
          console.warn('RSS fallo', src, e);
        }
      }
      if (!results.length) return FALLBACK_NEWS;
      return shuffle(results).slice(0, 40);
    }

    function renderTicker(items) {
      const inner = document.getElementById('noticias-inner');
      const sep = `<span style="color:#44c4ff;font-size:1.1em;font-weight:bold;">&nbsp;&nbsp;‚Ä¢&nbsp;&nbsp;</span>`;
      inner.innerHTML = items.map(n => `<span onclick="window.open('${n.link}', '_blank')" style="cursor:pointer;">${n.title}</span>`).join(sep);
      setTimeout(() => {
        const ancho = inner.offsetWidth / 2;
        const dur = Math.max(24, inner.textContent.length / 10);
        inner.getAnimations().forEach(a => a.cancel());
        inner.animate([
          { transform: "translateX(0)" },
          { transform: `translateX(-${ancho}px)` }
        ], {
          duration: dur * 1000,
          iterations: Infinity,
          easing: "linear"
        });
      }, 150);
    }

    async function startTicker() {
      if (isPreview) return; // no ticker en miniatura
      const items = await loadNews();
      renderTicker(items);
    }

    startTicker();
    setInterval(startTicker, 15 * 60 * 1000); // refresca cada 15 min

    // --- MODO HEATMAP MULTICOLOR ---
    function updateHeatmap() {
      // Limpiar capas anteriores
      heatmapLayers.forEach(layer => {
        if (map.hasLayer(layer)) map.removeLayer(layer);
      });
      heatmapLayers = [];

      if (!heatmapMode) return;

      // Heatmap ROJO para IPs maliciosas
      if (layersVisible.ips && lastEvents.length > 0) {
        const redData = lastEvents.map(ev => [ev.lat, ev.lon, 0.8]);
        const redHeat = L.heatLayer(redData, {
          radius: 30,
          blur: 40,
          maxZoom: 10,
          max: 0.6,
          minOpacity: 0.4,
          gradient: {
            0.0: 'rgba(211, 47, 47, 0)',
            0.2: 'rgba(211, 47, 47, 0.2)',
            0.4: 'rgba(229, 57, 53, 0.4)',
            0.6: 'rgba(244, 67, 54, 0.6)',
            0.8: 'rgba(255, 107, 107, 0.8)',
            1.0: 'rgba(255, 82, 82, 1.0)'
          }
        }).addTo(map);
        heatmapLayers.push(redHeat);
      }
      
      // Heatmap NARANJA para ransomware
      if (layersVisible.ransomware && lastRansomwareVictims.length > 0) {
        const orangeData = lastRansomwareVictims.map(v => [v.lat, v.lon, 1.0]);
        const orangeHeat = L.heatLayer(orangeData, {
          radius: 30,
          blur: 40,
          maxZoom: 10,
          max: 0.6,
          minOpacity: 0.4,
          gradient: {
            0.0: 'rgba(245, 124, 0, 0)',
            0.2: 'rgba(245, 124, 0, 0.2)',
            0.4: 'rgba(251, 140, 0, 0.4)',
            0.6: 'rgba(255, 152, 0, 0.6)',
            0.8: 'rgba(255, 183, 77, 0.8)',
            1.0: 'rgba(255, 204, 0, 1.0)'
          }
        }).addTo(map);
        heatmapLayers.push(orangeHeat);
      }

      // Heatmap MORADO para botnets
      if (layersVisible.urlhaus && lastUrlhausUrls.length > 0) {
        const purpleData = lastUrlhausUrls.map(u => [u.lat, u.lon, 0.9]);
        const purpleHeat = L.heatLayer(purpleData, {
          radius: 30,
          blur: 40,
          maxZoom: 10,
          max: 0.6,
          minOpacity: 0.4,
          gradient: {
            0.0: 'rgba(123, 31, 162, 0)',
            0.2: 'rgba(123, 31, 162, 0.2)',
            0.4: 'rgba(142, 36, 170, 0.4)',
            0.6: 'rgba(156, 39, 176, 0.6)',
            0.8: 'rgba(186, 104, 200, 0.8)',
            1.0: 'rgba(206, 147, 216, 1.0)'
          }
        }).addTo(map);
        heatmapLayers.push(purpleHeat);
      }

      // Heatmap NARANJA OSCURO para IPsum (IPs Malware)
      if (layersVisible.threatfox && lastThreatfoxIocs.length > 0) {
        const orangeData = lastThreatfoxIocs.map(ioc => [ioc.lat, ioc.lon, 0.85]);
        const orangeHeat = L.heatLayer(orangeData, {
          radius: 30,
          blur: 40,
          maxZoom: 10,
          max: 0.6,
          minOpacity: 0.4,
          gradient: {
            0.0: 'rgba(230, 81, 0, 0)',
            0.2: 'rgba(230, 81, 0, 0.2)',
            0.4: 'rgba(239, 108, 0, 0.4)',
            0.6: 'rgba(255, 111, 0, 0.6)',
            0.8: 'rgba(255, 138, 101, 0.8)',
            1.0: 'rgba(255, 171, 145, 1.0)'
          }
        }).addTo(map);
        heatmapLayers.push(orangeHeat);
      }

      // Heatmap CIAN para Blocklist
      if (layersVisible.blocklist && lastBlocklistIps.length > 0) {
        const cyanData = lastBlocklistIps.map(ip => [ip.lat, ip.lon, 0.75]);
        const cyanHeat = L.heatLayer(cyanData, {
          radius: 30,
          blur: 40,
          maxZoom: 10,
          max: 0.6,
          minOpacity: 0.4,
          gradient: {
            0.0: 'rgba(0, 151, 167, 0)',
            0.2: 'rgba(0, 151, 167, 0.2)',
            0.4: 'rgba(0, 172, 193, 0.4)',
            0.6: 'rgba(0, 188, 212, 0.6)',
            0.8: 'rgba(77, 208, 225, 0.8)',
            1.0: 'rgba(128, 222, 234, 1.0)'
          }
        }).addTo(map);
        heatmapLayers.push(cyanHeat);
      }
    }

    // --- TOGGLE DE CAPAS Y HEATMAP ---
    document.getElementById('legend-ips').addEventListener('click', () => {
      layersVisible.ips = !layersVisible.ips;
      const element = document.getElementById('legend-ips');
      
      if (layersVisible.ips) {
        map.addLayer(attacksLayer);
        element.classList.remove('disabled');
      } else {
        map.removeLayer(attacksLayer);
        element.classList.add('disabled');
      }
      
      if (heatmapMode) updateHeatmap();
    });

    document.getElementById('legend-ransomware').addEventListener('click', () => {
      layersVisible.ransomware = !layersVisible.ransomware;
      const element = document.getElementById('legend-ransomware');
      
      if (layersVisible.ransomware) {
        map.addLayer(ransomwareLayer);
        element.classList.remove('disabled');
      } else {
        map.removeLayer(ransomwareLayer);
        element.classList.add('disabled');
      }
      
      if (heatmapMode) updateHeatmap();
    });

    document.getElementById('legend-urlhaus').addEventListener('click', () => {
      layersVisible.urlhaus = !layersVisible.urlhaus;
      const element = document.getElementById('legend-urlhaus');
      
      if (layersVisible.urlhaus) {
        map.addLayer(urlhausLayer);
        element.classList.remove('disabled');
      } else {
        map.removeLayer(urlhausLayer);
        element.classList.add('disabled');
      }
      
      if (heatmapMode) updateHeatmap();
    });

    document.getElementById('legend-threatfox').addEventListener('click', () => {
      layersVisible.threatfox = !layersVisible.threatfox;
      const element = document.getElementById('legend-threatfox');
      
      if (layersVisible.threatfox) {
        map.addLayer(threatfoxLayer);
        element.classList.remove('disabled');
      } else {
        map.removeLayer(threatfoxLayer);
        element.classList.add('disabled');
      }
      
      if (heatmapMode) updateHeatmap();
    });

    document.getElementById('legend-blocklist').addEventListener('click', () => {
      layersVisible.blocklist = !layersVisible.blocklist;
      const element = document.getElementById('legend-blocklist');
      
      if (layersVisible.blocklist) {
        map.addLayer(blocklistLayer);
        element.classList.remove('disabled');
      } else {
        map.removeLayer(blocklistLayer);
        element.classList.add('disabled');
      }
      
      if (heatmapMode) updateHeatmap();
    });

    // Funci√≥n para mostrar puntos temporalmente cuando llegan datos nuevos
    function showNewPointsTemporarily(duration = 30000) {
      // Limpiar timeout previo si existe
      if (temporaryPointsTimeout) {
        clearTimeout(temporaryPointsTimeout);
      }
      
      // Mostrar puntos
      if (layersVisible.ips) map.addLayer(attacksLayer);
      if (layersVisible.ransomware) map.addLayer(ransomwareLayer);
      if (layersVisible.urlhaus) map.addLayer(urlhausLayer);
      if (layersVisible.threatfox) map.addLayer(threatfoxLayer);
      if (layersVisible.blocklist) map.addLayer(blocklistLayer);
      
      // Ocultar heatmap temporalmente
      heatmapLayers.forEach(layer => {
        if (map.hasLayer(layer)) map.removeLayer(layer);
      });
      
      console.log(`üé¨ Mostrando puntos nuevos con animaci√≥n (${duration/1000}s)...`);
      
      // Volver a heatmap despu√©s del tiempo especificado
      temporaryPointsTimeout = setTimeout(() => {
        console.log('üî• Volviendo a modo mapa de calor...');
        map.removeLayer(attacksLayer);
        map.removeLayer(ransomwareLayer);
        map.removeLayer(urlhausLayer);
        map.removeLayer(threatfoxLayer);
        map.removeLayer(blocklistLayer);
        updateHeatmap();
      }, duration);
    }

    document.getElementById('heatmap-toggle').addEventListener('click', function() {
      heatmapMode = !heatmapMode;
      
      // Limpiar timeout de puntos temporales
      if (temporaryPointsTimeout) {
        clearTimeout(temporaryPointsTimeout);
        temporaryPointsTimeout = null;
      }
      
      if (heatmapMode) {
        // Activar heatmap: ocultar marcadores
        this.classList.add('active');
        this.textContent = 'üìç Modo Puntos';
        map.removeLayer(attacksLayer);
        map.removeLayer(ransomwareLayer);
        map.removeLayer(urlhausLayer);
        map.removeLayer(threatfoxLayer);
        map.removeLayer(blocklistLayer);
        updateHeatmap();
      } else {
        // Desactivar heatmap: mostrar marcadores
        this.classList.remove('active');
        this.textContent = 'üî• Modo Mapa de Calor';
        if (layersVisible.ips) map.addLayer(attacksLayer);
        if (layersVisible.ransomware) map.addLayer(ransomwareLayer);
        if (layersVisible.urlhaus) map.addLayer(urlhausLayer);
        if (layersVisible.threatfox) map.addLayer(threatfoxLayer);
        if (layersVisible.blocklist) map.addLayer(blocklistLayer);
        heatmapLayers.forEach(layer => {
          if (map.hasLayer(layer)) map.removeLayer(layer);
        });
        heatmapLayers = [];
      }
    });

    // Toggle leyenda
    document.getElementById('legend-header').addEventListener('click', function() {
      document.getElementById('legend').classList.toggle('collapsed');
    });

    // Toggle lista de ataques
    document.getElementById('attacks-header').addEventListener('click', function() {
      document.getElementById('recent-attacks').classList.toggle('collapsed');
    });

    // Bot√≥n de reset
    document.getElementById('reset-view').addEventListener('click', resetMapView);
  </script>
</body>
</html>

